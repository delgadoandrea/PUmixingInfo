// Generated at Thu Feb  5 21:45:21 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9/GCC/4.7" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/SimDataFormats/GeneratorProducts/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"

#include <iostream>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("HepMC") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("gen") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("lhef") );
  ::Reflex::Type type_67 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1441 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_2169 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_796 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_173 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_102 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_198 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_3453 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::Flow"));
  ::Reflex::Type type_4043 = ::Reflex::TypeBuilder(Reflex::Literal("gen::PdfInfo"));
  ::Reflex::Type type_4728 = ::Reflex::TypeBuilder(Reflex::Literal("lhef::HEPEUP"));
  ::Reflex::Type type_293 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_4729 = ::Reflex::TypeBuilder(Reflex::Literal("lhef::HEPRUP"));
  ::Reflex::Type type_866 = ::Reflex::TypeBuilder(Reflex::Literal("GenFilterInfo"));
  ::Reflex::Type type_4173 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_432 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_459 = ::Reflex::TypeBuilder(Reflex::Literal("LHEEventProduct"));
  ::Reflex::Type type_2442 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<int>"));
  ::Reflex::Type type_3447 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::PdfInfo"));
  ::Reflex::Type type_4207 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_70 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_3486 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenEvent"));
  ::Reflex::Type type_3459 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::HeavyIon"));
  ::Reflex::Type type_4248 = ::Reflex::TypeBuilder(Reflex::Literal("gen::WeightsInfo"));
  ::Reflex::Type type_818 = ::Reflex::TypeBuilder(Reflex::Literal("LHERunInfoProduct"));
  ::Reflex::Type type_3482 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenVertex"));
  ::Reflex::Type type_2802 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_1341 = ::Reflex::TypeBuilder(Reflex::Literal("GenRunInfoProduct"));
  ::Reflex::Type type_4198 = ::Reflex::TypeBuilder(Reflex::Literal("edm::HepMCProduct"));
  ::Reflex::Type type_2914 = ::Reflex::TypeBuilder(Reflex::Literal("std::greater<int>"));
  ::Reflex::Type type_3455 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::FourVector"));
  ::Reflex::Type type_2958 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_2808 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long>"));
  ::Reflex::Type type_2806 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_341 = ::Reflex::TypeBuilder(Reflex::Literal("GenEventInfoProduct"));
  ::Reflex::Type type_690 = ::Reflex::TypeBuilder(Reflex::Literal("LHEXMLStringProduct"));
  ::Reflex::Type type_1920 = ::Reflex::TypeBuilder(Reflex::Literal("GenLumiInfoProduct"));
  ::Reflex::Type type_2767 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,int>"));
  ::Reflex::Type type_3450 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenParticle"));
  ::Reflex::Type type_3458 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::ThreeVector"));
  ::Reflex::Type type_2807 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_3475 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::Polarization"));
  ::Reflex::Type type_4195 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_3448 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenCrossSection"));
  ::Reflex::Type type_3474 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::WeightContainer"));
  ::Reflex::Type type_2319 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_5075 = ::Reflex::TypeBuilder(Reflex::Literal("GenRunInfoProduct::XSec"));
  ::Reflex::Type type_4182 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<int>"));
  ::Reflex::Type type_2768 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<double,double>"));
  ::Reflex::Type type_5599 = ::Reflex::TypeBuilder(Reflex::Literal("GenLumiInfoProduct::XSec"));
  ::Reflex::Type type_3457 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HepMC::IteratorRange"));
  ::Reflex::Type type_2799 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_4660 = ::Reflex::TypeBuilder(Reflex::Literal("LHERunInfoProduct::Header"));
  ::Reflex::Type type_2898 = ::Reflex::TypeBuilder(Reflex::Literal("std::forward_iterator_tag"));
  ::Reflex::Type type_10846 = ::Reflex::TypeBuilder(Reflex::Literal("lhef::HEPEUP::FiveVector"));
  ::Reflex::Type type_3456 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenParticleEndRange"));
  ::Reflex::Type type_3473 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenEventVertexRange"));
  ::Reflex::Type type_2800 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2551 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<gen::PdfInfo>"));
  ::Reflex::Type type_4108 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<GenFilterInfo>"));
  ::Reflex::Type type_3479 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenEventParticleRange"));
  ::Reflex::Type type_2548 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<GenFilterInfo>"));
  ::Reflex::Type type_2801 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<gen::WeightsInfo>"));
  ::Reflex::Type type_5601 = ::Reflex::TypeBuilder(Reflex::Literal("GenLumiInfoProduct::FinalStat"));
  ::Reflex::Type type_3483 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenVertexParticleRange"));
  ::Reflex::Type type_15161 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HepMC::Units::LengthUnit"));
  ::Reflex::Type type_4104 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<LHEEventProduct>"));
  ::Reflex::Type type_2544 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<LHEEventProduct>"));
  ::Reflex::Type type_4205 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<edm::HepMCProduct>"));
  ::Reflex::Type type_4238 = ::Reflex::TypeBuilder(Reflex::Literal("LHEEventProduct::const_iterator"));
  ::Reflex::Type type_2477 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr_ref<gen::PdfInfo>"));
  ::Reflex::Type type_5600 = ::Reflex::TypeBuilder(Reflex::Literal("GenLumiInfoProduct::ProcessInfo"));
  ::Reflex::Type type_2957 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,HepMC::GenVertex*>"));
  ::Reflex::Type type_3485 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::ConstGenParticleEndRange"));
  ::Reflex::Type type_15160 = ::Reflex::EnumTypeBuilder(Reflex::Literal("HepMC::Units::MomentumUnit"));
  ::Reflex::Type type_3477 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::ConstGenEventVertexRange"));
  ::Reflex::Type type_4156 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<edm::HepMCProduct>"));
  ::Reflex::Type type_4105 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<LHERunInfoProduct>"));
  ::Reflex::Type type_4109 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<GenRunInfoProduct>"));
  ::Reflex::Type type_4110 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::HepMCProduct>"));
  ::Reflex::Type type_3047 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<gen::WeightsInfo>"));
  ::Reflex::Type type_2804 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HepMC::GenParticle*>"));
  ::Reflex::Type type_2815 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<int,int> >"));
  ::Reflex::Type type_2545 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<LHERunInfoProduct>"));
  ::Reflex::Type type_2549 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<GenRunInfoProduct>"));
  ::Reflex::Type type_2550 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::HepMCProduct>"));
  ::Reflex::Type type_4106 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<GenLumiInfoProduct>"));
  ::Reflex::Type type_4655 = ::Reflex::TypeBuilder(Reflex::Literal("LHERunInfoProduct::const_iterator"));
  ::Reflex::Type type_2956 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,HepMC::GenParticle*>"));
  ::Reflex::Type type_3481 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenParticleProductionRange"));
  ::Reflex::Type type_3480 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::ConstGenEventParticleRange"));
  ::Reflex::Type type_15546 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenEvent::vertex_iterator"));
  ::Reflex::Type type_2546 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<GenLumiInfoProduct>"));
  ::Reflex::Type type_4103 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<LHEXMLStringProduct>"));
  ::Reflex::Type type_4107 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<GenEventInfoProduct>"));
  ::Reflex::Type type_15460 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenVertex::vertex_iterator"));
  ::Reflex::Type type_2543 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<LHEXMLStringProduct>"));
  ::Reflex::Type type_2547 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<GenEventInfoProduct>"));
  ::Reflex::Type type_4145 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<edm::HepMCProduct>"));
  ::Reflex::Type type_3050 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HepMC::GenParticle*>"));
  ::Reflex::Type type_15548 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenEvent::particle_iterator"));
  ::Reflex::Type type_4175 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_15461 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenVertex::particle_iterator"));
  ::Reflex::Type type_4117 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<GenFilterInfo>"));
  ::Reflex::Type type_4162 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<edm::HepMCProduct>"));
  ::Reflex::Type type_2811 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_2803 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const edm::HepMCProduct*>"));
  ::Reflex::Type type_2814 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>"));
  ::Reflex::Type type_2812 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<LHERunInfoProduct::Header>"));
  ::Reflex::Type type_2751 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,HepMC::GenVertex*>"));
  ::Reflex::Type type_3478 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::ConstGenParticleProductionRange"));
  ::Reflex::Type type_4113 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<LHEEventProduct>"));
  ::Reflex::Type type_15545 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenEvent::vertex_const_iterator"));
  ::Reflex::Type type_2752 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,HepMC::GenParticle*>"));
  ::Reflex::Type type_3049 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<const edm::HepMCProduct*>"));
  ::Reflex::Type type_3069 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<lhef::HEPEUP::FiveVector>"));
  ::Reflex::Type type_4114 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<LHERunInfoProduct>"));
  ::Reflex::Type type_4118 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<GenRunInfoProduct>"));
  ::Reflex::Type type_4119 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::HepMCProduct>"));
  ::Reflex::Type type_3067 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<LHERunInfoProduct::Header>"));
  ::Reflex::Type type_15547 = ::Reflex::TypeBuilder(Reflex::Literal("HepMC::GenEvent::particle_const_iterator"));
  ::Reflex::Type type_4115 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<GenLumiInfoProduct>"));
  ::Reflex::Type type_4112 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<LHEXMLStringProduct>"));
  ::Reflex::Type type_4116 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<GenEventInfoProduct>"));
  ::Reflex::Type type_2805 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>"));
  ::Reflex::Type type_3054 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<GenLumiInfoProduct::ProcessInfo>"));
  ::Reflex::Type type_2954 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,unsigned long>"));
  ::Reflex::Type type_2199 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_1779 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_istream<char,std::char_traits<char> >"));
  ::Reflex::Type type_2893 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,int> >"));
  ::Reflex::Type type_2955 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >"));
  ::Reflex::Type type_2756 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<HepMC::GenParticle*,HepMC::GenParticle*>"));
  ::Reflex::Type type_4018 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3051 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,HepMC::GenVertex*> >"));
  ::Reflex::Type type_2597 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,int> >"));
  ::Reflex::Type type_3052 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,HepMC::GenParticle*> >"));
  ::Reflex::Type type_5436 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<double*,std::vector<double> >"));
  ::Reflex::Type type_5514 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<gen::WeightsInfo> >"));
  ::Reflex::Type type_5509 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<HepMC::GenParticle*> >"));
  ::Reflex::Type type_2891 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >"));
  ::Reflex::Type type_5435 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const double*,std::vector<double> >"));
  ::Reflex::Type type_2892 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >"));
  ::Reflex::Type type_5506 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<const edm::HepMCProduct*> >"));
  ::Reflex::Type type_5515 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<lhef::HEPEUP::FiveVector> >"));
  ::Reflex::Type type_15959 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find"));
  ::Reflex::Type type_2294 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<gen::WeightsInfo,std::allocator<gen::WeightsInfo> >"));
  ::Reflex::Type type_5512 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<LHERunInfoProduct::Header> >"));
  ::Reflex::Type type_2595 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >"));
  ::Reflex::Type type_15970 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find"));
  ::Reflex::Type type_2596 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >"));
  ::Reflex::Type type_2813 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_2289 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> >"));
  ::Reflex::Type type_5507 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<GenLumiInfoProduct::ProcessInfo> >"));
  ::Reflex::Type type_5444 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >"));
  ::Reflex::Type type_2755 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >,bool>"));
  ::Reflex::Type type_2894 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >"));
  ::Reflex::Type type_2759 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >,bool>"));
  ::Reflex::Type type_18425 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<HepMC::GenVertex> >"));
  ::Reflex::Type type_5445 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const gen::WeightsInfo*,std::vector<gen::WeightsInfo> >"));
  ::Reflex::Type type_5434 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >"));
  ::Reflex::Type type_2286 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> >"));
  ::Reflex::Type type_2295 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> >"));
  ::Reflex::Type type_2598 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >"));
  ::Reflex::Type type_18427 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<HepMC::GenParticle> >"));
  ::Reflex::Type type_2292 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> >"));
  ::Reflex::Type type_3190 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> > >"));
  ::Reflex::Type type_3196 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> > >"));
  ::Reflex::Type type_5433 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> >"));
  ::Reflex::Type type_3189 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> > >"));
  ::Reflex::Type type_5427 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >"));
  ::Reflex::Type type_5446 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >"));
  ::Reflex::Type type_3195 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> > >"));
  ::Reflex::Type type_5441 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >"));
  ::Reflex::Type type_4250 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_2287 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> >"));
  ::Reflex::Type type_5428 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::HepMCProduct* const*,std::vector<const edm::HepMCProduct*> >"));
  ::Reflex::Type type_5447 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >"));
  ::Reflex::Type type_2677 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>"));
  ::Reflex::Type type_4662 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >"));
  ::Reflex::Type type_3212 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> > >"));
  ::Reflex::Type type_2676 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>"));
  ::Reflex::Type type_3211 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const gen::WeightsInfo*,std::vector<gen::WeightsInfo> > >"));
  ::Reflex::Type type_3200 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> > >"));
  ::Reflex::Type type_5429 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >"));
  ::Reflex::Type type_4196 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>"));
  ::Reflex::Type type_3199 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> > >"));
  ::Reflex::Type type_5430 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >"));
  ::Reflex::Type type_4197 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>"));
  ::Reflex::Type type_3188 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> > >"));
  ::Reflex::Type type_3214 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> > >"));
  ::Reflex::Type type_4093 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>"));
  ::Reflex::Type type_3208 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> > >"));
  ::Reflex::Type type_4094 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>"));
  ::Reflex::Type type_3187 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::HepMCProduct* const*,std::vector<const edm::HepMCProduct*> > >"));
  ::Reflex::Type type_3213 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> > >"));
  ::Reflex::Type type_3207 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> > >"));
  ::Reflex::Type type_4077 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>"));
  ::Reflex::Type type_4078 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>"));
  ::Reflex::Type type_3192 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> > >"));
  ::Reflex::Type type_3191 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> > >"));
  ::Reflex::Type type_2754 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >,std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> > >"));
  ::Reflex::Type type_2758 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >,std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> > >"));
  ::Reflex::Type type_2753 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >,std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> > >"));
  ::Reflex::Type type_2757 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >,std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> > >"));
  ::Reflex::Type type_18426 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >"));
  ::Reflex::Type type_18428 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >"));
  ::Reflex::Type type_2493 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,HepMC::GenVertex*>,std::_Select1st<std::pair<const int,HepMC::GenVertex*> >,std::less<int>,std::allocator<std::pair<const int,HepMC::GenVertex*> > >"));
  ::Reflex::Type type_2495 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,HepMC::GenVertex*>,std::_Select1st<std::pair<const int,HepMC::GenVertex*> >,std::greater<int>,std::allocator<std::pair<const int,HepMC::GenVertex*> > >"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,HepMC::GenParticle*>,std::_Select1st<std::pair<const int,HepMC::GenParticle*> >,std::less<int>,std::allocator<std::pair<const int,HepMC::GenParticle*> > >"));
  ::Reflex::Type type_3486c = ::Reflex::ConstBuilder(type_3486);
  ::Reflex::Type type_18345 = ::Reflex::PointerBuilder(type_3486c);
  ::Reflex::Type type_341c = ::Reflex::ConstBuilder(type_341);
  ::Reflex::Type type_18346 = ::Reflex::ReferenceBuilder(type_341c);
  ::Reflex::Type type_18347 = ::Reflex::ReferenceBuilder(type_341);
  ::Reflex::Type type_2807c = ::Reflex::ConstBuilder(type_2807);
  ::Reflex::Type type_9222 = ::Reflex::ReferenceBuilder(type_2807c);
  ::Reflex::Type type_4043c = ::Reflex::ConstBuilder(type_4043);
  ::Reflex::Type type_18348 = ::Reflex::PointerBuilder(type_4043c);
  ::Reflex::Type type_2806c = ::Reflex::ConstBuilder(type_2806);
  ::Reflex::Type type_18349 = ::Reflex::ReferenceBuilder(type_2806c);
  ::Reflex::Type type_3033 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_293);
  ::Reflex::Type type_19216 = ::Reflex::ReferenceBuilder(type_459);
  ::Reflex::Type type_4728c = ::Reflex::ConstBuilder(type_4728);
  ::Reflex::Type type_19217 = ::Reflex::ReferenceBuilder(type_4728c);
  ::Reflex::Type type_102c = ::Reflex::ConstBuilder(type_102);
  ::Reflex::Type type_19218 = ::Reflex::ReferenceBuilder(type_4043c);
  ::Reflex::Type type_4248c = ::Reflex::ConstBuilder(type_4248);
  ::Reflex::Type type_10085 = ::Reflex::ReferenceBuilder(type_4248c);
  ::Reflex::Type type_2320 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2319);
  ::Reflex::Type type_2320c = ::Reflex::ConstBuilder(type_2320);
  ::Reflex::Type type_12177 = ::Reflex::ReferenceBuilder(type_2320c);
  ::Reflex::Type type_2801c = ::Reflex::ConstBuilder(type_2801);
  ::Reflex::Type type_19219 = ::Reflex::ReferenceBuilder(type_2801c);
  ::Reflex::Type type_19666 = ::Reflex::ReferenceBuilder(type_690);
  ::Reflex::Type type_690c = ::Reflex::ConstBuilder(type_690);
  ::Reflex::Type type_19667 = ::Reflex::ReferenceBuilder(type_690c);
  ::Reflex::Type type_2811c = ::Reflex::ConstBuilder(type_2811);
  ::Reflex::Type type_9219 = ::Reflex::ReferenceBuilder(type_2811c);
  ::Reflex::Type type_19755 = ::Reflex::ReferenceBuilder(type_818);
  ::Reflex::Type type_818c = ::Reflex::ConstBuilder(type_818);
  ::Reflex::Type type_19756 = ::Reflex::ReferenceBuilder(type_818c);
  ::Reflex::Type type_4729c = ::Reflex::ConstBuilder(type_4729);
  ::Reflex::Type type_19757 = ::Reflex::ReferenceBuilder(type_4729c);
  ::Reflex::Type type_4660c = ::Reflex::ConstBuilder(type_4660);
  ::Reflex::Type type_6902 = ::Reflex::ReferenceBuilder(type_4660c);
  ::Reflex::Type type_19758 = ::Reflex::ReferenceBuilder(type_866);
  ::Reflex::Type type_866c = ::Reflex::ConstBuilder(type_866);
  ::Reflex::Type type_19759 = ::Reflex::ReferenceBuilder(type_866c);
  ::Reflex::Type type_19889 = ::Reflex::ReferenceBuilder(type_1341);
  ::Reflex::Type type_1341c = ::Reflex::ConstBuilder(type_1341);
  ::Reflex::Type type_19890 = ::Reflex::ReferenceBuilder(type_1341c);
  ::Reflex::Type type_5075c = ::Reflex::ConstBuilder(type_5075);
  ::Reflex::Type type_19891 = ::Reflex::ReferenceBuilder(type_5075c);
  ::Reflex::Type type_22389 = ::Reflex::ReferenceBuilder(type_1920);
  ::Reflex::Type type_1920c = ::Reflex::ConstBuilder(type_1920);
  ::Reflex::Type type_22390 = ::Reflex::ReferenceBuilder(type_1920c);
  ::Reflex::Type type_67c = ::Reflex::ConstBuilder(type_67);
  ::Reflex::Type type_2805c = ::Reflex::ConstBuilder(type_2805);
  ::Reflex::Type type_22391 = ::Reflex::ReferenceBuilder(type_2805c);
  ::Reflex::Type type_24124 = ::Reflex::ReferenceBuilder(type_4043);
  ::Reflex::Type type_23991 = ::Reflex::PointerBuilder(type_4043);
  ::Reflex::Type type_24123 = ::Reflex::ReferenceBuilder(type_2551);
  ::Reflex::Type type_6865 = ::Reflex::PointerBuilder(type_3450);
  ::Reflex::Type type_6231 = ::Reflex::PointerBuilder(type_6865);
  ::Reflex::Type type_9241 = ::Reflex::ReferenceBuilder(type_6865);
  ::Reflex::Type type_24186 = ::Reflex::ReferenceBuilder(type_2676);
  ::Reflex::Type type_2676c = ::Reflex::ConstBuilder(type_2676);
  ::Reflex::Type type_24187 = ::Reflex::ReferenceBuilder(type_2676c);
  ::Reflex::Type type_9248 = ::Reflex::PointerBuilder(type_3482);
  ::Reflex::Type type_9251 = ::Reflex::PointerBuilder(type_9248);
  ::Reflex::Type type_9253 = ::Reflex::ReferenceBuilder(type_9248);
  ::Reflex::Type type_24188 = ::Reflex::ReferenceBuilder(type_2677);
  ::Reflex::Type type_2677c = ::Reflex::ConstBuilder(type_2677);
  ::Reflex::Type type_24189 = ::Reflex::ReferenceBuilder(type_2677c);
  ::Reflex::Type type_2751c = ::Reflex::ConstBuilder(type_2751);
  ::Reflex::Type type_7884 = ::Reflex::ReferenceBuilder(type_2751c);
  ::Reflex::Type type_10150 = ::Reflex::ReferenceBuilder(type_67c);
  ::Reflex::Type type_9248c = ::Reflex::ConstBuilder(type_9248);
  ::Reflex::Type type_24290 = ::Reflex::ReferenceBuilder(type_9248c);
  ::Reflex::Type type_2752c = ::Reflex::ConstBuilder(type_2752);
  ::Reflex::Type type_7989 = ::Reflex::ReferenceBuilder(type_2752c);
  ::Reflex::Type type_6865c = ::Reflex::ConstBuilder(type_6865);
  ::Reflex::Type type_6870 = ::Reflex::ReferenceBuilder(type_6865c);
  ::Reflex::Type type_10083 = ::Reflex::ReferenceBuilder(type_4248);
  ::Reflex::Type type_6325 = ::Reflex::PointerBuilder(type_4248);
  ::Reflex::Type type_10081 = ::Reflex::PointerBuilder(type_4248c);
  ::Reflex::Type type_2927 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_62);
  ::Reflex::Type type_3047c = ::Reflex::ConstBuilder(type_3047);
  ::Reflex::Type type_23489 = ::Reflex::ReferenceBuilder(type_3047c);
  ::Reflex::Type type_24312 = ::Reflex::ReferenceBuilder(type_2801);
  ::Reflex::Type type_4198c = ::Reflex::ConstBuilder(type_4198);
  ::Reflex::Type type_10205 = ::Reflex::PointerBuilder(type_4198c);
  ::Reflex::Type type_6175 = ::Reflex::PointerBuilder(type_10205);
  ::Reflex::Type type_10205c = ::Reflex::ConstBuilder(type_10205);
  ::Reflex::Type type_10212 = ::Reflex::PointerBuilder(type_10205c);
  ::Reflex::Type type_10214 = ::Reflex::ReferenceBuilder(type_10205);
  ::Reflex::Type type_10216 = ::Reflex::ReferenceBuilder(type_10205c);
  ::Reflex::Type type_3049c = ::Reflex::ConstBuilder(type_3049);
  ::Reflex::Type type_23385 = ::Reflex::ReferenceBuilder(type_3049c);
  ::Reflex::Type type_2803c = ::Reflex::ConstBuilder(type_2803);
  ::Reflex::Type type_24316 = ::Reflex::ReferenceBuilder(type_2803c);
  ::Reflex::Type type_24317 = ::Reflex::ReferenceBuilder(type_2803);
  ::Reflex::Type type_6868 = ::Reflex::PointerBuilder(type_6865c);
  ::Reflex::Type type_3050c = ::Reflex::ConstBuilder(type_3050);
  ::Reflex::Type type_23424 = ::Reflex::ReferenceBuilder(type_3050c);
  ::Reflex::Type type_2804c = ::Reflex::ConstBuilder(type_2804);
  ::Reflex::Type type_24318 = ::Reflex::ReferenceBuilder(type_2804c);
  ::Reflex::Type type_24319 = ::Reflex::ReferenceBuilder(type_2804);
  ::Reflex::Type type_10341 = ::Reflex::ReferenceBuilder(type_5600);
  ::Reflex::Type type_5600c = ::Reflex::ConstBuilder(type_5600);
  ::Reflex::Type type_10343 = ::Reflex::ReferenceBuilder(type_5600c);
  ::Reflex::Type type_6194 = ::Reflex::PointerBuilder(type_5600);
  ::Reflex::Type type_10339 = ::Reflex::PointerBuilder(type_5600c);
  ::Reflex::Type type_3054c = ::Reflex::ConstBuilder(type_3054);
  ::Reflex::Type type_23398 = ::Reflex::ReferenceBuilder(type_3054c);
  ::Reflex::Type type_24321 = ::Reflex::ReferenceBuilder(type_2805);
  ::Reflex::Type type_10790 = ::Reflex::ReferenceBuilder(type_4660);
  ::Reflex::Type type_6288 = ::Reflex::PointerBuilder(type_4660);
  ::Reflex::Type type_6900 = ::Reflex::PointerBuilder(type_4660c);
  ::Reflex::Type type_3067c = ::Reflex::ConstBuilder(type_3067);
  ::Reflex::Type type_23463 = ::Reflex::ReferenceBuilder(type_3067c);
  ::Reflex::Type type_2812c = ::Reflex::ConstBuilder(type_2812);
  ::Reflex::Type type_9220 = ::Reflex::ReferenceBuilder(type_2812c);
  ::Reflex::Type type_24335 = ::Reflex::ReferenceBuilder(type_2812);
  ::Reflex::Type type_29107 = ::Reflex::ReferenceBuilder(type_4728);
  ::Reflex::Type type_29984 = ::Reflex::ArrayBuilder(type_102, 5);
  ::Reflex::Type type_10855 = ::Reflex::ReferenceBuilder(type_10846);
  ::Reflex::Type type_10846c = ::Reflex::ConstBuilder(type_10846);
  ::Reflex::Type type_10857 = ::Reflex::ReferenceBuilder(type_10846c);
  ::Reflex::Type type_6891 = ::Reflex::ReferenceBuilder(type_102);
  ::Reflex::Type type_6344 = ::Reflex::PointerBuilder(type_10846);
  ::Reflex::Type type_10853 = ::Reflex::PointerBuilder(type_10846c);
  ::Reflex::Type type_3069c = ::Reflex::ConstBuilder(type_3069);
  ::Reflex::Type type_23502 = ::Reflex::ReferenceBuilder(type_3069c);
  ::Reflex::Type type_2814c = ::Reflex::ConstBuilder(type_2814);
  ::Reflex::Type type_24344 = ::Reflex::ReferenceBuilder(type_2814c);
  ::Reflex::Type type_24345 = ::Reflex::ReferenceBuilder(type_2814);
  ::Reflex::Type type_7878 = ::Reflex::PointerBuilder(type_2751);
  ::Reflex::Type type_7880 = ::Reflex::PointerBuilder(type_2751c);
  ::Reflex::Type type_7882 = ::Reflex::ReferenceBuilder(type_2751);
  ::Reflex::Type type_2914c = ::Reflex::ConstBuilder(type_2914);
  ::Reflex::Type type_24051 = ::Reflex::ReferenceBuilder(type_2914c);
  ::Reflex::Type type_3051c = ::Reflex::ConstBuilder(type_3051);
  ::Reflex::Type type_24041 = ::Reflex::ReferenceBuilder(type_3051c);
  ::Reflex::Type type_2955c = ::Reflex::ConstBuilder(type_2955);
  ::Reflex::Type type_24518 = ::Reflex::ReferenceBuilder(type_2955c);
  ::Reflex::Type type_24519 = ::Reflex::ReferenceBuilder(type_2955);
  ::Reflex::Type type_7983 = ::Reflex::PointerBuilder(type_2752);
  ::Reflex::Type type_7985 = ::Reflex::PointerBuilder(type_2752c);
  ::Reflex::Type type_7987 = ::Reflex::ReferenceBuilder(type_2752);
  ::Reflex::Type type_2442c = ::Reflex::ConstBuilder(type_2442);
  ::Reflex::Type type_23975 = ::Reflex::ReferenceBuilder(type_2442c);
  ::Reflex::Type type_3052c = ::Reflex::ConstBuilder(type_3052);
  ::Reflex::Type type_24048 = ::Reflex::ReferenceBuilder(type_3052c);
  ::Reflex::Type type_2956c = ::Reflex::ConstBuilder(type_2956);
  ::Reflex::Type type_24520 = ::Reflex::ReferenceBuilder(type_2956c);
  ::Reflex::Type type_24521 = ::Reflex::ReferenceBuilder(type_2956);
  ::Reflex::Type type_2957c = ::Reflex::ConstBuilder(type_2957);
  ::Reflex::Type type_24522 = ::Reflex::ReferenceBuilder(type_2957c);
  ::Reflex::Type type_24523 = ::Reflex::ReferenceBuilder(type_2957);
  ::Reflex::Type type_3447c = ::Reflex::ConstBuilder(type_3447);
  ::Reflex::Type type_24797 = ::Reflex::ReferenceBuilder(type_3447c);
  ::Reflex::Type type_24798 = ::Reflex::ReferenceBuilder(type_3447);
  ::Reflex::Type type_6881 = ::Reflex::ReferenceBuilder(type_102c);
  ::Reflex::Type type_3448c = ::Reflex::ConstBuilder(type_3448);
  ::Reflex::Type type_24799 = ::Reflex::ReferenceBuilder(type_3448c);
  ::Reflex::Type type_15333 = ::Reflex::ReferenceBuilder(type_3448);
  ::Reflex::Type type_2200 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_2199);
  ::Reflex::Type type_4752 = ::Reflex::ReferenceBuilder(type_2200);
  ::Reflex::Type type_1780 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::istream"), type_1779);
  ::Reflex::Type type_4761 = ::Reflex::ReferenceBuilder(type_1780);
  ::Reflex::Type type_3455c = ::Reflex::ConstBuilder(type_3455);
  ::Reflex::Type type_24800 = ::Reflex::ReferenceBuilder(type_3455c);
  ::Reflex::Type type_3453c = ::Reflex::ConstBuilder(type_3453);
  ::Reflex::Type type_15336 = ::Reflex::ReferenceBuilder(type_3453c);
  ::Reflex::Type type_3475c = ::Reflex::ConstBuilder(type_3475);
  ::Reflex::Type type_15335 = ::Reflex::ReferenceBuilder(type_3475c);
  ::Reflex::Type type_3450c = ::Reflex::ConstBuilder(type_3450);
  ::Reflex::Type type_15334 = ::Reflex::ReferenceBuilder(type_3450c);
  ::Reflex::Type type_24801 = ::Reflex::ReferenceBuilder(type_3450);
  ::Reflex::Type type_24802 = ::Reflex::PointerBuilder(type_3486);
  ::Reflex::Type type_24803 = ::Reflex::ReferenceBuilder(type_3453);
  ::Reflex::Type type_12816 = ::Reflex::PointerBuilder(type_3450c);
  ::Reflex::Type type_24875 = ::Reflex::ReferenceBuilder(type_3455);
  ::Reflex::Type type_3459c = ::Reflex::ConstBuilder(type_3459);
  ::Reflex::Type type_24880 = ::Reflex::ReferenceBuilder(type_3459c);
  ::Reflex::Type type_24881 = ::Reflex::ReferenceBuilder(type_3459);
  ::Reflex::Type type_796c = ::Reflex::ConstBuilder(type_796);
  ::Reflex::Type type_10408 = ::Reflex::ReferenceBuilder(type_796c);
  ::Reflex::Type type_3474c = ::Reflex::ConstBuilder(type_3474);
  ::Reflex::Type type_24888 = ::Reflex::ReferenceBuilder(type_3474c);
  ::Reflex::Type type_24889 = ::Reflex::ReferenceBuilder(type_3474);
  ::Reflex::Type type_3458c = ::Reflex::ConstBuilder(type_3458);
  ::Reflex::Type type_24878 = ::Reflex::ReferenceBuilder(type_3458c);
  ::Reflex::Type type_24890 = ::Reflex::ReferenceBuilder(type_3475);
  ::Reflex::Type type_3482c = ::Reflex::ConstBuilder(type_3482);
  ::Reflex::Type type_15337 = ::Reflex::ReferenceBuilder(type_3482c);
  ::Reflex::Type type_24959 = ::Reflex::ReferenceBuilder(type_3482);
  ::Reflex::Type type_24964 = ::Reflex::PointerBuilder(type_3448);
  ::Reflex::Type type_15340 = ::Reflex::PointerBuilder(type_3459);
  ::Reflex::Type type_15339 = ::Reflex::PointerBuilder(type_3447);
  ::Reflex::Type type_2808c = ::Reflex::ConstBuilder(type_2808);
  ::Reflex::Type type_24326 = ::Reflex::ReferenceBuilder(type_2808c);
  ::Reflex::Type type_24891 = ::Reflex::ReferenceBuilder(type_3486c);
  ::Reflex::Type type_15159 = ::Reflex::ReferenceBuilder(type_3486);
  ::Reflex::Type type_25019 = ::Reflex::PointerBuilder(type_3448c);
  ::Reflex::Type type_15332 = ::Reflex::PointerBuilder(type_3459c);
  ::Reflex::Type type_15331 = ::Reflex::PointerBuilder(type_3447c);
  ::Reflex::Type type_2756c = ::Reflex::ConstBuilder(type_2756);
  ::Reflex::Type type_24292 = ::Reflex::ReferenceBuilder(type_2756c);
  ::Reflex::Type type_16542 = ::Reflex::ReferenceBuilder(type_2320);
  ::Reflex::Type type_4196c = ::Reflex::ConstBuilder(type_4196);
  ::Reflex::Type type_4093c = ::Reflex::ConstBuilder(type_4093);
  ::Reflex::Type type_28800 = ::Reflex::ReferenceBuilder(type_4093c);
  ::Reflex::Type type_4207c = ::Reflex::ConstBuilder(type_4207);
  ::Reflex::Type type_18751 = ::Reflex::ReferenceBuilder(type_4207c);
  ::Reflex::Type type_28801 = ::Reflex::ReferenceBuilder(type_4196c);
  ::Reflex::Type type_4182c = ::Reflex::ConstBuilder(type_4182);
  ::Reflex::Type type_28802 = ::Reflex::ReferenceBuilder(type_4182c);
  ::Reflex::Type type_4195c = ::Reflex::ConstBuilder(type_4195);
  ::Reflex::Type type_18986 = ::Reflex::PointerBuilder(type_4195c);
  ::Reflex::Type type_4077c = ::Reflex::ConstBuilder(type_4077);
  ::Reflex::Type type_28803 = ::Reflex::ReferenceBuilder(type_4077c);
  ::Reflex::Type type_28804 = ::Reflex::ReferenceBuilder(type_4093);
  ::Reflex::Type type_24308 = ::Reflex::ReferenceBuilder(type_2799);
  ::Reflex::Type type_4176 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_4175);
  ::Reflex::Type type_28805 = ::Reflex::ReferenceBuilder(type_4176);
  ::Reflex::Type type_4197c = ::Reflex::ConstBuilder(type_4197);
  ::Reflex::Type type_4094c = ::Reflex::ConstBuilder(type_4094);
  ::Reflex::Type type_28807 = ::Reflex::ReferenceBuilder(type_4094c);
  ::Reflex::Type type_28808 = ::Reflex::ReferenceBuilder(type_4197c);
  ::Reflex::Type type_4078c = ::Reflex::ConstBuilder(type_4078);
  ::Reflex::Type type_28809 = ::Reflex::ReferenceBuilder(type_4078c);
  ::Reflex::Type type_28810 = ::Reflex::ReferenceBuilder(type_4094);
  ::Reflex::Type type_28811 = ::Reflex::PointerBuilder(type_690c);
  ::Reflex::Type type_432c = ::Reflex::ConstBuilder(type_432);
  ::Reflex::Type type_4075 = ::Reflex::ReferenceBuilder(type_432c);
  ::Reflex::Type type_28812 = ::Reflex::PointerBuilder(type_690);
  ::Reflex::Type type_4112c = ::Reflex::ConstBuilder(type_4112);
  ::Reflex::Type type_28813 = ::Reflex::PointerBuilder(type_4112c);
  ::Reflex::Type type_28729 = ::Reflex::ReferenceBuilder(type_4018);
  ::Reflex::Type type_2169c = ::Reflex::ConstBuilder(type_2169);
  ::Reflex::Type type_3430 = ::Reflex::PointerBuilder(type_2169c);
  ::Reflex::Type type_7113 = ::Reflex::ReferenceBuilder(type_3430);
  ::Reflex::Type type_2800c = ::Reflex::ConstBuilder(type_2800);
  ::Reflex::Type type_24309 = ::Reflex::ReferenceBuilder(type_2800c);
  ::Reflex::Type type_459c = ::Reflex::ConstBuilder(type_459);
  ::Reflex::Type type_28816 = ::Reflex::PointerBuilder(type_459c);
  ::Reflex::Type type_28817 = ::Reflex::PointerBuilder(type_459);
  ::Reflex::Type type_4113c = ::Reflex::ConstBuilder(type_4113);
  ::Reflex::Type type_28818 = ::Reflex::PointerBuilder(type_4113c);
  ::Reflex::Type type_28821 = ::Reflex::PointerBuilder(type_818c);
  ::Reflex::Type type_28822 = ::Reflex::PointerBuilder(type_818);
  ::Reflex::Type type_4114c = ::Reflex::ConstBuilder(type_4114);
  ::Reflex::Type type_28823 = ::Reflex::PointerBuilder(type_4114c);
  ::Reflex::Type type_28826 = ::Reflex::PointerBuilder(type_1920c);
  ::Reflex::Type type_28827 = ::Reflex::PointerBuilder(type_1920);
  ::Reflex::Type type_4115c = ::Reflex::ConstBuilder(type_4115);
  ::Reflex::Type type_28828 = ::Reflex::PointerBuilder(type_4115c);
  ::Reflex::Type type_28831 = ::Reflex::PointerBuilder(type_341c);
  ::Reflex::Type type_28832 = ::Reflex::PointerBuilder(type_341);
  ::Reflex::Type type_4116c = ::Reflex::ConstBuilder(type_4116);
  ::Reflex::Type type_28833 = ::Reflex::PointerBuilder(type_4116c);
  ::Reflex::Type type_28836 = ::Reflex::PointerBuilder(type_866c);
  ::Reflex::Type type_28837 = ::Reflex::PointerBuilder(type_866);
  ::Reflex::Type type_4117c = ::Reflex::ConstBuilder(type_4117);
  ::Reflex::Type type_28838 = ::Reflex::PointerBuilder(type_4117c);
  ::Reflex::Type type_28841 = ::Reflex::PointerBuilder(type_1341c);
  ::Reflex::Type type_28842 = ::Reflex::PointerBuilder(type_1341);
  ::Reflex::Type type_4118c = ::Reflex::ConstBuilder(type_4118);
  ::Reflex::Type type_28843 = ::Reflex::PointerBuilder(type_4118c);
  ::Reflex::Type type_28966 = ::Reflex::PointerBuilder(type_3455);
  ::Reflex::Type type_71 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_70);
  ::Reflex::Type type_28967 = ::Reflex::PointerBuilder(type_71);
  ::Reflex::Type type_12805 = ::Reflex::ReferenceBuilder(type_4198c);
  ::Reflex::Type type_28968 = ::Reflex::ReferenceBuilder(type_4198);
  ::Reflex::Type type_28846 = ::Reflex::PointerBuilder(type_4198);
  ::Reflex::Type type_4119c = ::Reflex::ConstBuilder(type_4119);
  ::Reflex::Type type_28847 = ::Reflex::PointerBuilder(type_4119c);
  ::Reflex::Type type_28960 = ::Reflex::ReferenceBuilder(type_4196);
  ::Reflex::Type type_4205c = ::Reflex::ConstBuilder(type_4205);
  ::Reflex::Type type_28961 = ::Reflex::ReferenceBuilder(type_4205c);
  ::Reflex::Type type_4162c = ::Reflex::ConstBuilder(type_4162);
  ::Reflex::Type type_28962 = ::Reflex::ReferenceBuilder(type_4162c);
  ::Reflex::Type type_4145c = ::Reflex::ConstBuilder(type_4145);
  ::Reflex::Type type_28963 = ::Reflex::ReferenceBuilder(type_4145c);
  ::Reflex::Type type_12808 = ::Reflex::PointerBuilder(type_3482c);
  ::Reflex::Type type_4156c = ::Reflex::ConstBuilder(type_4156);
  ::Reflex::Type type_28964 = ::Reflex::ReferenceBuilder(type_4156c);
  ::Reflex::Type type_4173c = ::Reflex::ConstBuilder(type_4173);
  ::Reflex::Type type_18749 = ::Reflex::ReferenceBuilder(type_4173c);
  ::Reflex::Type type_28965 = ::Reflex::ReferenceBuilder(type_4197);
  ::Reflex::Type type_29108 = ::Reflex::ReferenceBuilder(type_4729);
  ::Reflex::Type type_29132 = ::Reflex::ReferenceBuilder(type_5075);
  ::Reflex::Type type_29533 = ::Reflex::ReferenceBuilder(type_5599);
  ::Reflex::Type type_5599c = ::Reflex::ConstBuilder(type_5599);
  ::Reflex::Type type_29534 = ::Reflex::ReferenceBuilder(type_5599c);
  ::Reflex::Type type_29535 = ::Reflex::ReferenceBuilder(type_5601);
  ::Reflex::Type type_5601c = ::Reflex::ConstBuilder(type_5601);
  ::Reflex::Type type_29536 = ::Reflex::ReferenceBuilder(type_5601c);
  ::Reflex::Type type_2595c = ::Reflex::ConstBuilder(type_2595);
  ::Reflex::Type type_24153 = ::Reflex::ReferenceBuilder(type_2595c);
  ::Reflex::Type type_15545c = ::Reflex::ConstBuilder(type_15545);
  ::Reflex::Type type_30196 = ::Reflex::ReferenceBuilder(type_15545c);
  ::Reflex::Type type_30197 = ::Reflex::ReferenceBuilder(type_15545);
  ::Reflex::Type type_2891c = ::Reflex::ConstBuilder(type_2891);
  ::Reflex::Type type_24154 = ::Reflex::ReferenceBuilder(type_2891c);
  ::Reflex::Type type_15546c = ::Reflex::ConstBuilder(type_15546);
  ::Reflex::Type type_30198 = ::Reflex::ReferenceBuilder(type_15546c);
  ::Reflex::Type type_30199 = ::Reflex::ReferenceBuilder(type_15546);
  ::Reflex::Type type_2596c = ::Reflex::ConstBuilder(type_2596);
  ::Reflex::Type type_24156 = ::Reflex::ReferenceBuilder(type_2596c);
  ::Reflex::Type type_15547c = ::Reflex::ConstBuilder(type_15547);
  ::Reflex::Type type_30200 = ::Reflex::ReferenceBuilder(type_15547c);
  ::Reflex::Type type_30201 = ::Reflex::ReferenceBuilder(type_15547);
  ::Reflex::Type type_2892c = ::Reflex::ConstBuilder(type_2892);
  ::Reflex::Type type_24157 = ::Reflex::ReferenceBuilder(type_2892c);
  ::Reflex::Type type_15548c = ::Reflex::ConstBuilder(type_15548);
  ::Reflex::Type type_30202 = ::Reflex::ReferenceBuilder(type_15548c);
  ::Reflex::Type type_30203 = ::Reflex::ReferenceBuilder(type_15548);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __GenEventInfoProduct
#undef __GenEventInfoProduct
#endif
class __GenEventInfoProduct {
  public:
  __GenEventInfoProduct();
  virtual ~__GenEventInfoProduct() throw();
  ::std::vector<double> weights_;
  unsigned int signalProcessID_;
  double qScale_;
  double alphaQCD_;
  double alphaQED_;
  ::std::auto_ptr<gen::PdfInfo> pdf_;
  ::std::vector<double> binningValues_;
  ::std::vector<float> DJRValues_;
  int nMEPartons_;
  int nMEPartonsFiltered_;
};
#ifdef __LHEEventProduct
#undef __LHEEventProduct
#endif
class __LHEEventProduct {
  public:
  __LHEEventProduct();
  ::lhef::HEPEUP hepeup_;
  ::std::vector<std::basic_string<char> > comments_;
  ::std::auto_ptr<gen::PdfInfo> pdf_;
  ::std::vector<gen::WeightsInfo> weights_;
  double originalXWGTUP_;
  ::std::vector<float> scales_;
  int npLO_;
  int npNLO_;
};
#ifdef __LHEXMLStringProduct
#undef __LHEXMLStringProduct
#endif
class __LHEXMLStringProduct {
  public:
  __LHEXMLStringProduct();
  virtual ~__LHEXMLStringProduct() throw();
  ::std::vector<std::basic_string<char> > content_;
};
#ifdef __LHERunInfoProduct
#undef __LHERunInfoProduct
#endif
class __LHERunInfoProduct {
  public:
  __LHERunInfoProduct();
  ::lhef::HEPRUP heprup_;
  ::std::vector<LHERunInfoProduct::Header> headers_;
  ::std::vector<std::basic_string<char> > comments_;
};
#ifdef __GenFilterInfo
#undef __GenFilterInfo
#endif
class __GenFilterInfo {
  public:
  __GenFilterInfo();
  virtual ~__GenFilterInfo() throw();
  unsigned int numPassPositiveEvents_;
  unsigned int numPassNegativeEvents_;
  unsigned int numTotalPositiveEvents_;
  unsigned int numTotalNegativeEvents_;
  double sumPassWeights_;
  double sumPassWeights2_;
  double sumTotalWeights_;
  double sumTotalWeights2_;
};
#ifdef __GenRunInfoProduct
#undef __GenRunInfoProduct
#endif
class __GenRunInfoProduct {
  public:
  __GenRunInfoProduct();
  virtual ~__GenRunInfoProduct() throw();
  ::GenRunInfoProduct::XSec internalXSec_;
  ::GenRunInfoProduct::XSec externalXSecLO_;
  ::GenRunInfoProduct::XSec externalXSecNLO_;
  double externalFilterEfficiency_;
};
#ifdef __GenLumiInfoProduct
#undef __GenLumiInfoProduct
#endif
class __GenLumiInfoProduct {
  public:
  __GenLumiInfoProduct();
  virtual ~__GenLumiInfoProduct() throw();
  int hepidwtup_;
  ::std::vector<GenLumiInfoProduct::ProcessInfo> internalProcesses_;
};
#ifdef __gen__PdfInfo
#undef __gen__PdfInfo
#endif
struct __gen__PdfInfo {
  public:
  __gen__PdfInfo();
  ::std::pair<int,int> id;
  ::std::pair<double,double> x;
  ::std::pair<double,double> xPDF;
  double scalePDF;
};
#ifdef __std__auto_ptr_gen__PdfInfo_
#undef __std__auto_ptr_gen__PdfInfo_
#endif
class __std__auto_ptr_gen__PdfInfo_ {
  public:
  __std__auto_ptr_gen__PdfInfo_();
  void* _M_ptr;
};
#ifdef __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr_
#undef __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr_
#endif
struct __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr_ {
  public:
  __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr_();
};
#ifdef __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr_
#undef __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr_
#endif
struct __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr_ {
  public:
  __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr_();
};
#ifdef __std__pair_constsint_HepMC__GenVertexp_
#undef __std__pair_constsint_HepMC__GenVertexp_
#endif
struct __std__pair_constsint_HepMC__GenVertexp_ {
  public:
  __std__pair_constsint_HepMC__GenVertexp_();
  int first;
  void* second;
};
#ifdef __std__pair_constsint_HepMC__GenParticlep_
#undef __std__pair_constsint_HepMC__GenParticlep_
#endif
struct __std__pair_constsint_HepMC__GenParticlep_ {
  public:
  __std__pair_constsint_HepMC__GenParticlep_();
  int first;
  void* second;
};
#ifdef __gen__WeightsInfo
#undef __gen__WeightsInfo
#endif
struct __gen__WeightsInfo {
  public:
  __gen__WeightsInfo();
  ::std::string id;
  double wgt;
};
#ifdef __std__vector_gen__WeightsInfo_
#undef __std__vector_gen__WeightsInfo_
#endif
class __std__vector_gen__WeightsInfo_ : protected ::std::_Vector_base<gen::WeightsInfo,std::allocator<gen::WeightsInfo> > {
  public:
  __std__vector_gen__WeightsInfo_();
};
#ifdef __std__vector_constsedm__HepMCProductp_
#undef __std__vector_constsedm__HepMCProductp_
#endif
class __std__vector_constsedm__HepMCProductp_ : protected ::std::_Vector_base<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> > {
  public:
  __std__vector_constsedm__HepMCProductp_();
};
#ifdef __std__vector_HepMC__GenParticlep_
#undef __std__vector_HepMC__GenParticlep_
#endif
class __std__vector_HepMC__GenParticlep_ : protected ::std::_Vector_base<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> > {
  public:
  __std__vector_HepMC__GenParticlep_();
};
#ifdef __GenLumiInfoProduct__ProcessInfo
#undef __GenLumiInfoProduct__ProcessInfo
#endif
struct __GenLumiInfoProduct__ProcessInfo {
  public:
  __GenLumiInfoProduct__ProcessInfo();
  int process_;
  ::GenLumiInfoProduct::XSec lheXSec_;
  unsigned int nPassPos_;
  unsigned int nPassNeg_;
  unsigned int nTotalPos_;
  unsigned int nTotalNeg_;
  ::GenLumiInfoProduct::FinalStat tried_;
  ::GenLumiInfoProduct::FinalStat selected_;
  ::GenLumiInfoProduct::FinalStat killed_;
  ::GenLumiInfoProduct::FinalStat accepted_;
  ::GenLumiInfoProduct::FinalStat acceptedBr_;
};
#ifdef __std__vector_GenLumiInfoProduct__ProcessInfo_
#undef __std__vector_GenLumiInfoProduct__ProcessInfo_
#endif
class __std__vector_GenLumiInfoProduct__ProcessInfo_ : protected ::std::_Vector_base<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> > {
  public:
  __std__vector_GenLumiInfoProduct__ProcessInfo_();
};
#ifdef __LHERunInfoProduct__Header
#undef __LHERunInfoProduct__Header
#endif
class __LHERunInfoProduct__Header {
  public:
  __LHERunInfoProduct__Header();
  ::std::string tag_;
  ::std::vector<std::basic_string<char> > lines_;
};
#ifdef __std__vector_LHERunInfoProduct__Header_
#undef __std__vector_LHERunInfoProduct__Header_
#endif
class __std__vector_LHERunInfoProduct__Header_ : protected ::std::_Vector_base<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> > {
  public:
  __std__vector_LHERunInfoProduct__Header_();
};
#ifdef __lhef__HEPEUP
#undef __lhef__HEPEUP
#endif
class __lhef__HEPEUP {
  public:
  __lhef__HEPEUP();
  int NUP;
  int IDPRUP;
  double XWGTUP;
  ::std::pair<double,double> XPDWUP;
  double SCALUP;
  double AQEDUP;
  double AQCDUP;
  ::std::vector<int> IDUP;
  ::std::vector<int> ISTUP;
  ::std::vector<std::pair<int,int> > MOTHUP;
  ::std::vector<std::pair<int,int> > ICOLUP;
  ::std::vector<lhef::HEPEUP::FiveVector> PUP;
  ::std::vector<double> VTIMUP;
  ::std::vector<double> SPINUP;
};
#ifdef __lhef__HEPEUP__FiveVector
#undef __lhef__HEPEUP__FiveVector
#endif
struct __lhef__HEPEUP__FiveVector {
  public:
  __lhef__HEPEUP__FiveVector();
  double x[5];
};
#ifdef __std__vector_lhef__HEPEUP__FiveVector_
#undef __std__vector_lhef__HEPEUP__FiveVector_
#endif
class __std__vector_lhef__HEPEUP__FiveVector_ : protected ::std::_Vector_base<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> > {
  public:
  __std__vector_lhef__HEPEUP__FiveVector_();
};
#ifdef __std__map_int_HepMC__GenVertexp_std__greater_int_s_
#undef __std__map_int_HepMC__GenVertexp_std__greater_int_s_
#endif
class __std__map_int_HepMC__GenVertexp_std__greater_int_s_ {
  public:
  __std__map_int_HepMC__GenVertexp_std__greater_int_s_();
  ::std::_Rb_tree<int,std::pair<const int,HepMC::GenVertex*>,std::_Select1st<std::pair<const int,HepMC::GenVertex*> >,std::greater<int>,std::allocator<std::pair<const int,HepMC::GenVertex*> > > _M_t;
};
#ifdef __std__map_int_HepMC__GenParticlep_
#undef __std__map_int_HepMC__GenParticlep_
#endif
class __std__map_int_HepMC__GenParticlep_ {
  public:
  __std__map_int_HepMC__GenParticlep_();
  ::std::_Rb_tree<int,std::pair<const int,HepMC::GenParticle*>,std::_Select1st<std::pair<const int,HepMC::GenParticle*> >,std::less<int>,std::allocator<std::pair<const int,HepMC::GenParticle*> > > _M_t;
};
#ifdef __std__map_int_HepMC__GenVertexp_
#undef __std__map_int_HepMC__GenVertexp_
#endif
class __std__map_int_HepMC__GenVertexp_ {
  public:
  __std__map_int_HepMC__GenVertexp_();
  ::std::_Rb_tree<int,std::pair<const int,HepMC::GenVertex*>,std::_Select1st<std::pair<const int,HepMC::GenVertex*> >,std::less<int>,std::allocator<std::pair<const int,HepMC::GenVertex*> > > _M_t;
};
#ifdef __HepMC__PdfInfo
#undef __HepMC__PdfInfo
#endif
class __HepMC__PdfInfo {
  public:
  __HepMC__PdfInfo();
  int m_id1;
  int m_id2;
  int m_pdf_id1;
  int m_pdf_id2;
  double m_x1;
  double m_x2;
  double m_scalePDF;
  double m_pdf1;
  double m_pdf2;
};
#ifdef __HepMC__GenCrossSection
#undef __HepMC__GenCrossSection
#endif
class __HepMC__GenCrossSection {
  public:
  __HepMC__GenCrossSection();
  double m_cross_section;
  double m_cross_section_error;
  bool m_is_set;
};
#ifdef __HepMC__GenParticle
#undef __HepMC__GenParticle
#endif
class __HepMC__GenParticle {
  public:
  __HepMC__GenParticle();
  virtual ~__HepMC__GenParticle() throw();
  ::HepMC::FourVector m_momentum;
  int m_pdg_id;
  int m_status;
  ::HepMC::Flow m_flow;
  ::HepMC::Polarization m_polarization;
  void* m_production_vertex;
  void* m_end_vertex;
  int m_barcode;
  double m_generated_mass;
};
#ifdef __HepMC__Flow
#undef __HepMC__Flow
#endif
class __HepMC__Flow {
  public:
  __HepMC__Flow();
  virtual ~__HepMC__Flow() throw();
  void* m_particle_owner;
  ::std::map<int,int> m_icode;
};
#ifdef __HepMC__FourVector
#undef __HepMC__FourVector
#endif
class __HepMC__FourVector {
  public:
  __HepMC__FourVector();
  double m_x;
  double m_y;
  double m_z;
  double m_t;
};
#ifdef __HepMC__HeavyIon
#undef __HepMC__HeavyIon
#endif
class __HepMC__HeavyIon {
  public:
  __HepMC__HeavyIon();
  int m_Ncoll_hard;
  int m_Npart_proj;
  int m_Npart_targ;
  int m_Ncoll;
  int m_spectator_neutrons;
  int m_spectator_protons;
  int m_N_Nwounded_collisions;
  int m_Nwounded_N_collisions;
  int m_Nwounded_Nwounded_collisions;
  float m_impact_parameter;
  float m_event_plane_angle;
  float m_eccentricity;
  float m_sigma_inel_NN;
};
#ifdef __HepMC__WeightContainer
#undef __HepMC__WeightContainer
#endif
class __HepMC__WeightContainer {
  public:
  __HepMC__WeightContainer();
  ::std::vector<double> m_weights;
  ::std::map<std::basic_string<char>,unsigned long> m_names;
};
#ifdef __HepMC__Polarization
#undef __HepMC__Polarization
#endif
class __HepMC__Polarization {
  public:
  __HepMC__Polarization();
  virtual ~__HepMC__Polarization() throw();
  double m_theta;
  double m_phi;
  bool m_defined;
};
#ifdef __HepMC__GenVertex
#undef __HepMC__GenVertex
#endif
class __HepMC__GenVertex {
  public:
  __HepMC__GenVertex();
  virtual ~__HepMC__GenVertex() throw();
#ifdef __HepMC__GenVertex__edge_iterator
#undef __HepMC__GenVertex__edge_iterator
#endif
  class __HepMC__GenVertex__edge_iterator :   public ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>   {
    public:
    __HepMC__GenVertex__edge_iterator();
    virtual ~__HepMC__GenVertex__edge_iterator() throw();
    void* m_vertex;
    ::HepMC::IteratorRange m_range;
    ::__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> > m_set_iter;
    bool m_is_inparticle_iter;
    bool m_is_past_end;
  };
  ::HepMC::FourVector m_position;
  ::std::vector<HepMC::GenParticle*> m_particles_in;
  ::std::vector<HepMC::GenParticle*> m_particles_out;
  int m_id;
  ::HepMC::WeightContainer m_weights;
  void* m_event;
  int m_barcode;
};
#ifdef __HepMC__GenEvent
#undef __HepMC__GenEvent
#endif
class __HepMC__GenEvent {
  public:
  __HepMC__GenEvent();
  virtual ~__HepMC__GenEvent() throw();
  int m_signal_process_id;
  int m_event_number;
  int m_mpi;
  double m_event_scale;
  double m_alphaQCD;
  double m_alphaQED;
  void* m_signal_process_vertex;
  void* m_beam_particle_1;
  void* m_beam_particle_2;
  ::HepMC::WeightContainer m_weights;
  ::std::vector<long> m_random_states;
  ::std::map<int,HepMC::GenVertex*,std::greater<int> > m_vertex_barcodes;
  ::std::map<int,HepMC::GenParticle*> m_particle_barcodes;
  void* m_cross_section;
  void* m_heavy_ion;
  void* m_pdf_info;
  ::HepMC::Units::MomentumUnit m_momentum_unit;
  ::HepMC::Units::LengthUnit m_position_unit;
};
#ifdef __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_
#undef __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_
#endif
class __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_ {
  public:
  __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_();
  ::edm::RefVectorBase<int> refVector_;
};
#ifdef __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_
#undef __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_
#endif
class __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_ {
  public:
  __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_();
  ::edm::RefVectorBase<int> refVector_;
};
#ifdef __edm__Wrapper_LHEXMLStringProduct_
#undef __edm__Wrapper_LHEXMLStringProduct_
#endif
class __edm__Wrapper_LHEXMLStringProduct_ {
  public:
  __edm__Wrapper_LHEXMLStringProduct_();
  bool present;
  ::LHEXMLStringProduct obj;
};
#ifdef __edm__Wrapper_LHEEventProduct_
#undef __edm__Wrapper_LHEEventProduct_
#endif
class __edm__Wrapper_LHEEventProduct_ {
  public:
  __edm__Wrapper_LHEEventProduct_();
  bool present;
  ::LHEEventProduct obj;
};
#ifdef __edm__Wrapper_LHERunInfoProduct_
#undef __edm__Wrapper_LHERunInfoProduct_
#endif
class __edm__Wrapper_LHERunInfoProduct_ {
  public:
  __edm__Wrapper_LHERunInfoProduct_();
  bool present;
  ::LHERunInfoProduct obj;
};
#ifdef __edm__Wrapper_GenLumiInfoProduct_
#undef __edm__Wrapper_GenLumiInfoProduct_
#endif
class __edm__Wrapper_GenLumiInfoProduct_ {
  public:
  __edm__Wrapper_GenLumiInfoProduct_();
  bool present;
  ::GenLumiInfoProduct obj;
};
#ifdef __edm__Wrapper_GenEventInfoProduct_
#undef __edm__Wrapper_GenEventInfoProduct_
#endif
class __edm__Wrapper_GenEventInfoProduct_ {
  public:
  __edm__Wrapper_GenEventInfoProduct_();
  bool present;
  ::GenEventInfoProduct obj;
};
#ifdef __edm__Wrapper_GenFilterInfo_
#undef __edm__Wrapper_GenFilterInfo_
#endif
class __edm__Wrapper_GenFilterInfo_ {
  public:
  __edm__Wrapper_GenFilterInfo_();
  bool present;
  ::GenFilterInfo obj;
};
#ifdef __edm__Wrapper_GenRunInfoProduct_
#undef __edm__Wrapper_GenRunInfoProduct_
#endif
class __edm__Wrapper_GenRunInfoProduct_ {
  public:
  __edm__Wrapper_GenRunInfoProduct_();
  bool present;
  ::GenRunInfoProduct obj;
};
#ifdef __edm__HepMCProduct
#undef __edm__HepMCProduct
#endif
class __edm__HepMCProduct {
  public:
  __edm__HepMCProduct();
  virtual ~__edm__HepMCProduct() throw();
  void* evt_;
  bool isVtxGenApplied_;
  bool isVtxBoostApplied_;
  bool isPBoostApplied_;
};
#ifdef __edm__Wrapper_edm__HepMCProduct_
#undef __edm__Wrapper_edm__HepMCProduct_
#endif
class __edm__Wrapper_edm__HepMCProduct_ {
  public:
  __edm__Wrapper_edm__HepMCProduct_();
  bool present;
  ::edm::HepMCProduct obj;
};
#ifdef __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_
#undef __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_
#endif
class __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_ {
  public:
  __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_();
  ::edm::RefCore product_;
  int index_;
};
#ifdef __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_
#undef __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_
#endif
class __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_ {
  public:
  __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_();
  ::edm::RefCore product_;
  int index_;
};
#ifdef __lhef__HEPRUP
#undef __lhef__HEPRUP
#endif
class __lhef__HEPRUP {
  public:
  __lhef__HEPRUP();
  ::std::pair<int,int> IDBMUP;
  ::std::pair<double,double> EBMUP;
  ::std::pair<int,int> PDFGUP;
  ::std::pair<int,int> PDFSUP;
  int IDWTUP;
  int NPRUP;
  ::std::vector<double> XSECUP;
  ::std::vector<double> XERRUP;
  ::std::vector<double> XMAXUP;
  ::std::vector<int> LPRUP;
};
#ifdef __GenRunInfoProduct__XSec
#undef __GenRunInfoProduct__XSec
#endif
struct __GenRunInfoProduct__XSec {
  public:
  __GenRunInfoProduct__XSec();
  double value_;
  double error_;
};
#ifdef __GenLumiInfoProduct__XSec
#undef __GenLumiInfoProduct__XSec
#endif
struct __GenLumiInfoProduct__XSec {
  public:
  __GenLumiInfoProduct__XSec();
  double value_;
  double error_;
};
#ifdef __GenLumiInfoProduct__FinalStat
#undef __GenLumiInfoProduct__FinalStat
#endif
struct __GenLumiInfoProduct__FinalStat {
  public:
  __GenLumiInfoProduct__FinalStat();
  unsigned int n_;
  double sum_;
  double sum2_;
};
#ifdef __HepMC__GenEvent__vertex_const_iterator
#undef __HepMC__GenEvent__vertex_const_iterator
#endif
class __HepMC__GenEvent__vertex_const_iterator : public ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> {
  public:
  __HepMC__GenEvent__vertex_const_iterator();
  virtual ~__HepMC__GenEvent__vertex_const_iterator() throw();
  ::std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> > m_map_iterator;
};
#ifdef __HepMC__GenEvent__vertex_iterator
#undef __HepMC__GenEvent__vertex_iterator
#endif
class __HepMC__GenEvent__vertex_iterator : public ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> {
  public:
  __HepMC__GenEvent__vertex_iterator();
  virtual ~__HepMC__GenEvent__vertex_iterator() throw();
  ::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> > m_map_iterator;
};
#ifdef __HepMC__GenEvent__particle_const_iterator
#undef __HepMC__GenEvent__particle_const_iterator
#endif
class __HepMC__GenEvent__particle_const_iterator : public ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> {
  public:
  __HepMC__GenEvent__particle_const_iterator();
  virtual ~__HepMC__GenEvent__particle_const_iterator() throw();
  ::std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> > m_map_iterator;
};
#ifdef __HepMC__GenEvent__particle_iterator
#undef __HepMC__GenEvent__particle_iterator
#endif
class __HepMC__GenEvent__particle_iterator : public ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> {
  public:
  __HepMC__GenEvent__particle_iterator();
  virtual ~__HepMC__GenEvent__particle_iterator() throw();
  ::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> > m_map_iterator;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class GenEventInfoProduct -------------------------------
static void constructor_4045( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenEventInfoProduct();
  else ::new(mem) ::GenEventInfoProduct();
}

static void constructor_4046( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenEventInfoProduct((const ::HepMC::GenEvent*)arg[0]);
  else ::new(mem) ::GenEventInfoProduct((const ::HepMC::GenEvent*)arg[0]);
}

static void constructor_4047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenEventInfoProduct(*(const ::GenEventInfoProduct*)arg[0]);
  else ::new(mem) ::GenEventInfoProduct(*(const ::GenEventInfoProduct*)arg[0]);
}

static void destructor_4048(void*, void * o, const std::vector<void*>&, void *) {
(((::GenEventInfoProduct*)o)->::GenEventInfoProduct::~GenEventInfoProduct)();
}
static  void operator_4049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenEventInfoProduct*)o)->operator=)(*(const ::GenEventInfoProduct*)arg[0]);
  else   (((::GenEventInfoProduct*)o)->operator=)(*(const ::GenEventInfoProduct*)arg[0]);
}

static  void method_4050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenEventInfoProduct*)o)->weights)();
  else   (((const ::GenEventInfoProduct*)o)->weights)();
}

static  void method_4051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenEventInfoProduct*)o)->weight)());
  else   (((const ::GenEventInfoProduct*)o)->weight)();
}

static  void method_4052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenEventInfoProduct*)o)->signalProcessID)());
  else   (((const ::GenEventInfoProduct*)o)->signalProcessID)();
}

static  void method_4053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenEventInfoProduct*)o)->qScale)());
  else   (((const ::GenEventInfoProduct*)o)->qScale)();
}

static  void method_4054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenEventInfoProduct*)o)->alphaQCD)());
  else   (((const ::GenEventInfoProduct*)o)->alphaQCD)();
}

static  void method_4055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenEventInfoProduct*)o)->alphaQED)());
  else   (((const ::GenEventInfoProduct*)o)->alphaQED)();
}

static  void method_4056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenEventInfoProduct*)o)->pdf)());
  else   (((const ::GenEventInfoProduct*)o)->pdf)();
}

static  void method_4057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenEventInfoProduct*)o)->hasPDF)());
  else   (((const ::GenEventInfoProduct*)o)->hasPDF)();
}

static  void method_4058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenEventInfoProduct*)o)->binningValues)();
  else   (((const ::GenEventInfoProduct*)o)->binningValues)();
}

static  void method_4059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenEventInfoProduct*)o)->hasBinningValues)());
  else   (((const ::GenEventInfoProduct*)o)->hasBinningValues)();
}

static  void method_4060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenEventInfoProduct*)o)->DJRValues)();
  else   (((const ::GenEventInfoProduct*)o)->DJRValues)();
}

static  void method_4061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenEventInfoProduct*)o)->hasDJRValues)());
  else   (((const ::GenEventInfoProduct*)o)->hasDJRValues)();
}

static  void method_4062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::GenEventInfoProduct*)o)->nMEPartons)());
  else   (((const ::GenEventInfoProduct*)o)->nMEPartons)();
}

static  void method_4063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::GenEventInfoProduct*)o)->nMEPartonsFiltered)());
  else   (((const ::GenEventInfoProduct*)o)->nMEPartonsFiltered)();
}

static  void method_4064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenEventInfoProduct*)o)->setWeights)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_4065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenEventInfoProduct*)o)->setSignalProcessID)(*(unsigned int*)arg[0]);
}

static  void method_4066( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::GenEventInfoProduct*)o)->setScales)();
  }
  else if ( arg.size() == 1 ) { 
    (((::GenEventInfoProduct*)o)->setScales)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::GenEventInfoProduct*)o)->setScales)(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::GenEventInfoProduct*)o)->setScales)(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
}

static  void method_4067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenEventInfoProduct*)o)->setPDF)((const ::gen::PdfInfo*)arg[0]);
}

static  void method_4068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenEventInfoProduct*)o)->setBinningValues)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_4069( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenEventInfoProduct*)o)->setDJR)(*(const ::std::vector<float>*)arg[0]);
}

static  void method_4070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenEventInfoProduct*)o)->setNMEPartons)(*(int*)arg[0]);
}

static  void method_4071( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenEventInfoProduct*)o)->setNMEPartonsFiltered)(*(int*)arg[0]);
}

static void method_newdel_341( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenEventInfoProduct >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenEventInfoProduct >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenEventInfoProduct >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenEventInfoProduct >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenEventInfoProduct >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___GenEventInfoProduct_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  int &nMEPartons_ = *(int*)(target + OffsetOf(__shadow__::__GenEventInfoProduct, nMEPartons_));

  //--- User's code ---
    nMEPartons_ = -1;
 
}

void read___GenEventInfoProduct_1( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  int &nMEPartonsFiltered_ = *(int*)(target + OffsetOf(__shadow__::__GenEventInfoProduct, nMEPartonsFiltered_));

  //--- User's code ---
    nMEPartonsFiltered_ = -1;
 
}

//------Dictionary for class GenEventInfoProduct -------------------------------
void __GenEventInfoProduct_db_datamem(Reflex::Class*);
void __GenEventInfoProduct_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenEventInfoProduct_datamem_bld(&__GenEventInfoProduct_db_datamem);
Reflex::GenreflexMemberBuilder __GenEventInfoProduct_funcmem_bld(&__GenEventInfoProduct_db_funcmem);
void __GenEventInfoProduct_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(2);
  rule = &readrules[0];
  rule->fSourceClass = "GenEventInfoProduct";
  rule->fTarget      = "nMEPartons_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenEventInfoProduct_0);
  rule->fCode        = "\n    nMEPartons_ = -1;\n ";
  rule->fVersion     = "[-10]";
  rule = &readrules[1];
  rule->fSourceClass = "GenEventInfoProduct";
  rule->fTarget      = "nMEPartonsFiltered_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenEventInfoProduct_1);
  rule->fCode        = "\n    nMEPartonsFiltered_ = -1;\n ";
  rule->fVersion     = "[-10]";


  ::Reflex::ClassBuilder(Reflex::Literal("GenEventInfoProduct"), typeid(::GenEventInfoProduct), sizeof(::GenEventInfoProduct), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddProperty("ioread", readrules )
  .AddTypedef(type_4043, Reflex::Literal("GenEventInfoProduct::PDF"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenEventInfoProduct"), constructor_4045, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18345), Reflex::Literal("GenEventInfoProduct"), constructor_4046, 0, "evt", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18346), Reflex::Literal("GenEventInfoProduct"), constructor_4047, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenEventInfoProduct"), destructor_4048, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_341, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenEventInfoProduct_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenEventInfoProduct_funcmem_bld);
}

//------Delayed data member builder for class GenEventInfoProduct -------------------
void __GenEventInfoProduct_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2807, Reflex::Literal("weights_"), OffsetOf(__shadow__::__GenEventInfoProduct, weights_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("signalProcessID_"), OffsetOf(__shadow__::__GenEventInfoProduct, signalProcessID_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("qScale_"), OffsetOf(__shadow__::__GenEventInfoProduct, qScale_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("alphaQCD_"), OffsetOf(__shadow__::__GenEventInfoProduct, alphaQCD_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("alphaQED_"), OffsetOf(__shadow__::__GenEventInfoProduct, alphaQED_), ::Reflex::PRIVATE)
  .AddDataMember(type_2551, Reflex::Literal("pdf_"), OffsetOf(__shadow__::__GenEventInfoProduct, pdf_), ::Reflex::PRIVATE)
  .AddDataMember(type_2807, Reflex::Literal("binningValues_"), OffsetOf(__shadow__::__GenEventInfoProduct, binningValues_), ::Reflex::PRIVATE)
  .AddDataMember(type_2806, Reflex::Literal("DJRValues_"), OffsetOf(__shadow__::__GenEventInfoProduct, DJRValues_), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("nMEPartons_"), OffsetOf(__shadow__::__GenEventInfoProduct, nMEPartons_), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("nMEPartonsFiltered_"), OffsetOf(__shadow__::__GenEventInfoProduct, nMEPartonsFiltered_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenEventInfoProduct -------------------
void __GenEventInfoProduct_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18347, type_18346), Reflex::Literal("operator="), operator_4049, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9222), Reflex::Literal("weights"), method_4050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("weight"), method_4051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("signalProcessID"), method_4052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("qScale"), method_4053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("alphaQCD"), method_4054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("alphaQED"), method_4055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18348), Reflex::Literal("pdf"), method_4056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasPDF"), method_4057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9222), Reflex::Literal("binningValues"), method_4058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasBinningValues"), method_4059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18349), Reflex::Literal("DJRValues"), method_4060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasDJRValues"), method_4061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("nMEPartons"), method_4062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("nMEPartonsFiltered"), method_4063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_9222), Reflex::Literal("setWeights"), method_4064, 0, "weights", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198), Reflex::Literal("setSignalProcessID"), method_4065, 0, "procID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102, type_102, type_102), Reflex::Literal("setScales"), method_4066, 0, "q=-1.0e+0;qcd=-1.0e+0;qed=-1.0e+0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18348), Reflex::Literal("setPDF"), method_4067, 0, "pdf", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_9222), Reflex::Literal("setBinningValues"), method_4068, 0, "values", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18349), Reflex::Literal("setDJR"), method_4069, 0, "values", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("setNMEPartons"), method_4070, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("setNMEPartonsFiltered"), method_4071, 0, "n", ::Reflex::PUBLIC);
}
//------Stub functions for class LHEEventProduct -------------------------------
static  void operator_4253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LHEEventProduct*)o)->operator=)(*(::LHEEventProduct*)arg[0]);
  else   (((::LHEEventProduct*)o)->operator=)(*(::LHEEventProduct*)arg[0]);
}

static void constructor_4254( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEEventProduct(*(::LHEEventProduct*)arg[0]);
  else ::new(mem) ::LHEEventProduct(*(::LHEEventProduct*)arg[0]);
}

static void constructor_4255( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEEventProduct();
  else ::new(mem) ::LHEEventProduct();
}

static void constructor_4256( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEEventProduct(*(const ::lhef::HEPEUP*)arg[0]);
  else ::new(mem) ::LHEEventProduct(*(const ::lhef::HEPEUP*)arg[0]);
}

static void constructor_4257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEEventProduct(*(const ::lhef::HEPEUP*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::LHEEventProduct(*(const ::lhef::HEPEUP*)arg[0],
      *(const double*)arg[1]);
}

static void destructor_4258(void*, void * o, const std::vector<void*>&, void *) {
(((::LHEEventProduct*)o)->::LHEEventProduct::~LHEEventProduct)();
}
static  void method_4259( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHEEventProduct*)o)->setPDF)(*(const ::gen::PdfInfo*)arg[0]);
}

static  void method_4260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHEEventProduct*)o)->addWeight)(*(const ::gen::WeightsInfo*)arg[0]);
}

static  void method_4261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHEEventProduct*)o)->addComment)(*(const ::std::string*)arg[0]);
}

static  void method_4262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::LHEEventProduct*)o)->originalXWGTUP)());
  else   (((const ::LHEEventProduct*)o)->originalXWGTUP)();
}

static  void method_4263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHEEventProduct*)o)->weights)();
  else   (((const ::LHEEventProduct*)o)->weights)();
}

static  void method_4264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHEEventProduct*)o)->scales)();
  else   (((const ::LHEEventProduct*)o)->scales)();
}

static  void method_4265( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHEEventProduct*)o)->setScales)(*(const ::std::vector<float>*)arg[0]);
}

static  void method_4266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::LHEEventProduct*)o)->npLO)());
  else   (((const ::LHEEventProduct*)o)->npLO)();
}

static  void method_4267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::LHEEventProduct*)o)->npNLO)());
  else   (((const ::LHEEventProduct*)o)->npNLO)();
}

static  void method_4268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHEEventProduct*)o)->setNpLO)(*(int*)arg[0]);
}

static  void method_4269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHEEventProduct*)o)->setNpNLO)(*(int*)arg[0]);
}

static  void method_4270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHEEventProduct*)o)->hepeup)();
  else   (((const ::LHEEventProduct*)o)->hepeup)();
}

static  void method_4271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::LHEEventProduct*)o)->pdf)());
  else   (((const ::LHEEventProduct*)o)->pdf)();
}

static  void method_4272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::LHEEventProduct*)o)->comments_size)());
  else   (((const ::LHEEventProduct*)o)->comments_size)();
}

static  void method_4273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::LHEEventProduct*)o)->comments_begin)());
  else   (((const ::LHEEventProduct*)o)->comments_begin)();
}

static  void method_4274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::LHEEventProduct*)o)->comments_end)());
  else   (((const ::LHEEventProduct*)o)->comments_end)();
}

static  void method_4275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (LHEEventProduct::const_iterator)((((const ::LHEEventProduct*)o)->begin)());
  else   (((const ::LHEEventProduct*)o)->begin)();
}

static  void method_4276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (LHEEventProduct::const_iterator)((((const ::LHEEventProduct*)o)->end)());
  else   (((const ::LHEEventProduct*)o)->end)();
}

static void method_newdel_459( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LHEEventProduct >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LHEEventProduct >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LHEEventProduct >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LHEEventProduct >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LHEEventProduct >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___LHEEventProduct_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  int &npLO_ = *(int*)(target + OffsetOf(__shadow__::__LHEEventProduct, npLO_));

  //--- User's code ---
    npLO_ = -99;
  
}

void read___LHEEventProduct_1( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  int &npNLO_ = *(int*)(target + OffsetOf(__shadow__::__LHEEventProduct, npNLO_));

  //--- User's code ---
    npNLO_ = -99;
  
}

//------Dictionary for class LHEEventProduct -------------------------------
void __LHEEventProduct_db_datamem(Reflex::Class*);
void __LHEEventProduct_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LHEEventProduct_datamem_bld(&__LHEEventProduct_db_datamem);
Reflex::GenreflexMemberBuilder __LHEEventProduct_funcmem_bld(&__LHEEventProduct_db_funcmem);
void __LHEEventProduct_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(2);
  rule = &readrules[0];
  rule->fSourceClass = "LHEEventProduct";
  rule->fTarget      = "npLO_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___LHEEventProduct_0);
  rule->fCode        = "\n    npLO_ = -99;\n  ";
  rule->fVersion     = "[-12]";
  rule = &readrules[1];
  rule->fSourceClass = "LHEEventProduct";
  rule->fTarget      = "npNLO_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___LHEEventProduct_1);
  rule->fCode        = "\n    npNLO_ = -99;\n  ";
  rule->fVersion     = "[-12]";


  ::Reflex::ClassBuilder(Reflex::Literal("LHEEventProduct"), typeid(::LHEEventProduct), sizeof(::LHEEventProduct), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "13")
  .AddProperty("ioread", readrules )
  .AddTypedef(type_4043, Reflex::Literal("LHEEventProduct::PDF"))
  .AddTypedef(type_4248, Reflex::Literal("LHEEventProduct::WGT"))
  .AddTypedef(type_4250, Reflex::Literal("LHEEventProduct::comments_const_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("LHEEventProduct::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19216, type_19216), Reflex::Literal("operator="), operator_4253, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19216), Reflex::Literal("LHEEventProduct"), constructor_4254, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LHEEventProduct"), constructor_4255, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19217), Reflex::Literal("LHEEventProduct"), constructor_4256, 0, "hepeup", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19217, type_102c), Reflex::Literal("LHEEventProduct"), constructor_4257, 0, "hepeup;originalXWGTUP", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LHEEventProduct"), destructor_4258, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_459, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LHEEventProduct_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LHEEventProduct_funcmem_bld);
}

//------Delayed data member builder for class LHEEventProduct -------------------
void __LHEEventProduct_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4728, Reflex::Literal("hepeup_"), OffsetOf(__shadow__::__LHEEventProduct, hepeup_), ::Reflex::PRIVATE)
  .AddDataMember(type_2811, Reflex::Literal("comments_"), OffsetOf(__shadow__::__LHEEventProduct, comments_), ::Reflex::PRIVATE)
  .AddDataMember(type_2551, Reflex::Literal("pdf_"), OffsetOf(__shadow__::__LHEEventProduct, pdf_), ::Reflex::PRIVATE)
  .AddDataMember(type_2801, Reflex::Literal("weights_"), OffsetOf(__shadow__::__LHEEventProduct, weights_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("originalXWGTUP_"), OffsetOf(__shadow__::__LHEEventProduct, originalXWGTUP_), ::Reflex::PRIVATE)
  .AddDataMember(type_2806, Reflex::Literal("scales_"), OffsetOf(__shadow__::__LHEEventProduct, scales_), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("npLO_"), OffsetOf(__shadow__::__LHEEventProduct, npLO_), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("npNLO_"), OffsetOf(__shadow__::__LHEEventProduct, npNLO_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class LHEEventProduct -------------------
void __LHEEventProduct_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_19218), Reflex::Literal("setPDF"), method_4259, 0, "pdf", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10085), Reflex::Literal("addWeight"), method_4260, 0, "wgt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_12177), Reflex::Literal("addComment"), method_4261, 0, "line", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("originalXWGTUP"), method_4262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19219), Reflex::Literal("weights"), method_4263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18349), Reflex::Literal("scales"), method_4264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18349), Reflex::Literal("setScales"), method_4265, 0, "scales", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("npLO"), method_4266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("npNLO"), method_4267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("setNpLO"), method_4268, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("setNpNLO"), method_4269, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19217), Reflex::Literal("hepeup"), method_4270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18348), Reflex::Literal("pdf"), method_4271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("comments_size"), method_4272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4250), Reflex::Literal("comments_begin"), method_4273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4250), Reflex::Literal("comments_end"), method_4274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4238), Reflex::Literal("begin"), method_4275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4238), Reflex::Literal("end"), method_4276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class LHEXMLStringProduct -------------------------------
static  void operator_4615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LHEXMLStringProduct*)o)->operator=)(*(const ::LHEXMLStringProduct*)arg[0]);
  else   (((::LHEXMLStringProduct*)o)->operator=)(*(const ::LHEXMLStringProduct*)arg[0]);
}

static void constructor_4616( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEXMLStringProduct(*(const ::LHEXMLStringProduct*)arg[0]);
  else ::new(mem) ::LHEXMLStringProduct(*(const ::LHEXMLStringProduct*)arg[0]);
}

static void constructor_4617( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEXMLStringProduct();
  else ::new(mem) ::LHEXMLStringProduct();
}

static void constructor_4618( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEXMLStringProduct(*(const ::std::string*)arg[0]);
  else ::new(mem) ::LHEXMLStringProduct(*(const ::std::string*)arg[0]);
}

static void constructor_4619( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHEXMLStringProduct(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::LHEXMLStringProduct(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static void destructor_4620(void*, void * o, const std::vector<void*>&, void *) {
(((::LHEXMLStringProduct*)o)->::LHEXMLStringProduct::~LHEXMLStringProduct)();
}
static  void method_4621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHEXMLStringProduct*)o)->getStrings)();
  else   (((const ::LHEXMLStringProduct*)o)->getStrings)();
}

static  void method_4622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::LHEXMLStringProduct*)o)->mergeProduct)(*(const ::LHEXMLStringProduct*)arg[0]));
  else   (((::LHEXMLStringProduct*)o)->mergeProduct)(*(const ::LHEXMLStringProduct*)arg[0]);
}

static void method_newdel_690( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LHEXMLStringProduct >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LHEXMLStringProduct >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LHEXMLStringProduct >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LHEXMLStringProduct >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LHEXMLStringProduct >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LHEXMLStringProduct -------------------------------
void __LHEXMLStringProduct_db_datamem(Reflex::Class*);
void __LHEXMLStringProduct_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LHEXMLStringProduct_datamem_bld(&__LHEXMLStringProduct_db_datamem);
Reflex::GenreflexMemberBuilder __LHEXMLStringProduct_funcmem_bld(&__LHEXMLStringProduct_db_funcmem);
void __LHEXMLStringProduct_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LHEXMLStringProduct"), typeid(::LHEXMLStringProduct), sizeof(::LHEXMLStringProduct), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19666, type_19667), Reflex::Literal("operator="), operator_4615, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19667), Reflex::Literal("LHEXMLStringProduct"), constructor_4616, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LHEXMLStringProduct"), constructor_4617, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12177), Reflex::Literal("LHEXMLStringProduct"), constructor_4618, 0, "content", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9219), Reflex::Literal("LHEXMLStringProduct"), constructor_4619, 0, "content", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LHEXMLStringProduct"), destructor_4620, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_690, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LHEXMLStringProduct_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LHEXMLStringProduct_funcmem_bld);
}

//------Delayed data member builder for class LHEXMLStringProduct -------------------
void __LHEXMLStringProduct_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("content_"), OffsetOf(__shadow__::__LHEXMLStringProduct, content_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class LHEXMLStringProduct -------------------
void __LHEXMLStringProduct_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9219), Reflex::Literal("getStrings"), method_4621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19667), Reflex::Literal("mergeProduct"), method_4622, 0, "other", ::Reflex::PUBLIC);
}
//------Stub functions for class LHERunInfoProduct -------------------------------
static  void operator_4665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LHERunInfoProduct*)o)->operator=)(*(const ::LHERunInfoProduct*)arg[0]);
  else   (((::LHERunInfoProduct*)o)->operator=)(*(const ::LHERunInfoProduct*)arg[0]);
}

static void constructor_4666( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHERunInfoProduct(*(const ::LHERunInfoProduct*)arg[0]);
  else ::new(mem) ::LHERunInfoProduct(*(const ::LHERunInfoProduct*)arg[0]);
}

static void constructor_4667( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHERunInfoProduct();
  else ::new(mem) ::LHERunInfoProduct();
}

static void constructor_4668( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHERunInfoProduct(*(const ::lhef::HEPRUP*)arg[0]);
  else ::new(mem) ::LHERunInfoProduct(*(const ::lhef::HEPRUP*)arg[0]);
}

static void destructor_4669(void*, void * o, const std::vector<void*>&, void *) {
(((::LHERunInfoProduct*)o)->::LHERunInfoProduct::~LHERunInfoProduct)();
}
static  void method_4670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHERunInfoProduct*)o)->addHeader)(*(const ::LHERunInfoProduct::Header*)arg[0]);
}

static  void method_4671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHERunInfoProduct*)o)->addComment)(*(const ::std::string*)arg[0]);
}

static  void method_4672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHERunInfoProduct*)o)->heprup)();
  else   (((const ::LHERunInfoProduct*)o)->heprup)();
}

static  void method_4673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::LHERunInfoProduct*)o)->headers_size)());
  else   (((const ::LHERunInfoProduct*)o)->headers_size)();
}

static  void method_4674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((const ::LHERunInfoProduct*)o)->headers_begin)());
  else   (((const ::LHERunInfoProduct*)o)->headers_begin)();
}

static  void method_4675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((const ::LHERunInfoProduct*)o)->headers_end)());
  else   (((const ::LHERunInfoProduct*)o)->headers_end)();
}

static  void method_4676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::LHERunInfoProduct*)o)->comments_size)());
  else   (((const ::LHERunInfoProduct*)o)->comments_size)();
}

static  void method_4677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::LHERunInfoProduct*)o)->comments_begin)());
  else   (((const ::LHERunInfoProduct*)o)->comments_begin)();
}

static  void method_4678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::LHERunInfoProduct*)o)->comments_end)());
  else   (((const ::LHERunInfoProduct*)o)->comments_end)();
}

static  void method_4679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (LHERunInfoProduct::const_iterator)((((const ::LHERunInfoProduct*)o)->begin)());
  else   (((const ::LHERunInfoProduct*)o)->begin)();
}

static  void method_4680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (LHERunInfoProduct::const_iterator)((((const ::LHERunInfoProduct*)o)->init)());
  else   (((const ::LHERunInfoProduct*)o)->init)();
}

static  void method_4681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (LHERunInfoProduct::const_iterator)((((const ::LHERunInfoProduct*)o)->end)());
  else   (((const ::LHERunInfoProduct*)o)->end)();
}

static  void method_4682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LHERunInfoProduct*)o)->endOfFile)();
  else   (((::LHERunInfoProduct*)o)->endOfFile)();
}

static  void operator_4683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::LHERunInfoProduct*)o)->operator==)(*(const ::LHERunInfoProduct*)arg[0]));
  else   (((const ::LHERunInfoProduct*)o)->operator==)(*(const ::LHERunInfoProduct*)arg[0]);
}

static  void operator_4684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::LHERunInfoProduct*)o)->operator!=)(*(const ::LHERunInfoProduct*)arg[0]));
  else   (((const ::LHERunInfoProduct*)o)->operator!=)(*(const ::LHERunInfoProduct*)arg[0]);
}

static  void method_4685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::LHERunInfoProduct*)o)->mergeProduct)(*(const ::LHERunInfoProduct*)arg[0]));
  else   (((::LHERunInfoProduct*)o)->mergeProduct)(*(const ::LHERunInfoProduct*)arg[0]);
}

static  void method_4686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::LHERunInfoProduct*)o)->isProductEqual)(*(const ::LHERunInfoProduct*)arg[0]));
  else   (((const ::LHERunInfoProduct*)o)->isProductEqual)(*(const ::LHERunInfoProduct*)arg[0]);
}

static void method_newdel_818( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LHERunInfoProduct -------------------------------
void __LHERunInfoProduct_db_datamem(Reflex::Class*);
void __LHERunInfoProduct_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LHERunInfoProduct_datamem_bld(&__LHERunInfoProduct_db_datamem);
Reflex::GenreflexMemberBuilder __LHERunInfoProduct_funcmem_bld(&__LHERunInfoProduct_db_funcmem);
void __LHERunInfoProduct_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LHERunInfoProduct"), typeid(::LHERunInfoProduct), sizeof(::LHERunInfoProduct), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_2813, Reflex::Literal("LHERunInfoProduct::weights_defs"))
  .AddTypedef(type_3033, Reflex::Literal("LHERunInfoProduct::size_type"))
  .AddTypedef(type_4662, Reflex::Literal("LHERunInfoProduct::headers_const_iterator"))
  .AddTypedef(type_4250, Reflex::Literal("LHERunInfoProduct::comments_const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19755, type_19756), Reflex::Literal("operator="), operator_4665, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19756), Reflex::Literal("LHERunInfoProduct"), constructor_4666, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LHERunInfoProduct"), constructor_4667, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19757), Reflex::Literal("LHERunInfoProduct"), constructor_4668, 0, "heprup", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LHERunInfoProduct"), destructor_4669, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_818, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LHERunInfoProduct_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LHERunInfoProduct_funcmem_bld);
}

//------Delayed data member builder for class LHERunInfoProduct -------------------
void __LHERunInfoProduct_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4729, Reflex::Literal("heprup_"), OffsetOf(__shadow__::__LHERunInfoProduct, heprup_), ::Reflex::PRIVATE)
  .AddDataMember(type_2812, Reflex::Literal("headers_"), OffsetOf(__shadow__::__LHERunInfoProduct, headers_), ::Reflex::PRIVATE)
  .AddDataMember(type_2811, Reflex::Literal("comments_"), OffsetOf(__shadow__::__LHERunInfoProduct, comments_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class LHERunInfoProduct -------------------
void __LHERunInfoProduct_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6902), Reflex::Literal("addHeader"), method_4670, 0, "header", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_12177), Reflex::Literal("addComment"), method_4671, 0, "line", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19757), Reflex::Literal("heprup"), method_4672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("headers_size"), method_4673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662), Reflex::Literal("headers_begin"), method_4674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662), Reflex::Literal("headers_end"), method_4675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("comments_size"), method_4676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4250), Reflex::Literal("comments_begin"), method_4677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4250), Reflex::Literal("comments_end"), method_4678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4655), Reflex::Literal("begin"), method_4679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4655), Reflex::Literal("init"), method_4680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4655), Reflex::Literal("end"), method_4681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12177), Reflex::Literal("endOfFile"), method_4682, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19756), Reflex::Literal("operator=="), operator_4683, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19756), Reflex::Literal("operator!="), operator_4684, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19756), Reflex::Literal("mergeProduct"), method_4685, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19756), Reflex::Literal("isProductEqual"), method_4686, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GenFilterInfo -------------------------------
static  void operator_4700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenFilterInfo*)o)->operator=)(*(const ::GenFilterInfo*)arg[0]);
  else   (((::GenFilterInfo*)o)->operator=)(*(const ::GenFilterInfo*)arg[0]);
}

static void constructor_4701( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenFilterInfo();
  else ::new(mem) ::GenFilterInfo();
}

static void constructor_4702( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenFilterInfo(*(unsigned int*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::GenFilterInfo(*(unsigned int*)arg[0],
      *(unsigned int*)arg[1]);
}

static void constructor_4703( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenFilterInfo(*(unsigned int*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(unsigned int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
  else ::new(mem) ::GenFilterInfo(*(unsigned int*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned int*)arg[2],
      *(unsigned int*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
}

static void constructor_4704( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenFilterInfo(*(const ::GenFilterInfo*)arg[0]);
  else ::new(mem) ::GenFilterInfo(*(const ::GenFilterInfo*)arg[0]);
}

static void destructor_4705(void*, void * o, const std::vector<void*>&, void *) {
(((::GenFilterInfo*)o)->::GenFilterInfo::~GenFilterInfo)();
}
static  void method_4706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenFilterInfo*)o)->numEventsTried)());
  else   (((const ::GenFilterInfo*)o)->numEventsTried)();
}

static  void method_4707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenFilterInfo*)o)->numEventsPassed)());
  else   (((const ::GenFilterInfo*)o)->numEventsPassed)();
}

static  void method_4708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenFilterInfo*)o)->numEventsTotal)());
  else   (((const ::GenFilterInfo*)o)->numEventsTotal)();
}

static  void method_4709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenFilterInfo*)o)->numPassPositiveEvents)());
  else   (((const ::GenFilterInfo*)o)->numPassPositiveEvents)();
}

static  void method_4710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenFilterInfo*)o)->numTotalPositiveEvents)());
  else   (((const ::GenFilterInfo*)o)->numTotalPositiveEvents)();
}

static  void method_4711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenFilterInfo*)o)->numPassNegativeEvents)());
  else   (((const ::GenFilterInfo*)o)->numPassNegativeEvents)();
}

static  void method_4712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenFilterInfo*)o)->numTotalNegativeEvents)());
  else   (((const ::GenFilterInfo*)o)->numTotalNegativeEvents)();
}

static  void method_4713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->sumPassWeights)());
  else   (((const ::GenFilterInfo*)o)->sumPassWeights)();
}

static  void method_4714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->sumPassWeights2)());
  else   (((const ::GenFilterInfo*)o)->sumPassWeights2)();
}

static  void method_4715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->sumFailWeights)());
  else   (((const ::GenFilterInfo*)o)->sumFailWeights)();
}

static  void method_4716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->sumFailWeights2)());
  else   (((const ::GenFilterInfo*)o)->sumFailWeights2)();
}

static  void method_4717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->sumWeights)());
  else   (((const ::GenFilterInfo*)o)->sumWeights)();
}

static  void method_4718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->sumWeights2)());
  else   (((const ::GenFilterInfo*)o)->sumWeights2)();
}

static  void method_4719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->filterEfficiency)());
    else     (((const ::GenFilterInfo*)o)->filterEfficiency)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->filterEfficiency)(*(int*)arg[0]));
    else     (((const ::GenFilterInfo*)o)->filterEfficiency)(*(int*)arg[0]);
  }
}

static  void method_4720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->filterEfficiencyError)());
    else     (((const ::GenFilterInfo*)o)->filterEfficiencyError)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::GenFilterInfo*)o)->filterEfficiencyError)(*(int*)arg[0]));
    else     (((const ::GenFilterInfo*)o)->filterEfficiencyError)(*(int*)arg[0]);
  }
}

static  void method_4721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GenFilterInfo*)o)->mergeProduct)(*(const ::GenFilterInfo*)arg[0]));
  else   (((::GenFilterInfo*)o)->mergeProduct)(*(const ::GenFilterInfo*)arg[0]);
}

static void method_newdel_866( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenFilterInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenFilterInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenFilterInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenFilterInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenFilterInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___GenFilterInfo_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_numEventsPassed_ = oldObj->GetId("numEventsPassed_");
#endif
  struct __GenFilterInfo_Onfile {
    unsigned int &numEventsPassed_;
    __GenFilterInfo_Onfile( unsigned int &onfile_numEventsPassed_ ): numEventsPassed_(onfile_numEventsPassed_){}
  };
  static Long_t offset_Onfile___GenFilterInfo_numEventsPassed_ = oldObj->GetClass()->GetDataMemberOffset("numEventsPassed_");
  char *onfile_add = (char*)oldObj->GetObject();
  __GenFilterInfo_Onfile onfile(
         *(unsigned int*)(onfile_add+offset_Onfile___GenFilterInfo_numEventsPassed_) );

  unsigned int &numPassPositiveEvents_ = *(unsigned int*)(target + OffsetOf(__shadow__::__GenFilterInfo, numPassPositiveEvents_));

  //--- User's code ---
	  numPassPositiveEvents_ = onfile.numEventsPassed_;
	
}

void read___GenFilterInfo_1( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  unsigned int &numPassNegativeEvents_ = *(unsigned int*)(target + OffsetOf(__shadow__::__GenFilterInfo, numPassNegativeEvents_));

  //--- User's code ---
	  numPassNegativeEvents_ = 0;
	
}

void read___GenFilterInfo_2( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_numEventsTried_ = oldObj->GetId("numEventsTried_");
#endif
  struct __GenFilterInfo_Onfile {
    unsigned int &numEventsTried_;
    __GenFilterInfo_Onfile( unsigned int &onfile_numEventsTried_ ): numEventsTried_(onfile_numEventsTried_){}
  };
  static Long_t offset_Onfile___GenFilterInfo_numEventsTried_ = oldObj->GetClass()->GetDataMemberOffset("numEventsTried_");
  char *onfile_add = (char*)oldObj->GetObject();
  __GenFilterInfo_Onfile onfile(
         *(unsigned int*)(onfile_add+offset_Onfile___GenFilterInfo_numEventsTried_) );

  unsigned int &numTotalPositiveEvents_ = *(unsigned int*)(target + OffsetOf(__shadow__::__GenFilterInfo, numTotalPositiveEvents_));

  //--- User's code ---
	  numTotalPositiveEvents_ = onfile.numEventsTried_;
	
}

void read___GenFilterInfo_3( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  unsigned int &numTotalNegativeEvents_ = *(unsigned int*)(target + OffsetOf(__shadow__::__GenFilterInfo, numTotalNegativeEvents_));

  //--- User's code ---
	  numTotalNegativeEvents_ = 0;
	
}

void read___GenFilterInfo_4( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_numEventsPassed_ = oldObj->GetId("numEventsPassed_");
#endif
  struct __GenFilterInfo_Onfile {
    unsigned int &numEventsPassed_;
    __GenFilterInfo_Onfile( unsigned int &onfile_numEventsPassed_ ): numEventsPassed_(onfile_numEventsPassed_){}
  };
  static Long_t offset_Onfile___GenFilterInfo_numEventsPassed_ = oldObj->GetClass()->GetDataMemberOffset("numEventsPassed_");
  char *onfile_add = (char*)oldObj->GetObject();
  __GenFilterInfo_Onfile onfile(
         *(unsigned int*)(onfile_add+offset_Onfile___GenFilterInfo_numEventsPassed_) );

  double &sumPassWeights_ = *(double*)(target + OffsetOf(__shadow__::__GenFilterInfo, sumPassWeights_));

  //--- User's code ---
	  sumPassWeights_ = onfile.numEventsPassed_;
	
}

void read___GenFilterInfo_5( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_numEventsPassed_ = oldObj->GetId("numEventsPassed_");
#endif
  struct __GenFilterInfo_Onfile {
    unsigned int &numEventsPassed_;
    __GenFilterInfo_Onfile( unsigned int &onfile_numEventsPassed_ ): numEventsPassed_(onfile_numEventsPassed_){}
  };
  static Long_t offset_Onfile___GenFilterInfo_numEventsPassed_ = oldObj->GetClass()->GetDataMemberOffset("numEventsPassed_");
  char *onfile_add = (char*)oldObj->GetObject();
  __GenFilterInfo_Onfile onfile(
         *(unsigned int*)(onfile_add+offset_Onfile___GenFilterInfo_numEventsPassed_) );

  double &sumPassWeights2_ = *(double*)(target + OffsetOf(__shadow__::__GenFilterInfo, sumPassWeights2_));

  //--- User's code ---
	  sumPassWeights2_ = onfile.numEventsPassed_;
	
}

void read___GenFilterInfo_6( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_numEventsTried_ = oldObj->GetId("numEventsTried_");
#endif
  struct __GenFilterInfo_Onfile {
    unsigned int &numEventsTried_;
    __GenFilterInfo_Onfile( unsigned int &onfile_numEventsTried_ ): numEventsTried_(onfile_numEventsTried_){}
  };
  static Long_t offset_Onfile___GenFilterInfo_numEventsTried_ = oldObj->GetClass()->GetDataMemberOffset("numEventsTried_");
  char *onfile_add = (char*)oldObj->GetObject();
  __GenFilterInfo_Onfile onfile(
         *(unsigned int*)(onfile_add+offset_Onfile___GenFilterInfo_numEventsTried_) );

  double &sumTotalWeights_ = *(double*)(target + OffsetOf(__shadow__::__GenFilterInfo, sumTotalWeights_));

  //--- User's code ---
	  sumTotalWeights_ = onfile.numEventsTried_;
	
}

void read___GenFilterInfo_7( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_numEventsTried_ = oldObj->GetId("numEventsTried_");
#endif
  struct __GenFilterInfo_Onfile {
    unsigned int &numEventsTried_;
    __GenFilterInfo_Onfile( unsigned int &onfile_numEventsTried_ ): numEventsTried_(onfile_numEventsTried_){}
  };
  static Long_t offset_Onfile___GenFilterInfo_numEventsTried_ = oldObj->GetClass()->GetDataMemberOffset("numEventsTried_");
  char *onfile_add = (char*)oldObj->GetObject();
  __GenFilterInfo_Onfile onfile(
         *(unsigned int*)(onfile_add+offset_Onfile___GenFilterInfo_numEventsTried_) );

  double &sumTotalWeights2_ = *(double*)(target + OffsetOf(__shadow__::__GenFilterInfo, sumTotalWeights2_));

  //--- User's code ---
	  sumTotalWeights2_ = onfile.numEventsTried_;
	
}

//------Dictionary for class GenFilterInfo -------------------------------
void __GenFilterInfo_db_datamem(Reflex::Class*);
void __GenFilterInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenFilterInfo_datamem_bld(&__GenFilterInfo_db_datamem);
Reflex::GenreflexMemberBuilder __GenFilterInfo_funcmem_bld(&__GenFilterInfo_db_funcmem);
void __GenFilterInfo_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(8);
  rule = &readrules[0];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "numPassPositiveEvents_";
  rule->fSource      = "unsigned int numEventsPassed_";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_0);
  rule->fCode        = "\n	  numPassPositiveEvents_ = onfile.numEventsPassed_;\n	";
  rule->fVersion     = "[-10]";
  rule = &readrules[1];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "numPassNegativeEvents_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_1);
  rule->fCode        = "\n	  numPassNegativeEvents_ = 0;\n	";
  rule->fVersion     = "[-10]";
  rule = &readrules[2];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "numTotalPositiveEvents_";
  rule->fSource      = "unsigned int numEventsTried_";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_2);
  rule->fCode        = "\n	  numTotalPositiveEvents_ = onfile.numEventsTried_;\n	";
  rule->fVersion     = "[-10]";
  rule = &readrules[3];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "numTotalNegativeEvents_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_3);
  rule->fCode        = "\n	  numTotalNegativeEvents_ = 0;\n	";
  rule->fVersion     = "[-10]";
  rule = &readrules[4];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "sumPassWeights_";
  rule->fSource      = "unsigned int numEventsPassed_";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_4);
  rule->fCode        = "\n	  sumPassWeights_ = onfile.numEventsPassed_;\n	";
  rule->fVersion     = "[-10]";
  rule = &readrules[5];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "sumPassWeights2_";
  rule->fSource      = "unsigned int numEventsPassed_";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_5);
  rule->fCode        = "\n	  sumPassWeights2_ = onfile.numEventsPassed_;\n	";
  rule->fVersion     = "[-10]";
  rule = &readrules[6];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "sumTotalWeights_";
  rule->fSource      = "unsigned int numEventsTried_";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_6);
  rule->fCode        = "\n	  sumTotalWeights_ = onfile.numEventsTried_;\n	";
  rule->fVersion     = "[-10]";
  rule = &readrules[7];
  rule->fSourceClass = "GenFilterInfo";
  rule->fTarget      = "sumTotalWeights2_";
  rule->fSource      = "unsigned int numEventsTried_";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___GenFilterInfo_7);
  rule->fCode        = "\n	  sumTotalWeights2_ = onfile.numEventsTried_;\n	";
  rule->fVersion     = "[-10]";


  ::Reflex::ClassBuilder(Reflex::Literal("GenFilterInfo"), typeid(::GenFilterInfo), sizeof(::GenFilterInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19758, type_19759), Reflex::Literal("operator="), operator_4700, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenFilterInfo"), constructor_4701, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_198, type_198), Reflex::Literal("GenFilterInfo"), constructor_4702, 0, ";", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_198, type_198, type_198, type_198, type_102, type_102, type_102, type_102), Reflex::Literal("GenFilterInfo"), constructor_4703, 0, ";;;;;;;", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19759), Reflex::Literal("GenFilterInfo"), constructor_4704, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenFilterInfo"), destructor_4705, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_866, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenFilterInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenFilterInfo_funcmem_bld);
}

//------Delayed data member builder for class GenFilterInfo -------------------
void __GenFilterInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_198, Reflex::Literal("numPassPositiveEvents_"), OffsetOf(__shadow__::__GenFilterInfo, numPassPositiveEvents_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("numPassNegativeEvents_"), OffsetOf(__shadow__::__GenFilterInfo, numPassNegativeEvents_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("numTotalPositiveEvents_"), OffsetOf(__shadow__::__GenFilterInfo, numTotalPositiveEvents_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("numTotalNegativeEvents_"), OffsetOf(__shadow__::__GenFilterInfo, numTotalNegativeEvents_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sumPassWeights_"), OffsetOf(__shadow__::__GenFilterInfo, sumPassWeights_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sumPassWeights2_"), OffsetOf(__shadow__::__GenFilterInfo, sumPassWeights2_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sumTotalWeights_"), OffsetOf(__shadow__::__GenFilterInfo, sumTotalWeights_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sumTotalWeights2_"), OffsetOf(__shadow__::__GenFilterInfo, sumTotalWeights2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenFilterInfo -------------------
void __GenFilterInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("numEventsTried"), method_4706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("numEventsPassed"), method_4707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("numEventsTotal"), method_4708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("numPassPositiveEvents"), method_4709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("numTotalPositiveEvents"), method_4710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("numPassNegativeEvents"), method_4711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("numTotalNegativeEvents"), method_4712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumPassWeights"), method_4713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumPassWeights2"), method_4714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumFailWeights"), method_4715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumFailWeights2"), method_4716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumWeights"), method_4717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumWeights2"), method_4718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102, type_67), Reflex::Literal("filterEfficiency"), method_4719, 0, "idwtup=3", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102, type_67), Reflex::Literal("filterEfficiencyError"), method_4720, 0, "idwtup=3", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19759), Reflex::Literal("mergeProduct"), method_4721, 0, "other", ::Reflex::PUBLIC);
}
//------Stub functions for class GenRunInfoProduct -------------------------------
static  void operator_5076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenRunInfoProduct*)o)->operator=)(*(const ::GenRunInfoProduct*)arg[0]);
  else   (((::GenRunInfoProduct*)o)->operator=)(*(const ::GenRunInfoProduct*)arg[0]);
}

static void constructor_5077( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenRunInfoProduct();
  else ::new(mem) ::GenRunInfoProduct();
}

static void constructor_5078( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenRunInfoProduct(*(const ::GenRunInfoProduct*)arg[0]);
  else ::new(mem) ::GenRunInfoProduct(*(const ::GenRunInfoProduct*)arg[0]);
}

static void destructor_5079(void*, void * o, const std::vector<void*>&, void *) {
(((::GenRunInfoProduct*)o)->::GenRunInfoProduct::~GenRunInfoProduct)();
}
static  void method_5080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenRunInfoProduct*)o)->internalXSec)();
  else   (((const ::GenRunInfoProduct*)o)->internalXSec)();
}

static  void method_5081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenRunInfoProduct*)o)->externalXSecLO)();
  else   (((const ::GenRunInfoProduct*)o)->externalXSecLO)();
}

static  void method_5082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenRunInfoProduct*)o)->externalXSecNLO)();
  else   (((const ::GenRunInfoProduct*)o)->externalXSecNLO)();
}

static  void method_5083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenRunInfoProduct*)o)->filterEfficiency)());
  else   (((const ::GenRunInfoProduct*)o)->filterEfficiency)();
}

static  void method_5084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenRunInfoProduct*)o)->setInternalXSec)(*(const ::GenRunInfoProduct::XSec*)arg[0]);
}

static  void method_5085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenRunInfoProduct*)o)->setExternalXSecLO)(*(const ::GenRunInfoProduct::XSec*)arg[0]);
}

static  void method_5086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenRunInfoProduct*)o)->setExternalXSecNLO)(*(const ::GenRunInfoProduct::XSec*)arg[0]);
}

static  void method_5087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenRunInfoProduct*)o)->setFilterEfficiency)(*(double*)arg[0]);
}

static  void method_5088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenRunInfoProduct*)o)->crossSection)());
  else   (((const ::GenRunInfoProduct*)o)->crossSection)();
}

static  void method_5089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GenRunInfoProduct*)o)->mergeProduct)(*(const ::GenRunInfoProduct*)arg[0]));
  else   (((::GenRunInfoProduct*)o)->mergeProduct)(*(const ::GenRunInfoProduct*)arg[0]);
}

static  void method_5090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenRunInfoProduct*)o)->isProductEqual)(*(const ::GenRunInfoProduct*)arg[0]));
  else   (((const ::GenRunInfoProduct*)o)->isProductEqual)(*(const ::GenRunInfoProduct*)arg[0]);
}

static void method_newdel_1341( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenRunInfoProduct -------------------------------
void __GenRunInfoProduct_db_datamem(Reflex::Class*);
void __GenRunInfoProduct_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenRunInfoProduct_datamem_bld(&__GenRunInfoProduct_db_datamem);
Reflex::GenreflexMemberBuilder __GenRunInfoProduct_funcmem_bld(&__GenRunInfoProduct_db_funcmem);
void __GenRunInfoProduct_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenRunInfoProduct"), typeid(::GenRunInfoProduct), sizeof(::GenRunInfoProduct), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19889, type_19890), Reflex::Literal("operator="), operator_5076, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenRunInfoProduct"), constructor_5077, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19890), Reflex::Literal("GenRunInfoProduct"), constructor_5078, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenRunInfoProduct"), destructor_5079, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1341, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenRunInfoProduct_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenRunInfoProduct_funcmem_bld);
}

//------Delayed data member builder for class GenRunInfoProduct -------------------
void __GenRunInfoProduct_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5075, Reflex::Literal("internalXSec_"), OffsetOf(__shadow__::__GenRunInfoProduct, internalXSec_), ::Reflex::PRIVATE)
  .AddDataMember(type_5075, Reflex::Literal("externalXSecLO_"), OffsetOf(__shadow__::__GenRunInfoProduct, externalXSecLO_), ::Reflex::PRIVATE)
  .AddDataMember(type_5075, Reflex::Literal("externalXSecNLO_"), OffsetOf(__shadow__::__GenRunInfoProduct, externalXSecNLO_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("externalFilterEfficiency_"), OffsetOf(__shadow__::__GenRunInfoProduct, externalFilterEfficiency_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenRunInfoProduct -------------------
void __GenRunInfoProduct_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19891), Reflex::Literal("internalXSec"), method_5080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19891), Reflex::Literal("externalXSecLO"), method_5081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19891), Reflex::Literal("externalXSecNLO"), method_5082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("filterEfficiency"), method_5083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_19891), Reflex::Literal("setInternalXSec"), method_5084, 0, "xsec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_19891), Reflex::Literal("setExternalXSecLO"), method_5085, 0, "xsec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_19891), Reflex::Literal("setExternalXSecNLO"), method_5086, 0, "xsec", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setFilterEfficiency"), method_5087, 0, "effic", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("crossSection"), method_5088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19890), Reflex::Literal("mergeProduct"), method_5089, 0, "other", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19890), Reflex::Literal("isProductEqual"), method_5090, 0, "other", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class GenLumiInfoProduct -------------------------------
static  void operator_5602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenLumiInfoProduct*)o)->operator=)(*(const ::GenLumiInfoProduct*)arg[0]);
  else   (((::GenLumiInfoProduct*)o)->operator=)(*(const ::GenLumiInfoProduct*)arg[0]);
}

static void constructor_5603( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct();
  else ::new(mem) ::GenLumiInfoProduct();
}

static void constructor_5604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct(*(const int*)arg[0]);
  else ::new(mem) ::GenLumiInfoProduct(*(const int*)arg[0]);
}

static void constructor_5605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct(*(const ::GenLumiInfoProduct*)arg[0]);
  else ::new(mem) ::GenLumiInfoProduct(*(const ::GenLumiInfoProduct*)arg[0]);
}

static void destructor_5606(void*, void * o, const std::vector<void*>&, void *) {
(((::GenLumiInfoProduct*)o)->::GenLumiInfoProduct::~GenLumiInfoProduct)();
}
static  void method_5607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::GenLumiInfoProduct*)o)->getHEPIDWTUP)());
  else   (((const ::GenLumiInfoProduct*)o)->getHEPIDWTUP)();
}

static  void method_5608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenLumiInfoProduct*)o)->getProcessInfos)();
  else   (((const ::GenLumiInfoProduct*)o)->getProcessInfos)();
}

static  void method_5609( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct*)o)->setHEPIDWTUP)(*(const int*)arg[0]);
}

static  void method_5610( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct*)o)->setProcessInfo)(*(const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
}

static  void method_5611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::GenLumiInfoProduct*)o)->mergeProduct)(*(const ::GenLumiInfoProduct*)arg[0]));
  else   (((::GenLumiInfoProduct*)o)->mergeProduct)(*(const ::GenLumiInfoProduct*)arg[0]);
}

static  void method_5612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct*)o)->isProductEqual)(*(const ::GenLumiInfoProduct*)arg[0]));
  else   (((const ::GenLumiInfoProduct*)o)->isProductEqual)(*(const ::GenLumiInfoProduct*)arg[0]);
}

static  void method_5613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct*)o)->samePhysics)(*(const ::GenLumiInfoProduct*)arg[0]));
  else   (((const ::GenLumiInfoProduct*)o)->samePhysics)(*(const ::GenLumiInfoProduct*)arg[0]);
}

static void method_newdel_1920( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenLumiInfoProduct -------------------------------
void __GenLumiInfoProduct_db_datamem(Reflex::Class*);
void __GenLumiInfoProduct_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct_datamem_bld(&__GenLumiInfoProduct_db_datamem);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct_funcmem_bld(&__GenLumiInfoProduct_db_funcmem);
void __GenLumiInfoProduct_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenLumiInfoProduct"), typeid(::GenLumiInfoProduct), sizeof(::GenLumiInfoProduct), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22389, type_22390), Reflex::Literal("operator="), operator_5602, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenLumiInfoProduct"), constructor_5603, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_67c), Reflex::Literal("GenLumiInfoProduct"), constructor_5604, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22390), Reflex::Literal("GenLumiInfoProduct"), constructor_5605, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenLumiInfoProduct"), destructor_5606, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1920, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenLumiInfoProduct_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenLumiInfoProduct_funcmem_bld);
}

//------Delayed data member builder for class GenLumiInfoProduct -------------------
void __GenLumiInfoProduct_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67, Reflex::Literal("hepidwtup_"), OffsetOf(__shadow__::__GenLumiInfoProduct, hepidwtup_), ::Reflex::PRIVATE)
  .AddDataMember(type_2805, Reflex::Literal("internalProcesses_"), OffsetOf(__shadow__::__GenLumiInfoProduct, internalProcesses_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenLumiInfoProduct -------------------
void __GenLumiInfoProduct_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67c), Reflex::Literal("getHEPIDWTUP"), method_5607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22391), Reflex::Literal("getProcessInfos"), method_5608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67c), Reflex::Literal("setHEPIDWTUP"), method_5609, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_22391), Reflex::Literal("setProcessInfo"), method_5610, 0, "processes", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_22390), Reflex::Literal("mergeProduct"), method_5611, 0, "other", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_22390), Reflex::Literal("isProductEqual"), method_5612, 0, "other", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_22390), Reflex::Literal("samePhysics"), method_5613, 0, "other", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PdfInfo -------------------------------
static void destructor_18341(void*, void * o, const std::vector<void*>&, void *) {
(((::gen::PdfInfo*)o)->::gen::PdfInfo::~PdfInfo)();
}
static  void operator_18342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::gen::PdfInfo*)o)->operator=)(*(const ::gen::PdfInfo*)arg[0]);
  else   (((::gen::PdfInfo*)o)->operator=)(*(const ::gen::PdfInfo*)arg[0]);
}

static void constructor_18343( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::gen::PdfInfo(*(const ::gen::PdfInfo*)arg[0]);
  else ::new(mem) ::gen::PdfInfo(*(const ::gen::PdfInfo*)arg[0]);
}

static void constructor_18344( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::gen::PdfInfo();
  else ::new(mem) ::gen::PdfInfo();
}

static void method_newdel_4043( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::gen::PdfInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::gen::PdfInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::gen::PdfInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::gen::PdfInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::gen::PdfInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PdfInfo -------------------------------
void __gen__PdfInfo_db_datamem(Reflex::Class*);
void __gen__PdfInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __gen__PdfInfo_datamem_bld(&__gen__PdfInfo_db_datamem);
Reflex::GenreflexMemberBuilder __gen__PdfInfo_funcmem_bld(&__gen__PdfInfo_db_funcmem);
void __gen__PdfInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("gen::PdfInfo"), typeid(::gen::PdfInfo), sizeof(::gen::PdfInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PdfInfo"), destructor_18341, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24124, type_19218), Reflex::Literal("operator="), operator_18342, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19218), Reflex::Literal("PdfInfo"), constructor_18343, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PdfInfo"), constructor_18344, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4043, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__gen__PdfInfo_datamem_bld);
}

//------Delayed data member builder for class PdfInfo -------------------
void __gen__PdfInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2767, Reflex::Literal("id"), OffsetOf(__shadow__::__gen__PdfInfo, id), ::Reflex::PUBLIC)
  .AddDataMember(type_2768, Reflex::Literal("x"), OffsetOf(__shadow__::__gen__PdfInfo, x), ::Reflex::PUBLIC)
  .AddDataMember(type_2768, Reflex::Literal("xPDF"), OffsetOf(__shadow__::__gen__PdfInfo, xPDF), ::Reflex::PUBLIC)
  .AddDataMember(type_102, Reflex::Literal("scalePDF"), OffsetOf(__shadow__::__gen__PdfInfo, scalePDF), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class PdfInfo -------------------
void __gen__PdfInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class auto_ptr<gen::PdfInfo> -------------------------------
static void constructor_8943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::auto_ptr<gen::PdfInfo>();
  else ::new(mem) ::std::auto_ptr<gen::PdfInfo>();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::auto_ptr<gen::PdfInfo>((::gen::PdfInfo*)arg[0]);
  else ::new(mem) ::std::auto_ptr<gen::PdfInfo>((::gen::PdfInfo*)arg[0]);
  }
}

static void constructor_8944( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::auto_ptr<gen::PdfInfo>(*(::std::auto_ptr<gen::PdfInfo>*)arg[0]);
  else ::new(mem) ::std::auto_ptr<gen::PdfInfo>(*(::std::auto_ptr<gen::PdfInfo>*)arg[0]);
}

static  void operator_8945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::auto_ptr<gen::PdfInfo>*)o)->operator=)(*(::std::auto_ptr<gen::PdfInfo>*)arg[0]);
  else   (((::std::auto_ptr<gen::PdfInfo>*)o)->operator=)(*(::std::auto_ptr<gen::PdfInfo>*)arg[0]);
}

static void destructor_8946(void*, void * o, const std::vector<void*>&, void *) {
(((::std::auto_ptr<gen::PdfInfo>*)o)->::std::auto_ptr<gen::PdfInfo>::~auto_ptr)();
}
static  void operator_8947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::auto_ptr<gen::PdfInfo>*)o)->operator*)();
  else   (((const ::std::auto_ptr<gen::PdfInfo>*)o)->operator*)();
}

static  void operator_8948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::auto_ptr<gen::PdfInfo>*)o)->operator->)());
  else   (((const ::std::auto_ptr<gen::PdfInfo>*)o)->operator->)();
}

static  void method_8949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::auto_ptr<gen::PdfInfo>*)o)->get)());
  else   (((const ::std::auto_ptr<gen::PdfInfo>*)o)->get)();
}

static  void method_8950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::auto_ptr<gen::PdfInfo>*)o)->release)());
  else   (((::std::auto_ptr<gen::PdfInfo>*)o)->release)();
}

static  void method_8951( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::auto_ptr<gen::PdfInfo>*)o)->reset)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::auto_ptr<gen::PdfInfo>*)o)->reset)((::gen::PdfInfo*)arg[0]);
  }
}

static void constructor_8952( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::auto_ptr<gen::PdfInfo>(*(::std::auto_ptr_ref<gen::PdfInfo>*)arg[0]);
  else ::new(mem) ::std::auto_ptr<gen::PdfInfo>(*(::std::auto_ptr_ref<gen::PdfInfo>*)arg[0]);
}

static  void operator_8953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::auto_ptr<gen::PdfInfo>*)o)->operator=)(*(::std::auto_ptr_ref<gen::PdfInfo>*)arg[0]);
  else   (((::std::auto_ptr<gen::PdfInfo>*)o)->operator=)(*(::std::auto_ptr_ref<gen::PdfInfo>*)arg[0]);
}

static void constructor_x8( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::auto_ptr<gen::PdfInfo>();
  else ::new(mem) ::std::auto_ptr<gen::PdfInfo>();
}

static void method_newdel_2551( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::auto_ptr<gen::PdfInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::auto_ptr<gen::PdfInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::auto_ptr<gen::PdfInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::auto_ptr<gen::PdfInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::auto_ptr<gen::PdfInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class auto_ptr<gen::PdfInfo> -------------------------------
void __std__auto_ptr_gen__PdfInfo__db_datamem(Reflex::Class*);
void __std__auto_ptr_gen__PdfInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__auto_ptr_gen__PdfInfo__datamem_bld(&__std__auto_ptr_gen__PdfInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__auto_ptr_gen__PdfInfo__funcmem_bld(&__std__auto_ptr_gen__PdfInfo__db_funcmem);
void __std__auto_ptr_gen__PdfInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::auto_ptr<gen::PdfInfo>"), typeid(::std::auto_ptr<gen::PdfInfo>), sizeof(::std::auto_ptr<gen::PdfInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4043, Reflex::Literal("std::auto_ptr<gen::PdfInfo>::element_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23991), Reflex::Literal("auto_ptr"), constructor_8943, 0, "__p=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24123), Reflex::Literal("auto_ptr"), constructor_8944, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~auto_ptr"), destructor_8946, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2477), Reflex::Literal("auto_ptr"), constructor_8952, 0, "__ref", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("auto_ptr"), constructor_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2551, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__auto_ptr_gen__PdfInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__auto_ptr_gen__PdfInfo__funcmem_bld);
}

//------Delayed data member builder for class auto_ptr<gen::PdfInfo> -------------------
void __std__auto_ptr_gen__PdfInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_23991, Reflex::Literal("_M_ptr"), OffsetOf(__shadow__::__std__auto_ptr_gen__PdfInfo_, _M_ptr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class auto_ptr<gen::PdfInfo> -------------------
void __std__auto_ptr_gen__PdfInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24123, type_24123), Reflex::Literal("operator="), operator_8945, 0, "__a", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24124), Reflex::Literal("operator*"), operator_8947, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23991), Reflex::Literal("operator->"), operator_8948, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23991), Reflex::Literal("get"), method_8949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23991), Reflex::Literal("release"), method_8950, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_23991), Reflex::Literal("reset"), method_8951, 0, "__p=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24123, type_2477), Reflex::Literal("operator="), operator_8953, 0, "__ref", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class iterator<std::forward_iterator_tag,HepMC::GenParticle*,long int,HepMC::GenParticle**,HepMC::GenParticle*&> -------------------------------
static void destructor_9243(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>*)o)->::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>::~iterator)();
}
static  void operator_9244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>*)o)->operator=)(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>*)arg[0]);
  else   (((::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>*)o)->operator=)(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>*)arg[0]);
}

static void constructor_9245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>*)arg[0]);
}

static void constructor_9246( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>();
  else ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>();
}

static void method_newdel_2676( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::forward_iterator_tag,HepMC::GenParticle*,long int,HepMC::GenParticle**,HepMC::GenParticle*&> -------------------------------
void __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__db_datamem(Reflex::Class*);
void __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__datamem_bld(&__std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__funcmem_bld(&__std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__db_funcmem);
void __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>"), typeid(::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>), sizeof(::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::forward_iterator_tag,HepMC::GenParticle*>")
  .AddTypedef(type_2898, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>::iterator_category"))
  .AddTypedef(type_6865, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>::value_type"))
  .AddTypedef(type_62, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>::difference_type"))
  .AddTypedef(type_6231, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>::pointer"))
  .AddTypedef(type_9241, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_9243, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24186, type_24187), Reflex::Literal("operator="), operator_9244, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24187), Reflex::Literal("iterator"), constructor_9245, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_9246, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2676, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::forward_iterator_tag,HepMC::GenParticle*,long int,HepMC::GenParticle**,HepMC::GenParticle*&> -------------------
void __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::forward_iterator_tag,HepMC::GenParticle*,long int,HepMC::GenParticle**,HepMC::GenParticle*&> -------------------
void __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class iterator<std::forward_iterator_tag,HepMC::GenVertex*,long int,HepMC::GenVertex**,HepMC::GenVertex*&> -------------------------------
static void destructor_9255(void*, void * o, const std::vector<void*>&, void *) {
(((::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>*)o)->::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>::~iterator)();
}
static  void operator_9256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>*)o)->operator=)(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>*)arg[0]);
  else   (((::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>*)o)->operator=)(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>*)arg[0]);
}

static void constructor_9257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>*)arg[0]);
  else ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>(*(const ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>*)arg[0]);
}

static void constructor_9258( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>();
  else ::new(mem) ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>();
}

static void method_newdel_2677( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class iterator<std::forward_iterator_tag,HepMC::GenVertex*,long int,HepMC::GenVertex**,HepMC::GenVertex*&> -------------------------------
void __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__db_datamem(Reflex::Class*);
void __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__datamem_bld(&__std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__db_datamem);
Reflex::GenreflexMemberBuilder __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__funcmem_bld(&__std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__db_funcmem);
void __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>"), typeid(::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>), sizeof(::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("n_pattern"), "std::iterator<std::forward_iterator_tag,HepMC::GenVertex*>")
  .AddTypedef(type_2898, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>::iterator_category"))
  .AddTypedef(type_9248, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>::value_type"))
  .AddTypedef(type_62, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>::difference_type"))
  .AddTypedef(type_9251, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>::pointer"))
  .AddTypedef(type_9253, Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>::reference"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~iterator"), destructor_9255, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24188, type_24189), Reflex::Literal("operator="), operator_9256, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24189), Reflex::Literal("iterator"), constructor_9257, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("iterator"), constructor_9258, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2677, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class iterator<std::forward_iterator_tag,HepMC::GenVertex*,long int,HepMC::GenVertex**,HepMC::GenVertex*&> -------------------
void __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class iterator<std::forward_iterator_tag,HepMC::GenVertex*,long int,HepMC::GenVertex**,HepMC::GenVertex*&> -------------------
void __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const int,HepMC::GenVertex*> -------------------------------
static void destructor_9825(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const int,HepMC::GenVertex*>*)o)->::std::pair<const int,HepMC::GenVertex*>::~pair)();
}
static void constructor_9826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,HepMC::GenVertex*>(*(const ::std::pair<const int,HepMC::GenVertex*>*)arg[0]);
  else ::new(mem) ::std::pair<const int,HepMC::GenVertex*>(*(const ::std::pair<const int,HepMC::GenVertex*>*)arg[0]);
}

static void constructor_9827( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,HepMC::GenVertex*>();
  else ::new(mem) ::std::pair<const int,HepMC::GenVertex*>();
}

static void constructor_9828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,HepMC::GenVertex*>(*(const int*)arg[0],
      *(::HepMC::GenVertex* const*)arg[1]);
  else ::new(mem) ::std::pair<const int,HepMC::GenVertex*>(*(const int*)arg[0],
      *(::HepMC::GenVertex* const*)arg[1]);
}

static void method_newdel_2751( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenVertex*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenVertex*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenVertex*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenVertex*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenVertex*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const int,HepMC::GenVertex*> -------------------------------
void __std__pair_constsint_HepMC__GenVertexp__db_datamem(Reflex::Class*);
void __std__pair_constsint_HepMC__GenVertexp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsint_HepMC__GenVertexp__datamem_bld(&__std__pair_constsint_HepMC__GenVertexp__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsint_HepMC__GenVertexp__funcmem_bld(&__std__pair_constsint_HepMC__GenVertexp__db_funcmem);
void __std__pair_constsint_HepMC__GenVertexp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const int,HepMC::GenVertex*>"), typeid(::std::pair<const int,HepMC::GenVertex*>), sizeof(::std::pair<const int,HepMC::GenVertex*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_67c, Reflex::Literal("std::pair<const int,HepMC::GenVertex*>::first_type"))
  .AddTypedef(type_9248, Reflex::Literal("std::pair<const int,HepMC::GenVertex*>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_9825, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7884), Reflex::Literal("pair"), constructor_9826, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_9827, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10150, type_24290), Reflex::Literal("pair"), constructor_9828, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2751, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsint_HepMC__GenVertexp__datamem_bld);
}

//------Delayed data member builder for class pair<const int,HepMC::GenVertex*> -------------------
void __std__pair_constsint_HepMC__GenVertexp__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsint_HepMC__GenVertexp_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_9248, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsint_HepMC__GenVertexp_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const int,HepMC::GenVertex*> -------------------
void __std__pair_constsint_HepMC__GenVertexp__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const int,HepMC::GenParticle*> -------------------------------
static void destructor_9833(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const int,HepMC::GenParticle*>*)o)->::std::pair<const int,HepMC::GenParticle*>::~pair)();
}
static void constructor_9834( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,HepMC::GenParticle*>(*(const ::std::pair<const int,HepMC::GenParticle*>*)arg[0]);
  else ::new(mem) ::std::pair<const int,HepMC::GenParticle*>(*(const ::std::pair<const int,HepMC::GenParticle*>*)arg[0]);
}

static void constructor_9835( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,HepMC::GenParticle*>();
  else ::new(mem) ::std::pair<const int,HepMC::GenParticle*>();
}

static void constructor_9836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,HepMC::GenParticle*>(*(const int*)arg[0],
      *(::HepMC::GenParticle* const*)arg[1]);
  else ::new(mem) ::std::pair<const int,HepMC::GenParticle*>(*(const int*)arg[0],
      *(::HepMC::GenParticle* const*)arg[1]);
}

static void method_newdel_2752( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenParticle*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenParticle*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenParticle*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenParticle*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const int,HepMC::GenParticle*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const int,HepMC::GenParticle*> -------------------------------
void __std__pair_constsint_HepMC__GenParticlep__db_datamem(Reflex::Class*);
void __std__pair_constsint_HepMC__GenParticlep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsint_HepMC__GenParticlep__datamem_bld(&__std__pair_constsint_HepMC__GenParticlep__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsint_HepMC__GenParticlep__funcmem_bld(&__std__pair_constsint_HepMC__GenParticlep__db_funcmem);
void __std__pair_constsint_HepMC__GenParticlep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const int,HepMC::GenParticle*>"), typeid(::std::pair<const int,HepMC::GenParticle*>), sizeof(::std::pair<const int,HepMC::GenParticle*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_67c, Reflex::Literal("std::pair<const int,HepMC::GenParticle*>::first_type"))
  .AddTypedef(type_6865, Reflex::Literal("std::pair<const int,HepMC::GenParticle*>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_9833, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7989), Reflex::Literal("pair"), constructor_9834, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_9835, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10150, type_6870), Reflex::Literal("pair"), constructor_9836, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2752, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsint_HepMC__GenParticlep__datamem_bld);
}

//------Delayed data member builder for class pair<const int,HepMC::GenParticle*> -------------------
void __std__pair_constsint_HepMC__GenParticlep__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsint_HepMC__GenParticlep_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_6865, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsint_HepMC__GenParticlep_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const int,HepMC::GenParticle*> -------------------
void __std__pair_constsint_HepMC__GenParticlep__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class WeightsInfo -------------------------------
static void destructor_19165(void*, void * o, const std::vector<void*>&, void *) {
(((::gen::WeightsInfo*)o)->::gen::WeightsInfo::~WeightsInfo)();
}
static  void operator_19166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::gen::WeightsInfo*)o)->operator=)(*(const ::gen::WeightsInfo*)arg[0]);
  else   (((::gen::WeightsInfo*)o)->operator=)(*(const ::gen::WeightsInfo*)arg[0]);
}

static void constructor_19167( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::gen::WeightsInfo();
  else ::new(mem) ::gen::WeightsInfo();
}

static void constructor_19168( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::gen::WeightsInfo(*(const ::gen::WeightsInfo*)arg[0]);
  else ::new(mem) ::gen::WeightsInfo(*(const ::gen::WeightsInfo*)arg[0]);
}

static void constructor_19169( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::gen::WeightsInfo(*(const ::std::string*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::gen::WeightsInfo(*(const ::std::string*)arg[0],
      *(const double*)arg[1]);
}

static void method_newdel_4248( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::gen::WeightsInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::gen::WeightsInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::gen::WeightsInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::gen::WeightsInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::gen::WeightsInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class WeightsInfo -------------------------------
void __gen__WeightsInfo_db_datamem(Reflex::Class*);
void __gen__WeightsInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __gen__WeightsInfo_datamem_bld(&__gen__WeightsInfo_db_datamem);
Reflex::GenreflexMemberBuilder __gen__WeightsInfo_funcmem_bld(&__gen__WeightsInfo_db_funcmem);
void __gen__WeightsInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("gen::WeightsInfo"), typeid(::gen::WeightsInfo), sizeof(::gen::WeightsInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~WeightsInfo"), destructor_19165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10083, type_10085), Reflex::Literal("operator="), operator_19166, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("WeightsInfo"), constructor_19167, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10085), Reflex::Literal("WeightsInfo"), constructor_19168, 0, "o", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12177, type_102c), Reflex::Literal("WeightsInfo"), constructor_19169, 0, "s;w", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4248, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__gen__WeightsInfo_datamem_bld);
}

//------Delayed data member builder for class WeightsInfo -------------------
void __gen__WeightsInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2320, Reflex::Literal("id"), OffsetOf(__shadow__::__gen__WeightsInfo, id), ::Reflex::PUBLIC)
  .AddDataMember(type_102, Reflex::Literal("wgt"), OffsetOf(__shadow__::__gen__WeightsInfo, wgt), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class WeightsInfo -------------------
void __gen__WeightsInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<gen::WeightsInfo,std::allocator<gen::WeightsInfo> > -------------------------------
static void constructor_10094( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<gen::WeightsInfo>();
  else ::new(mem) ::std::vector<gen::WeightsInfo>();
}

static void constructor_10095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<gen::WeightsInfo>(*(const ::std::allocator<gen::WeightsInfo>*)arg[0]);
  else ::new(mem) ::std::vector<gen::WeightsInfo>(*(const ::std::allocator<gen::WeightsInfo>*)arg[0]);
}

static void constructor_10096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<gen::WeightsInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<gen::WeightsInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<gen::WeightsInfo>(*(::std::size_t*)arg[0],
      *(const ::gen::WeightsInfo*)arg[1]);
  else ::new(mem) ::std::vector<gen::WeightsInfo>(*(::std::size_t*)arg[0],
      *(const ::gen::WeightsInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<gen::WeightsInfo>(*(::std::size_t*)arg[0],
      *(const ::gen::WeightsInfo*)arg[1],
      *(const ::std::allocator<gen::WeightsInfo>*)arg[2]);
  else ::new(mem) ::std::vector<gen::WeightsInfo>(*(::std::size_t*)arg[0],
      *(const ::gen::WeightsInfo*)arg[1],
      *(const ::std::allocator<gen::WeightsInfo>*)arg[2]);
  }
}

static void constructor_10097( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<gen::WeightsInfo>(*(const ::std::vector<gen::WeightsInfo>*)arg[0]);
  else ::new(mem) ::std::vector<gen::WeightsInfo>(*(const ::std::vector<gen::WeightsInfo>*)arg[0]);
}

static void destructor_10098(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<gen::WeightsInfo>*)o)->::std::vector<gen::WeightsInfo>::~vector)();
}
static  void operator_10099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<gen::WeightsInfo>*)o)->operator=)(*(const ::std::vector<gen::WeightsInfo>*)arg[0]);
  else   (((::std::vector<gen::WeightsInfo>*)o)->operator=)(*(const ::std::vector<gen::WeightsInfo>*)arg[0]);
}

static  void method_10100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<gen::WeightsInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::gen::WeightsInfo*)arg[1]);
}

static  void method_10101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >)((((::std::vector<gen::WeightsInfo>*)o)->begin)());
  else   (((::std::vector<gen::WeightsInfo>*)o)->begin)();
}

static  void method_10102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const gen::WeightsInfo*,std::vector<gen::WeightsInfo> >)((((const ::std::vector<gen::WeightsInfo>*)o)->begin)());
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->begin)();
}

static  void method_10103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >)((((::std::vector<gen::WeightsInfo>*)o)->end)());
  else   (((::std::vector<gen::WeightsInfo>*)o)->end)();
}

static  void method_10104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const gen::WeightsInfo*,std::vector<gen::WeightsInfo> >)((((const ::std::vector<gen::WeightsInfo>*)o)->end)());
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->end)();
}

static  void method_10109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<gen::WeightsInfo>*)o)->size)());
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->size)();
}

static  void method_10110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<gen::WeightsInfo>*)o)->max_size)());
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->max_size)();
}

static  void method_10111( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<gen::WeightsInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<gen::WeightsInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::gen::WeightsInfo*)arg[1]);
  }
}

static  void method_10112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<gen::WeightsInfo>*)o)->capacity)());
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->capacity)();
}

static  void method_10113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<gen::WeightsInfo>*)o)->empty)());
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->empty)();
}

static  void method_10114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<gen::WeightsInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<gen::WeightsInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<gen::WeightsInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<gen::WeightsInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<gen::WeightsInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<gen::WeightsInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<gen::WeightsInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<gen::WeightsInfo>*)o)->front)();
  else   (((::std::vector<gen::WeightsInfo>*)o)->front)();
}

static  void method_10121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<gen::WeightsInfo>*)o)->front)();
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->front)();
}

static  void method_10122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<gen::WeightsInfo>*)o)->back)();
  else   (((::std::vector<gen::WeightsInfo>*)o)->back)();
}

static  void method_10123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<gen::WeightsInfo>*)o)->back)();
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->back)();
}

static  void method_10124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<gen::WeightsInfo>*)o)->data)());
  else   (((::std::vector<gen::WeightsInfo>*)o)->data)();
}

static  void method_10125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<gen::WeightsInfo>*)o)->data)());
  else   (((const ::std::vector<gen::WeightsInfo>*)o)->data)();
}

static  void method_10126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<gen::WeightsInfo>*)o)->push_back)(*(const ::gen::WeightsInfo*)arg[0]);
}

static  void method_10127( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<gen::WeightsInfo>*)o)->pop_back)();
}

static  void method_10128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >)((((::std::vector<gen::WeightsInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[0],
    *(const ::gen::WeightsInfo*)arg[1]));
  else   (((::std::vector<gen::WeightsInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[0],
    *(const ::gen::WeightsInfo*)arg[1]);
}

static  void method_10129( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<gen::WeightsInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::gen::WeightsInfo*)arg[2]);
}

static  void method_10130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >)((((::std::vector<gen::WeightsInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[0]));
  else   (((::std::vector<gen::WeightsInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[0]);
}

static  void method_10131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >)((((::std::vector<gen::WeightsInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[1]));
  else   (((::std::vector<gen::WeightsInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<gen::WeightsInfo*,std::vector<gen::WeightsInfo> >*)arg[1]);
}

static  void method_10132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<gen::WeightsInfo>*)o)->swap)(*(::std::vector<gen::WeightsInfo>*)arg[0]);
}

static  void method_10133( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<gen::WeightsInfo>*)o)->clear)();
}

static void method_newdel_2801( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<gen::WeightsInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<gen::WeightsInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<gen::WeightsInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<gen::WeightsInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<gen::WeightsInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<gen::WeightsInfo,std::allocator<gen::WeightsInfo> >")), ::Reflex::BaseOffset< ::std::vector<gen::WeightsInfo>,::std::_Vector_base<gen::WeightsInfo,std::allocator<gen::WeightsInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<gen::WeightsInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<gen::WeightsInfo> >::Generate();
}

//------Dictionary for class vector<gen::WeightsInfo,std::allocator<gen::WeightsInfo> > -------------------------------
void __std__vector_gen__WeightsInfo__db_datamem(Reflex::Class*);
void __std__vector_gen__WeightsInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_gen__WeightsInfo__datamem_bld(&__std__vector_gen__WeightsInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_gen__WeightsInfo__funcmem_bld(&__std__vector_gen__WeightsInfo__db_funcmem);
void __std__vector_gen__WeightsInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<gen::WeightsInfo>"), typeid(::std::vector<gen::WeightsInfo>), sizeof(::std::vector<gen::WeightsInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2294, ::Reflex::BaseOffset< ::std::vector<gen::WeightsInfo>, ::std::_Vector_base<gen::WeightsInfo,std::allocator<gen::WeightsInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4248, Reflex::Literal("std::vector<gen::WeightsInfo>::_Alloc_value_type"))
  .AddTypedef(type_2294, Reflex::Literal("std::vector<gen::WeightsInfo>::_Base"))
  .AddTypedef(type_3047, Reflex::Literal("std::vector<gen::WeightsInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5514, Reflex::Literal("std::vector<gen::WeightsInfo>::_Alloc_traits"))
  .AddTypedef(type_4248, Reflex::Literal("std::vector<gen::WeightsInfo>::value_type"))
  .AddTypedef(type_6325, Reflex::Literal("std::vector<gen::WeightsInfo>::pointer"))
  .AddTypedef(type_10081, Reflex::Literal("std::vector<gen::WeightsInfo>::const_pointer"))
  .AddTypedef(type_10083, Reflex::Literal("std::vector<gen::WeightsInfo>::reference"))
  .AddTypedef(type_10085, Reflex::Literal("std::vector<gen::WeightsInfo>::const_reference"))
  .AddTypedef(type_5444, Reflex::Literal("std::vector<gen::WeightsInfo>::iterator"))
  .AddTypedef(type_5445, Reflex::Literal("std::vector<gen::WeightsInfo>::const_iterator"))
  .AddTypedef(type_3211, Reflex::Literal("std::vector<gen::WeightsInfo>::const_reverse_iterator"))
  .AddTypedef(type_3212, Reflex::Literal("std::vector<gen::WeightsInfo>::reverse_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<gen::WeightsInfo>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::vector<gen::WeightsInfo>::difference_type"))
  .AddTypedef(type_3047, Reflex::Literal("std::vector<gen::WeightsInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10094, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23489), Reflex::Literal("vector"), constructor_10095, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3033, type_10085, type_23489), Reflex::Literal("vector"), constructor_10096, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19219), Reflex::Literal("vector"), constructor_10097, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10098, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2801, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_gen__WeightsInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<gen::WeightsInfo,std::allocator<gen::WeightsInfo> > -------------------
void __std__vector_gen__WeightsInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<gen::WeightsInfo,std::allocator<gen::WeightsInfo> > -------------------
void __std__vector_gen__WeightsInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24312, type_19219), Reflex::Literal("operator="), operator_10099, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_10085), Reflex::Literal("assign"), method_10100, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5444), Reflex::Literal("begin"), method_10101, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5445), Reflex::Literal("begin"), method_10102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5444), Reflex::Literal("end"), method_10103, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5445), Reflex::Literal("end"), method_10104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_10109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_10110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_4248), Reflex::Literal("resize"), method_10111, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_10112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_10113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_10114, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10083, type_3033), Reflex::Literal("operator[]"), operator_10115, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10085, type_3033), Reflex::Literal("operator[]"), operator_10116, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10083, type_3033), Reflex::Literal("at"), method_10118, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10085, type_3033), Reflex::Literal("at"), method_10119, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10083), Reflex::Literal("front"), method_10120, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10085), Reflex::Literal("front"), method_10121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10083), Reflex::Literal("back"), method_10122, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10085), Reflex::Literal("back"), method_10123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6325), Reflex::Literal("data"), method_10124, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10081), Reflex::Literal("data"), method_10125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10085), Reflex::Literal("push_back"), method_10126, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("pop_back"), method_10127, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5444, type_5444, type_10085), Reflex::Literal("insert"), method_10128, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_5444, type_3033, type_10085), Reflex::Literal("insert"), method_10129, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5444, type_5444), Reflex::Literal("erase"), method_10130, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5444, type_5444, type_5444), Reflex::Literal("erase"), method_10131, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24312), Reflex::Literal("swap"), method_10132, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_10133, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> > -------------------------------
static void constructor_10225( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const edm::HepMCProduct*>();
  else ::new(mem) ::std::vector<const edm::HepMCProduct*>();
}

static void constructor_10226( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(const ::std::allocator<const edm::HepMCProduct*>*)arg[0]);
  else ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(const ::std::allocator<const edm::HepMCProduct*>*)arg[0]);
}

static void constructor_10227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(::std::size_t*)arg[0],
      *(const ::edm::HepMCProduct* const*)arg[1]);
  else ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(::std::size_t*)arg[0],
      *(const ::edm::HepMCProduct* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(::std::size_t*)arg[0],
      *(const ::edm::HepMCProduct* const*)arg[1],
      *(const ::std::allocator<const edm::HepMCProduct*>*)arg[2]);
  else ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(::std::size_t*)arg[0],
      *(const ::edm::HepMCProduct* const*)arg[1],
      *(const ::std::allocator<const edm::HepMCProduct*>*)arg[2]);
  }
}

static void constructor_10228( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(const ::std::vector<const edm::HepMCProduct*>*)arg[0]);
  else ::new(mem) ::std::vector<const edm::HepMCProduct*>(*(const ::std::vector<const edm::HepMCProduct*>*)arg[0]);
}

static void destructor_10229(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<const edm::HepMCProduct*>*)o)->::std::vector<const edm::HepMCProduct*>::~vector)();
}
static  void operator_10230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const edm::HepMCProduct*>*)o)->operator=)(*(const ::std::vector<const edm::HepMCProduct*>*)arg[0]);
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->operator=)(*(const ::std::vector<const edm::HepMCProduct*>*)arg[0]);
}

static  void method_10231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const edm::HepMCProduct*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::HepMCProduct* const*)arg[1]);
}

static  void method_10232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >)((((::std::vector<const edm::HepMCProduct*>*)o)->begin)());
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->begin)();
}

static  void method_10233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HepMCProduct* const*,std::vector<const edm::HepMCProduct*> >)((((const ::std::vector<const edm::HepMCProduct*>*)o)->begin)());
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->begin)();
}

static  void method_10234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >)((((::std::vector<const edm::HepMCProduct*>*)o)->end)());
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->end)();
}

static  void method_10235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HepMCProduct* const*,std::vector<const edm::HepMCProduct*> >)((((const ::std::vector<const edm::HepMCProduct*>*)o)->end)());
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->end)();
}

static  void method_10240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const edm::HepMCProduct*>*)o)->size)());
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->size)();
}

static  void method_10241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const edm::HepMCProduct*>*)o)->max_size)());
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->max_size)();
}

static  void method_10242( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<const edm::HepMCProduct*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<const edm::HepMCProduct*>*)o)->resize)(*(::std::size_t*)arg[0],
      (const ::edm::HepMCProduct*)arg[1]);
  }
}

static  void method_10243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const edm::HepMCProduct*>*)o)->capacity)());
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->capacity)();
}

static  void method_10244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<const edm::HepMCProduct*>*)o)->empty)());
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->empty)();
}

static  void method_10245( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const edm::HepMCProduct*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const edm::HepMCProduct*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const edm::HepMCProduct*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const edm::HepMCProduct*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const edm::HepMCProduct*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const edm::HepMCProduct*>*)o)->front)();
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->front)();
}

static  void method_10252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const edm::HepMCProduct*>*)o)->front)();
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->front)();
}

static  void method_10253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const edm::HepMCProduct*>*)o)->back)();
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->back)();
}

static  void method_10254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const edm::HepMCProduct*>*)o)->back)();
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->back)();
}

static  void method_10255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<const edm::HepMCProduct*>*)o)->data)());
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->data)();
}

static  void method_10256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<const edm::HepMCProduct*>*)o)->data)());
  else   (((const ::std::vector<const edm::HepMCProduct*>*)o)->data)();
}

static  void method_10257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const edm::HepMCProduct*>*)o)->push_back)(*(const ::edm::HepMCProduct* const*)arg[0]);
}

static  void method_10258( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const edm::HepMCProduct*>*)o)->pop_back)();
}

static  void method_10259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >)((((::std::vector<const edm::HepMCProduct*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[0],
    *(const ::edm::HepMCProduct* const*)arg[1]));
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[0],
    *(const ::edm::HepMCProduct* const*)arg[1]);
}

static  void method_10260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const edm::HepMCProduct*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::HepMCProduct* const*)arg[2]);
}

static  void method_10261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >)((((::std::vector<const edm::HepMCProduct*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[0]));
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[0]);
}

static  void method_10262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >)((((::std::vector<const edm::HepMCProduct*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[1]));
  else   (((::std::vector<const edm::HepMCProduct*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const edm::HepMCProduct**,std::vector<const edm::HepMCProduct*> >*)arg[1]);
}

static  void method_10263( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const edm::HepMCProduct*>*)o)->swap)(*(::std::vector<const edm::HepMCProduct*>*)arg[0]);
}

static  void method_10264( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const edm::HepMCProduct*>*)o)->clear)();
}

static void method_newdel_2803( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<const edm::HepMCProduct*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<const edm::HepMCProduct*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<const edm::HepMCProduct*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<const edm::HepMCProduct*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<const edm::HepMCProduct*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> >")), ::Reflex::BaseOffset< ::std::vector<const edm::HepMCProduct*>,::std::_Vector_base<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<const edm::HepMCProduct*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<const edm::HepMCProduct*> >::Generate();
}

//------Dictionary for class vector<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> > -------------------------------
void __std__vector_constsedm__HepMCProductp__db_datamem(Reflex::Class*);
void __std__vector_constsedm__HepMCProductp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_constsedm__HepMCProductp__datamem_bld(&__std__vector_constsedm__HepMCProductp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_constsedm__HepMCProductp__funcmem_bld(&__std__vector_constsedm__HepMCProductp__db_funcmem);
void __std__vector_constsedm__HepMCProductp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<const edm::HepMCProduct*>"), typeid(::std::vector<const edm::HepMCProduct*>), sizeof(::std::vector<const edm::HepMCProduct*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2286, ::Reflex::BaseOffset< ::std::vector<const edm::HepMCProduct*>, ::std::_Vector_base<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10205, Reflex::Literal("std::vector<const edm::HepMCProduct*>::_Alloc_value_type"))
  .AddTypedef(type_2286, Reflex::Literal("std::vector<const edm::HepMCProduct*>::_Base"))
  .AddTypedef(type_3049, Reflex::Literal("std::vector<const edm::HepMCProduct*>::_Tp_alloc_type"))
  .AddTypedef(type_5506, Reflex::Literal("std::vector<const edm::HepMCProduct*>::_Alloc_traits"))
  .AddTypedef(type_10205, Reflex::Literal("std::vector<const edm::HepMCProduct*>::value_type"))
  .AddTypedef(type_6175, Reflex::Literal("std::vector<const edm::HepMCProduct*>::pointer"))
  .AddTypedef(type_10212, Reflex::Literal("std::vector<const edm::HepMCProduct*>::const_pointer"))
  .AddTypedef(type_10214, Reflex::Literal("std::vector<const edm::HepMCProduct*>::reference"))
  .AddTypedef(type_10216, Reflex::Literal("std::vector<const edm::HepMCProduct*>::const_reference"))
  .AddTypedef(type_5427, Reflex::Literal("std::vector<const edm::HepMCProduct*>::iterator"))
  .AddTypedef(type_5428, Reflex::Literal("std::vector<const edm::HepMCProduct*>::const_iterator"))
  .AddTypedef(type_3187, Reflex::Literal("std::vector<const edm::HepMCProduct*>::const_reverse_iterator"))
  .AddTypedef(type_3188, Reflex::Literal("std::vector<const edm::HepMCProduct*>::reverse_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<const edm::HepMCProduct*>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::vector<const edm::HepMCProduct*>::difference_type"))
  .AddTypedef(type_3049, Reflex::Literal("std::vector<const edm::HepMCProduct*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10225, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23385), Reflex::Literal("vector"), constructor_10226, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3033, type_10216, type_23385), Reflex::Literal("vector"), constructor_10227, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24316), Reflex::Literal("vector"), constructor_10228, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10229, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2803, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_constsedm__HepMCProductp__funcmem_bld);
}

//------Delayed data member builder for class vector<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> > -------------------
void __std__vector_constsedm__HepMCProductp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<const edm::HepMCProduct*,std::allocator<const edm::HepMCProduct*> > -------------------
void __std__vector_constsedm__HepMCProductp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24317, type_24316), Reflex::Literal("operator="), operator_10230, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_10216), Reflex::Literal("assign"), method_10231, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5427), Reflex::Literal("begin"), method_10232, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5428), Reflex::Literal("begin"), method_10233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5427), Reflex::Literal("end"), method_10234, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5428), Reflex::Literal("end"), method_10235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_10240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_10241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_10205), Reflex::Literal("resize"), method_10242, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_10243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_10244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_10245, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10214, type_3033), Reflex::Literal("operator[]"), operator_10246, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10216, type_3033), Reflex::Literal("operator[]"), operator_10247, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10214, type_3033), Reflex::Literal("at"), method_10249, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10216, type_3033), Reflex::Literal("at"), method_10250, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10214), Reflex::Literal("front"), method_10251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10216), Reflex::Literal("front"), method_10252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10214), Reflex::Literal("back"), method_10253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10216), Reflex::Literal("back"), method_10254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6175), Reflex::Literal("data"), method_10255, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10212), Reflex::Literal("data"), method_10256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10216), Reflex::Literal("push_back"), method_10257, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("pop_back"), method_10258, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5427, type_5427, type_10216), Reflex::Literal("insert"), method_10259, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_5427, type_3033, type_10216), Reflex::Literal("insert"), method_10260, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5427, type_5427), Reflex::Literal("erase"), method_10261, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5427, type_5427, type_5427), Reflex::Literal("erase"), method_10262, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24317), Reflex::Literal("swap"), method_10263, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_10264, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> > -------------------------------
static void constructor_10287( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HepMC::GenParticle*>();
  else ::new(mem) ::std::vector<HepMC::GenParticle*>();
}

static void constructor_10288( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HepMC::GenParticle*>(*(const ::std::allocator<HepMC::GenParticle*>*)arg[0]);
  else ::new(mem) ::std::vector<HepMC::GenParticle*>(*(const ::std::allocator<HepMC::GenParticle*>*)arg[0]);
}

static void constructor_10289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HepMC::GenParticle*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HepMC::GenParticle*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HepMC::GenParticle*>(*(::std::size_t*)arg[0],
      *(::HepMC::GenParticle* const*)arg[1]);
  else ::new(mem) ::std::vector<HepMC::GenParticle*>(*(::std::size_t*)arg[0],
      *(::HepMC::GenParticle* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HepMC::GenParticle*>(*(::std::size_t*)arg[0],
      *(::HepMC::GenParticle* const*)arg[1],
      *(const ::std::allocator<HepMC::GenParticle*>*)arg[2]);
  else ::new(mem) ::std::vector<HepMC::GenParticle*>(*(::std::size_t*)arg[0],
      *(::HepMC::GenParticle* const*)arg[1],
      *(const ::std::allocator<HepMC::GenParticle*>*)arg[2]);
  }
}

static void constructor_10290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HepMC::GenParticle*>(*(const ::std::vector<HepMC::GenParticle*>*)arg[0]);
  else ::new(mem) ::std::vector<HepMC::GenParticle*>(*(const ::std::vector<HepMC::GenParticle*>*)arg[0]);
}

static void destructor_10291(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HepMC::GenParticle*>*)o)->::std::vector<HepMC::GenParticle*>::~vector)();
}
static  void operator_10292( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HepMC::GenParticle*>*)o)->operator=)(*(const ::std::vector<HepMC::GenParticle*>*)arg[0]);
  else   (((::std::vector<HepMC::GenParticle*>*)o)->operator=)(*(const ::std::vector<HepMC::GenParticle*>*)arg[0]);
}

static  void method_10293( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HepMC::GenParticle*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::HepMC::GenParticle* const*)arg[1]);
}

static  void method_10294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >)((((::std::vector<HepMC::GenParticle*>*)o)->begin)());
  else   (((::std::vector<HepMC::GenParticle*>*)o)->begin)();
}

static  void method_10295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> >)((((const ::std::vector<HepMC::GenParticle*>*)o)->begin)());
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->begin)();
}

static  void method_10296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >)((((::std::vector<HepMC::GenParticle*>*)o)->end)());
  else   (((::std::vector<HepMC::GenParticle*>*)o)->end)();
}

static  void method_10297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> >)((((const ::std::vector<HepMC::GenParticle*>*)o)->end)());
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->end)();
}

static  void method_10302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HepMC::GenParticle*>*)o)->size)());
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->size)();
}

static  void method_10303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HepMC::GenParticle*>*)o)->max_size)());
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->max_size)();
}

static  void method_10304( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HepMC::GenParticle*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HepMC::GenParticle*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::HepMC::GenParticle*)arg[1]);
  }
}

static  void method_10305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HepMC::GenParticle*>*)o)->capacity)());
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->capacity)();
}

static  void method_10306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HepMC::GenParticle*>*)o)->empty)());
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->empty)();
}

static  void method_10307( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HepMC::GenParticle*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10308( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HepMC::GenParticle*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HepMC::GenParticle*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HepMC::GenParticle*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HepMC::GenParticle*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HepMC::GenParticle*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HepMC::GenParticle*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HepMC::GenParticle*>*)o)->front)();
  else   (((::std::vector<HepMC::GenParticle*>*)o)->front)();
}

static  void method_10314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HepMC::GenParticle*>*)o)->front)();
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->front)();
}

static  void method_10315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HepMC::GenParticle*>*)o)->back)();
  else   (((::std::vector<HepMC::GenParticle*>*)o)->back)();
}

static  void method_10316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HepMC::GenParticle*>*)o)->back)();
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->back)();
}

static  void method_10317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HepMC::GenParticle*>*)o)->data)());
  else   (((::std::vector<HepMC::GenParticle*>*)o)->data)();
}

static  void method_10318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HepMC::GenParticle*>*)o)->data)());
  else   (((const ::std::vector<HepMC::GenParticle*>*)o)->data)();
}

static  void method_10319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HepMC::GenParticle*>*)o)->push_back)(*(::HepMC::GenParticle* const*)arg[0]);
}

static  void method_10320( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HepMC::GenParticle*>*)o)->pop_back)();
}

static  void method_10321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >)((((::std::vector<HepMC::GenParticle*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[0],
    *(::HepMC::GenParticle* const*)arg[1]));
  else   (((::std::vector<HepMC::GenParticle*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[0],
    *(::HepMC::GenParticle* const*)arg[1]);
}

static  void method_10322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HepMC::GenParticle*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::HepMC::GenParticle* const*)arg[2]);
}

static  void method_10323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >)((((::std::vector<HepMC::GenParticle*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[0]));
  else   (((::std::vector<HepMC::GenParticle*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[0]);
}

static  void method_10324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >)((((::std::vector<HepMC::GenParticle*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[1]));
  else   (((::std::vector<HepMC::GenParticle*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HepMC::GenParticle**,std::vector<HepMC::GenParticle*> >*)arg[1]);
}

static  void method_10325( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HepMC::GenParticle*>*)o)->swap)(*(::std::vector<HepMC::GenParticle*>*)arg[0]);
}

static  void method_10326( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HepMC::GenParticle*>*)o)->clear)();
}

static void method_newdel_2804( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HepMC::GenParticle*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HepMC::GenParticle*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HepMC::GenParticle*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HepMC::GenParticle*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HepMC::GenParticle*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> >")), ::Reflex::BaseOffset< ::std::vector<HepMC::GenParticle*>,::std::_Vector_base<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HepMC::GenParticle*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HepMC::GenParticle*> >::Generate();
}

//------Dictionary for class vector<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> > -------------------------------
void __std__vector_HepMC__GenParticlep__db_datamem(Reflex::Class*);
void __std__vector_HepMC__GenParticlep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HepMC__GenParticlep__datamem_bld(&__std__vector_HepMC__GenParticlep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HepMC__GenParticlep__funcmem_bld(&__std__vector_HepMC__GenParticlep__db_funcmem);
void __std__vector_HepMC__GenParticlep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HepMC::GenParticle*>"), typeid(::std::vector<HepMC::GenParticle*>), sizeof(::std::vector<HepMC::GenParticle*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2289, ::Reflex::BaseOffset< ::std::vector<HepMC::GenParticle*>, ::std::_Vector_base<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_6865, Reflex::Literal("std::vector<HepMC::GenParticle*>::_Alloc_value_type"))
  .AddTypedef(type_2289, Reflex::Literal("std::vector<HepMC::GenParticle*>::_Base"))
  .AddTypedef(type_3050, Reflex::Literal("std::vector<HepMC::GenParticle*>::_Tp_alloc_type"))
  .AddTypedef(type_5509, Reflex::Literal("std::vector<HepMC::GenParticle*>::_Alloc_traits"))
  .AddTypedef(type_6865, Reflex::Literal("std::vector<HepMC::GenParticle*>::value_type"))
  .AddTypedef(type_6231, Reflex::Literal("std::vector<HepMC::GenParticle*>::pointer"))
  .AddTypedef(type_6868, Reflex::Literal("std::vector<HepMC::GenParticle*>::const_pointer"))
  .AddTypedef(type_9241, Reflex::Literal("std::vector<HepMC::GenParticle*>::reference"))
  .AddTypedef(type_6870, Reflex::Literal("std::vector<HepMC::GenParticle*>::const_reference"))
  .AddTypedef(type_5434, Reflex::Literal("std::vector<HepMC::GenParticle*>::iterator"))
  .AddTypedef(type_5433, Reflex::Literal("std::vector<HepMC::GenParticle*>::const_iterator"))
  .AddTypedef(type_3199, Reflex::Literal("std::vector<HepMC::GenParticle*>::const_reverse_iterator"))
  .AddTypedef(type_3200, Reflex::Literal("std::vector<HepMC::GenParticle*>::reverse_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<HepMC::GenParticle*>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::vector<HepMC::GenParticle*>::difference_type"))
  .AddTypedef(type_3050, Reflex::Literal("std::vector<HepMC::GenParticle*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10287, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23424), Reflex::Literal("vector"), constructor_10288, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3033, type_6870, type_23424), Reflex::Literal("vector"), constructor_10289, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24318), Reflex::Literal("vector"), constructor_10290, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10291, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2804, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HepMC__GenParticlep__funcmem_bld);
}

//------Delayed data member builder for class vector<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> > -------------------
void __std__vector_HepMC__GenParticlep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HepMC::GenParticle*,std::allocator<HepMC::GenParticle*> > -------------------
void __std__vector_HepMC__GenParticlep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24319, type_24318), Reflex::Literal("operator="), operator_10292, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_6870), Reflex::Literal("assign"), method_10293, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434), Reflex::Literal("begin"), method_10294, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5433), Reflex::Literal("begin"), method_10295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434), Reflex::Literal("end"), method_10296, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5433), Reflex::Literal("end"), method_10297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_10302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_10303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_6865), Reflex::Literal("resize"), method_10304, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_10305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_10306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_10307, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9241, type_3033), Reflex::Literal("operator[]"), operator_10308, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6870, type_3033), Reflex::Literal("operator[]"), operator_10309, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9241, type_3033), Reflex::Literal("at"), method_10311, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6870, type_3033), Reflex::Literal("at"), method_10312, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9241), Reflex::Literal("front"), method_10313, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6870), Reflex::Literal("front"), method_10314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9241), Reflex::Literal("back"), method_10315, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6870), Reflex::Literal("back"), method_10316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231), Reflex::Literal("data"), method_10317, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6868), Reflex::Literal("data"), method_10318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6870), Reflex::Literal("push_back"), method_10319, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("pop_back"), method_10320, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434, type_5434, type_6870), Reflex::Literal("insert"), method_10321, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_5434, type_3033, type_6870), Reflex::Literal("insert"), method_10322, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434, type_5434), Reflex::Literal("erase"), method_10323, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434, type_5434, type_5434), Reflex::Literal("erase"), method_10324, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24319), Reflex::Literal("swap"), method_10325, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_10326, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class ProcessInfo -------------------------------
static void destructor_22347(void*, void * o, const std::vector<void*>&, void *) {
(((::GenLumiInfoProduct::ProcessInfo*)o)->::GenLumiInfoProduct::ProcessInfo::~ProcessInfo)();
}
static  void operator_22348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenLumiInfoProduct::ProcessInfo*)o)->operator=)(*(const ::GenLumiInfoProduct::ProcessInfo*)arg[0]);
  else   (((::GenLumiInfoProduct::ProcessInfo*)o)->operator=)(*(const ::GenLumiInfoProduct::ProcessInfo*)arg[0]);
}

static void constructor_22349( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::ProcessInfo(*(const ::GenLumiInfoProduct::ProcessInfo*)arg[0]);
  else ::new(mem) ::GenLumiInfoProduct::ProcessInfo(*(const ::GenLumiInfoProduct::ProcessInfo*)arg[0]);
}

static void constructor_22350( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::ProcessInfo();
  else ::new(mem) ::GenLumiInfoProduct::ProcessInfo();
}

static void constructor_22351( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::ProcessInfo(*(int*)arg[0]);
  else ::new(mem) ::GenLumiInfoProduct::ProcessInfo(*(int*)arg[0]);
}

static  void method_22352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->process)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->process)();
}

static  void method_22353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GenLumiInfoProduct::XSec)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->lheXSec)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->lheXSec)();
}

static  void method_22354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->nPassPos)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->nPassPos)();
}

static  void method_22355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->nPassNeg)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->nPassNeg)();
}

static  void method_22356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->nTotalPos)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->nTotalPos)();
}

static  void method_22357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->nTotalNeg)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->nTotalNeg)();
}

static  void method_22358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GenLumiInfoProduct::FinalStat)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->tried)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->tried)();
}

static  void method_22359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GenLumiInfoProduct::FinalStat)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->selected)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->selected)();
}

static  void method_22360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GenLumiInfoProduct::FinalStat)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->killed)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->killed)();
}

static  void method_22361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GenLumiInfoProduct::FinalStat)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->accepted)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->accepted)();
}

static  void method_22362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GenLumiInfoProduct::FinalStat)((((const ::GenLumiInfoProduct::ProcessInfo*)o)->acceptedBr)());
  else   (((const ::GenLumiInfoProduct::ProcessInfo*)o)->acceptedBr)();
}

static  void method_22363( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->addOthers)(*(const ::GenLumiInfoProduct::ProcessInfo*)arg[0]);
}

static  void method_22364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setProcess)(*(int*)arg[0]);
}

static  void method_22365( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setLheXSec)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_22366( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setNPassPos)(*(unsigned int*)arg[0]);
}

static  void method_22367( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setNPassNeg)(*(unsigned int*)arg[0]);
}

static  void method_22368( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setNTotalPos)(*(unsigned int*)arg[0]);
}

static  void method_22369( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setNTotalNeg)(*(unsigned int*)arg[0]);
}

static  void method_22370( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setTried)(*(unsigned int*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_22371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setSelected)(*(unsigned int*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_22372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setKilled)(*(unsigned int*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_22373( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setAccepted)(*(unsigned int*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_22374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::ProcessInfo*)o)->setAcceptedBr)(*(unsigned int*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static void method_newdel_5600( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::ProcessInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::ProcessInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::ProcessInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::ProcessInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::ProcessInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ProcessInfo -------------------------------
void __GenLumiInfoProduct__ProcessInfo_db_datamem(Reflex::Class*);
void __GenLumiInfoProduct__ProcessInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct__ProcessInfo_datamem_bld(&__GenLumiInfoProduct__ProcessInfo_db_datamem);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct__ProcessInfo_funcmem_bld(&__GenLumiInfoProduct__ProcessInfo_db_funcmem);
void __GenLumiInfoProduct__ProcessInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenLumiInfoProduct::ProcessInfo"), typeid(::GenLumiInfoProduct::ProcessInfo), sizeof(::GenLumiInfoProduct::ProcessInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ProcessInfo"), destructor_22347, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10341, type_10343), Reflex::Literal("operator="), operator_22348, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10343), Reflex::Literal("ProcessInfo"), constructor_22349, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ProcessInfo"), constructor_22350, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_67), Reflex::Literal("ProcessInfo"), constructor_22351, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5600, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenLumiInfoProduct__ProcessInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenLumiInfoProduct__ProcessInfo_funcmem_bld);
}

//------Delayed data member builder for class ProcessInfo -------------------
void __GenLumiInfoProduct__ProcessInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67, Reflex::Literal("process_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, process_), ::Reflex::PRIVATE)
  .AddDataMember(type_5599, Reflex::Literal("lheXSec_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, lheXSec_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("nPassPos_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, nPassPos_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("nPassNeg_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, nPassNeg_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("nTotalPos_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, nTotalPos_), ::Reflex::PRIVATE)
  .AddDataMember(type_198, Reflex::Literal("nTotalNeg_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, nTotalNeg_), ::Reflex::PRIVATE)
  .AddDataMember(type_5601, Reflex::Literal("tried_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, tried_), ::Reflex::PRIVATE)
  .AddDataMember(type_5601, Reflex::Literal("selected_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, selected_), ::Reflex::PRIVATE)
  .AddDataMember(type_5601, Reflex::Literal("killed_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, killed_), ::Reflex::PRIVATE)
  .AddDataMember(type_5601, Reflex::Literal("accepted_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, accepted_), ::Reflex::PRIVATE)
  .AddDataMember(type_5601, Reflex::Literal("acceptedBr_"), OffsetOf(__shadow__::__GenLumiInfoProduct__ProcessInfo, acceptedBr_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ProcessInfo -------------------
void __GenLumiInfoProduct__ProcessInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("process"), method_22352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5599), Reflex::Literal("lheXSec"), method_22353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("nPassPos"), method_22354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("nPassNeg"), method_22355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("nTotalPos"), method_22356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("nTotalNeg"), method_22357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5601), Reflex::Literal("tried"), method_22358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5601), Reflex::Literal("selected"), method_22359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5601), Reflex::Literal("killed"), method_22360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5601), Reflex::Literal("accepted"), method_22361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5601), Reflex::Literal("acceptedBr"), method_22362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10343), Reflex::Literal("addOthers"), method_22363, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("setProcess"), method_22364, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102, type_102), Reflex::Literal("setLheXSec"), method_22365, 0, "value;err", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198), Reflex::Literal("setNPassPos"), method_22366, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198), Reflex::Literal("setNPassNeg"), method_22367, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198), Reflex::Literal("setNTotalPos"), method_22368, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198), Reflex::Literal("setNTotalNeg"), method_22369, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198, type_102, type_102), Reflex::Literal("setTried"), method_22370, 0, "n;sum;sum2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198, type_102, type_102), Reflex::Literal("setSelected"), method_22371, 0, "n;sum;sum2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198, type_102, type_102), Reflex::Literal("setKilled"), method_22372, 0, "n;sum;sum2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198, type_102, type_102), Reflex::Literal("setAccepted"), method_22373, 0, "n;sum;sum2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_198, type_102, type_102), Reflex::Literal("setAcceptedBr"), method_22374, 0, "n;sum;sum2", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> > -------------------------------
static void constructor_10352( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>();
  else ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>();
}

static void constructor_10353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(const ::std::allocator<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
  else ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(const ::std::allocator<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
}

static void constructor_10354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(::std::size_t*)arg[0],
      *(const ::GenLumiInfoProduct::ProcessInfo*)arg[1]);
  else ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(::std::size_t*)arg[0],
      *(const ::GenLumiInfoProduct::ProcessInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(::std::size_t*)arg[0],
      *(const ::GenLumiInfoProduct::ProcessInfo*)arg[1],
      *(const ::std::allocator<GenLumiInfoProduct::ProcessInfo>*)arg[2]);
  else ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(::std::size_t*)arg[0],
      *(const ::GenLumiInfoProduct::ProcessInfo*)arg[1],
      *(const ::std::allocator<GenLumiInfoProduct::ProcessInfo>*)arg[2]);
  }
}

static void constructor_10355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
  else ::new(mem) ::std::vector<GenLumiInfoProduct::ProcessInfo>(*(const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
}

static void destructor_10356(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->::std::vector<GenLumiInfoProduct::ProcessInfo>::~vector)();
}
static  void operator_10357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->operator=)(*(const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->operator=)(*(const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
}

static  void method_10358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::GenLumiInfoProduct::ProcessInfo*)arg[1]);
}

static  void method_10359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >)((((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->begin)());
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->begin)();
}

static  void method_10360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >)((((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->begin)());
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->begin)();
}

static  void method_10361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >)((((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->end)());
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->end)();
}

static  void method_10362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >)((((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->end)());
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->end)();
}

static  void method_10367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->size)());
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->size)();
}

static  void method_10368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->max_size)());
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->max_size)();
}

static  void method_10369( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::GenLumiInfoProduct::ProcessInfo*)arg[1]);
  }
}

static  void method_10370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->capacity)());
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->capacity)();
}

static  void method_10371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->empty)());
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->empty)();
}

static  void method_10372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->front)();
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->front)();
}

static  void method_10379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->front)();
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->front)();
}

static  void method_10380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->back)();
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->back)();
}

static  void method_10381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->back)();
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->back)();
}

static  void method_10382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->data)());
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->data)();
}

static  void method_10383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->data)());
  else   (((const ::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->data)();
}

static  void method_10384( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->push_back)(*(const ::GenLumiInfoProduct::ProcessInfo*)arg[0]);
}

static  void method_10385( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->pop_back)();
}

static  void method_10386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >)((((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[0],
    *(const ::GenLumiInfoProduct::ProcessInfo*)arg[1]));
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[0],
    *(const ::GenLumiInfoProduct::ProcessInfo*)arg[1]);
}

static  void method_10387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::GenLumiInfoProduct::ProcessInfo*)arg[2]);
}

static  void method_10388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >)((((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[0]));
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[0]);
}

static  void method_10389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >)((((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[1]));
  else   (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenLumiInfoProduct::ProcessInfo*,std::vector<GenLumiInfoProduct::ProcessInfo> >*)arg[1]);
}

static  void method_10390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->swap)(*(::std::vector<GenLumiInfoProduct::ProcessInfo>*)arg[0]);
}

static  void method_10391( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenLumiInfoProduct::ProcessInfo>*)o)->clear)();
}

static void method_newdel_2805( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<GenLumiInfoProduct::ProcessInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<GenLumiInfoProduct::ProcessInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<GenLumiInfoProduct::ProcessInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<GenLumiInfoProduct::ProcessInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<GenLumiInfoProduct::ProcessInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> >")), ::Reflex::BaseOffset< ::std::vector<GenLumiInfoProduct::ProcessInfo>,::std::_Vector_base<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<GenLumiInfoProduct::ProcessInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<GenLumiInfoProduct::ProcessInfo> >::Generate();
}

//------Dictionary for class vector<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> > -------------------------------
void __std__vector_GenLumiInfoProduct__ProcessInfo__db_datamem(Reflex::Class*);
void __std__vector_GenLumiInfoProduct__ProcessInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_GenLumiInfoProduct__ProcessInfo__datamem_bld(&__std__vector_GenLumiInfoProduct__ProcessInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_GenLumiInfoProduct__ProcessInfo__funcmem_bld(&__std__vector_GenLumiInfoProduct__ProcessInfo__db_funcmem);
void __std__vector_GenLumiInfoProduct__ProcessInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>"), typeid(::std::vector<GenLumiInfoProduct::ProcessInfo>), sizeof(::std::vector<GenLumiInfoProduct::ProcessInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2287, ::Reflex::BaseOffset< ::std::vector<GenLumiInfoProduct::ProcessInfo>, ::std::_Vector_base<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5600, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::_Alloc_value_type"))
  .AddTypedef(type_2287, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::_Base"))
  .AddTypedef(type_3054, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5507, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::_Alloc_traits"))
  .AddTypedef(type_5600, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::value_type"))
  .AddTypedef(type_6194, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::pointer"))
  .AddTypedef(type_10339, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::const_pointer"))
  .AddTypedef(type_10341, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::reference"))
  .AddTypedef(type_10343, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::const_reference"))
  .AddTypedef(type_5429, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::iterator"))
  .AddTypedef(type_5430, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::const_iterator"))
  .AddTypedef(type_3191, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::const_reverse_iterator"))
  .AddTypedef(type_3192, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::reverse_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::difference_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::vector<GenLumiInfoProduct::ProcessInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10352, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23398), Reflex::Literal("vector"), constructor_10353, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3033, type_10343, type_23398), Reflex::Literal("vector"), constructor_10354, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22391), Reflex::Literal("vector"), constructor_10355, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10356, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2805, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_GenLumiInfoProduct__ProcessInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> > -------------------
void __std__vector_GenLumiInfoProduct__ProcessInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<GenLumiInfoProduct::ProcessInfo,std::allocator<GenLumiInfoProduct::ProcessInfo> > -------------------
void __std__vector_GenLumiInfoProduct__ProcessInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24321, type_22391), Reflex::Literal("operator="), operator_10357, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_10343), Reflex::Literal("assign"), method_10358, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5429), Reflex::Literal("begin"), method_10359, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5430), Reflex::Literal("begin"), method_10360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5429), Reflex::Literal("end"), method_10361, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5430), Reflex::Literal("end"), method_10362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_10367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_10368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_5600), Reflex::Literal("resize"), method_10369, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_10370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_10371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_10372, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10341, type_3033), Reflex::Literal("operator[]"), operator_10373, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10343, type_3033), Reflex::Literal("operator[]"), operator_10374, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10341, type_3033), Reflex::Literal("at"), method_10376, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10343, type_3033), Reflex::Literal("at"), method_10377, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10341), Reflex::Literal("front"), method_10378, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10343), Reflex::Literal("front"), method_10379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10341), Reflex::Literal("back"), method_10380, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10343), Reflex::Literal("back"), method_10381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6194), Reflex::Literal("data"), method_10382, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10339), Reflex::Literal("data"), method_10383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10343), Reflex::Literal("push_back"), method_10384, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("pop_back"), method_10385, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5429, type_5429, type_10343), Reflex::Literal("insert"), method_10386, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_5429, type_3033, type_10343), Reflex::Literal("insert"), method_10387, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5429, type_5429), Reflex::Literal("erase"), method_10388, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5429, type_5429, type_5429), Reflex::Literal("erase"), method_10389, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24321), Reflex::Literal("swap"), method_10390, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_10391, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Header -------------------------------
static  void operator_19695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LHERunInfoProduct::Header*)o)->operator=)(*(const ::LHERunInfoProduct::Header*)arg[0]);
  else   (((::LHERunInfoProduct::Header*)o)->operator=)(*(const ::LHERunInfoProduct::Header*)arg[0]);
}

static void constructor_19696( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHERunInfoProduct::Header(*(const ::LHERunInfoProduct::Header*)arg[0]);
  else ::new(mem) ::LHERunInfoProduct::Header(*(const ::LHERunInfoProduct::Header*)arg[0]);
}

static void constructor_19697( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHERunInfoProduct::Header();
  else ::new(mem) ::LHERunInfoProduct::Header();
}

static void constructor_19698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LHERunInfoProduct::Header(*(const ::std::string*)arg[0]);
  else ::new(mem) ::LHERunInfoProduct::Header(*(const ::std::string*)arg[0]);
}

static void destructor_19699(void*, void * o, const std::vector<void*>&, void *) {
(((::LHERunInfoProduct::Header*)o)->::LHERunInfoProduct::Header::~Header)();
}
static  void method_19700( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LHERunInfoProduct::Header*)o)->addLine)(*(const ::std::string*)arg[0]);
}

static  void method_19701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::LHERunInfoProduct::Header*)o)->tag)();
  else   (((const ::LHERunInfoProduct::Header*)o)->tag)();
}

static  void method_19702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::LHERunInfoProduct::Header*)o)->size)());
  else   (((const ::LHERunInfoProduct::Header*)o)->size)();
}

static  void method_19703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::LHERunInfoProduct::Header*)o)->begin)());
  else   (((const ::LHERunInfoProduct::Header*)o)->begin)();
}

static  void method_19704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::LHERunInfoProduct::Header*)o)->end)());
  else   (((const ::LHERunInfoProduct::Header*)o)->end)();
}

static  void operator_19705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::LHERunInfoProduct::Header*)o)->operator==)(*(const ::LHERunInfoProduct::Header*)arg[0]));
  else   (((const ::LHERunInfoProduct::Header*)o)->operator==)(*(const ::LHERunInfoProduct::Header*)arg[0]);
}

static  void operator_19706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::LHERunInfoProduct::Header*)o)->operator!=)(*(const ::LHERunInfoProduct::Header*)arg[0]));
  else   (((const ::LHERunInfoProduct::Header*)o)->operator!=)(*(const ::LHERunInfoProduct::Header*)arg[0]);
}

static void method_newdel_4660( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct::Header >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct::Header >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct::Header >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct::Header >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LHERunInfoProduct::Header >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Header -------------------------------
void __LHERunInfoProduct__Header_db_datamem(Reflex::Class*);
void __LHERunInfoProduct__Header_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LHERunInfoProduct__Header_datamem_bld(&__LHERunInfoProduct__Header_db_datamem);
Reflex::GenreflexMemberBuilder __LHERunInfoProduct__Header_funcmem_bld(&__LHERunInfoProduct__Header_db_funcmem);
void __LHERunInfoProduct__Header_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LHERunInfoProduct::Header"), typeid(::LHERunInfoProduct::Header), sizeof(::LHERunInfoProduct::Header), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_4250, Reflex::Literal("LHERunInfoProduct::Header::const_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("LHERunInfoProduct::Header::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10790, type_6902), Reflex::Literal("operator="), operator_19695, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6902), Reflex::Literal("Header"), constructor_19696, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Header"), constructor_19697, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12177), Reflex::Literal("Header"), constructor_19698, 0, "tag", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Header"), destructor_19699, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4660, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LHERunInfoProduct__Header_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LHERunInfoProduct__Header_funcmem_bld);
}

//------Delayed data member builder for class Header -------------------
void __LHERunInfoProduct__Header_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2320, Reflex::Literal("tag_"), OffsetOf(__shadow__::__LHERunInfoProduct__Header, tag_), ::Reflex::PRIVATE)
  .AddDataMember(type_2811, Reflex::Literal("lines_"), OffsetOf(__shadow__::__LHERunInfoProduct__Header, lines_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Header -------------------
void __LHERunInfoProduct__Header_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_12177), Reflex::Literal("addLine"), method_19700, 0, "line", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12177), Reflex::Literal("tag"), method_19701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_19702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4250), Reflex::Literal("begin"), method_19703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4250), Reflex::Literal("end"), method_19704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_6902), Reflex::Literal("operator=="), operator_19705, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_6902), Reflex::Literal("operator!="), operator_19706, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vector<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> > -------------------------------
static void constructor_10800( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHERunInfoProduct::Header>();
  else ::new(mem) ::std::vector<LHERunInfoProduct::Header>();
}

static void constructor_10801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(const ::std::allocator<LHERunInfoProduct::Header>*)arg[0]);
  else ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(const ::std::allocator<LHERunInfoProduct::Header>*)arg[0]);
}

static void constructor_10802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(::std::size_t*)arg[0],
      *(const ::LHERunInfoProduct::Header*)arg[1]);
  else ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(::std::size_t*)arg[0],
      *(const ::LHERunInfoProduct::Header*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(::std::size_t*)arg[0],
      *(const ::LHERunInfoProduct::Header*)arg[1],
      *(const ::std::allocator<LHERunInfoProduct::Header>*)arg[2]);
  else ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(::std::size_t*)arg[0],
      *(const ::LHERunInfoProduct::Header*)arg[1],
      *(const ::std::allocator<LHERunInfoProduct::Header>*)arg[2]);
  }
}

static void constructor_10803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(const ::std::vector<LHERunInfoProduct::Header>*)arg[0]);
  else ::new(mem) ::std::vector<LHERunInfoProduct::Header>(*(const ::std::vector<LHERunInfoProduct::Header>*)arg[0]);
}

static void destructor_10804(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<LHERunInfoProduct::Header>*)o)->::std::vector<LHERunInfoProduct::Header>::~vector)();
}
static  void operator_10805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHERunInfoProduct::Header>*)o)->operator=)(*(const ::std::vector<LHERunInfoProduct::Header>*)arg[0]);
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->operator=)(*(const ::std::vector<LHERunInfoProduct::Header>*)arg[0]);
}

static  void method_10806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHERunInfoProduct::Header>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::LHERunInfoProduct::Header*)arg[1]);
}

static  void method_10807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((::std::vector<LHERunInfoProduct::Header>*)o)->begin)());
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->begin)();
}

static  void method_10808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((const ::std::vector<LHERunInfoProduct::Header>*)o)->begin)());
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->begin)();
}

static  void method_10809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((::std::vector<LHERunInfoProduct::Header>*)o)->end)());
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->end)();
}

static  void method_10810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((const ::std::vector<LHERunInfoProduct::Header>*)o)->end)());
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->end)();
}

static  void method_10815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<LHERunInfoProduct::Header>*)o)->size)());
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->size)();
}

static  void method_10816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<LHERunInfoProduct::Header>*)o)->max_size)());
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->max_size)();
}

static  void method_10817( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<LHERunInfoProduct::Header>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<LHERunInfoProduct::Header>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::LHERunInfoProduct::Header*)arg[1]);
  }
}

static  void method_10818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<LHERunInfoProduct::Header>*)o)->capacity)());
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->capacity)();
}

static  void method_10819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<LHERunInfoProduct::Header>*)o)->empty)());
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->empty)();
}

static  void method_10820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHERunInfoProduct::Header>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHERunInfoProduct::Header>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHERunInfoProduct::Header>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHERunInfoProduct::Header>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHERunInfoProduct::Header>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHERunInfoProduct::Header>*)o)->front)();
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->front)();
}

static  void method_10827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHERunInfoProduct::Header>*)o)->front)();
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->front)();
}

static  void method_10828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<LHERunInfoProduct::Header>*)o)->back)();
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->back)();
}

static  void method_10829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<LHERunInfoProduct::Header>*)o)->back)();
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->back)();
}

static  void method_10830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<LHERunInfoProduct::Header>*)o)->data)());
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->data)();
}

static  void method_10831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<LHERunInfoProduct::Header>*)o)->data)());
  else   (((const ::std::vector<LHERunInfoProduct::Header>*)o)->data)();
}

static  void method_10832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHERunInfoProduct::Header>*)o)->push_back)(*(const ::LHERunInfoProduct::Header*)arg[0]);
}

static  void method_10833( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<LHERunInfoProduct::Header>*)o)->pop_back)();
}

static  void method_10834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((::std::vector<LHERunInfoProduct::Header>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[0],
    *(const ::LHERunInfoProduct::Header*)arg[1]));
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[0],
    *(const ::LHERunInfoProduct::Header*)arg[1]);
}

static  void method_10835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHERunInfoProduct::Header>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::LHERunInfoProduct::Header*)arg[2]);
}

static  void method_10836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((::std::vector<LHERunInfoProduct::Header>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[0]));
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[0]);
}

static  void method_10837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >)((((::std::vector<LHERunInfoProduct::Header>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[1]));
  else   (((::std::vector<LHERunInfoProduct::Header>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<LHERunInfoProduct::Header*,std::vector<LHERunInfoProduct::Header> >*)arg[1]);
}

static  void method_10838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<LHERunInfoProduct::Header>*)o)->swap)(*(::std::vector<LHERunInfoProduct::Header>*)arg[0]);
}

static  void method_10839( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<LHERunInfoProduct::Header>*)o)->clear)();
}

static void method_newdel_2812( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<LHERunInfoProduct::Header> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<LHERunInfoProduct::Header> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<LHERunInfoProduct::Header> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<LHERunInfoProduct::Header> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<LHERunInfoProduct::Header> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> >")), ::Reflex::BaseOffset< ::std::vector<LHERunInfoProduct::Header>,::std::_Vector_base<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<LHERunInfoProduct::Header> >::Generate();
  else ::Reflex::Proxy< ::std::vector<LHERunInfoProduct::Header> >::Generate();
}

//------Dictionary for class vector<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> > -------------------------------
void __std__vector_LHERunInfoProduct__Header__db_datamem(Reflex::Class*);
void __std__vector_LHERunInfoProduct__Header__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_LHERunInfoProduct__Header__datamem_bld(&__std__vector_LHERunInfoProduct__Header__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_LHERunInfoProduct__Header__funcmem_bld(&__std__vector_LHERunInfoProduct__Header__db_funcmem);
void __std__vector_LHERunInfoProduct__Header__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<LHERunInfoProduct::Header>"), typeid(::std::vector<LHERunInfoProduct::Header>), sizeof(::std::vector<LHERunInfoProduct::Header>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2292, ::Reflex::BaseOffset< ::std::vector<LHERunInfoProduct::Header>, ::std::_Vector_base<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4660, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::_Alloc_value_type"))
  .AddTypedef(type_2292, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::_Base"))
  .AddTypedef(type_3067, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::_Tp_alloc_type"))
  .AddTypedef(type_5512, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::_Alloc_traits"))
  .AddTypedef(type_4660, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::value_type"))
  .AddTypedef(type_6288, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::pointer"))
  .AddTypedef(type_6900, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::const_pointer"))
  .AddTypedef(type_10790, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::reference"))
  .AddTypedef(type_6902, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::const_reference"))
  .AddTypedef(type_5441, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::iterator"))
  .AddTypedef(type_4662, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::const_iterator"))
  .AddTypedef(type_3207, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::const_reverse_iterator"))
  .AddTypedef(type_3208, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::reverse_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::difference_type"))
  .AddTypedef(type_3067, Reflex::Literal("std::vector<LHERunInfoProduct::Header>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10800, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23463), Reflex::Literal("vector"), constructor_10801, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3033, type_6902, type_23463), Reflex::Literal("vector"), constructor_10802, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9220), Reflex::Literal("vector"), constructor_10803, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10804, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2812, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_LHERunInfoProduct__Header__funcmem_bld);
}

//------Delayed data member builder for class vector<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> > -------------------
void __std__vector_LHERunInfoProduct__Header__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<LHERunInfoProduct::Header,std::allocator<LHERunInfoProduct::Header> > -------------------
void __std__vector_LHERunInfoProduct__Header__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24335, type_9220), Reflex::Literal("operator="), operator_10805, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_6902), Reflex::Literal("assign"), method_10806, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441), Reflex::Literal("begin"), method_10807, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662), Reflex::Literal("begin"), method_10808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441), Reflex::Literal("end"), method_10809, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662), Reflex::Literal("end"), method_10810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_10815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_10816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_4660), Reflex::Literal("resize"), method_10817, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_10818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_10819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_10820, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10790, type_3033), Reflex::Literal("operator[]"), operator_10821, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6902, type_3033), Reflex::Literal("operator[]"), operator_10822, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10790, type_3033), Reflex::Literal("at"), method_10824, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6902, type_3033), Reflex::Literal("at"), method_10825, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10790), Reflex::Literal("front"), method_10826, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6902), Reflex::Literal("front"), method_10827, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10790), Reflex::Literal("back"), method_10828, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6902), Reflex::Literal("back"), method_10829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6288), Reflex::Literal("data"), method_10830, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6900), Reflex::Literal("data"), method_10831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6902), Reflex::Literal("push_back"), method_10832, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("pop_back"), method_10833, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441, type_5441, type_6902), Reflex::Literal("insert"), method_10834, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_5441, type_3033, type_6902), Reflex::Literal("insert"), method_10835, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441, type_5441), Reflex::Literal("erase"), method_10836, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441, type_5441, type_5441), Reflex::Literal("erase"), method_10837, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24335), Reflex::Literal("swap"), method_10838, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_10839, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class HEPEUP -------------------------------
static void destructor_19778(void*, void * o, const std::vector<void*>&, void *) {
(((::lhef::HEPEUP*)o)->::lhef::HEPEUP::~HEPEUP)();
}
static  void operator_19779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::lhef::HEPEUP*)o)->operator=)(*(const ::lhef::HEPEUP*)arg[0]);
  else   (((::lhef::HEPEUP*)o)->operator=)(*(const ::lhef::HEPEUP*)arg[0]);
}

static void constructor_19780( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lhef::HEPEUP(*(const ::lhef::HEPEUP*)arg[0]);
  else ::new(mem) ::lhef::HEPEUP(*(const ::lhef::HEPEUP*)arg[0]);
}

static void constructor_19781( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lhef::HEPEUP();
  else ::new(mem) ::lhef::HEPEUP();
}

static  void method_19782( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::lhef::HEPEUP*)o)->resize)(*(int*)arg[0]);
}

static  void method_19783( void*, void* o, const std::vector<void*>&, void*)
{
  (((::lhef::HEPEUP*)o)->resize)();
}

static void method_newdel_4728( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HEPEUP -------------------------------
void __lhef__HEPEUP_db_datamem(Reflex::Class*);
void __lhef__HEPEUP_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __lhef__HEPEUP_datamem_bld(&__lhef__HEPEUP_db_datamem);
Reflex::GenreflexMemberBuilder __lhef__HEPEUP_funcmem_bld(&__lhef__HEPEUP_db_funcmem);
void __lhef__HEPEUP_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("lhef::HEPEUP"), typeid(::lhef::HEPEUP), sizeof(::lhef::HEPEUP), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HEPEUP"), destructor_19778, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29107, type_19217), Reflex::Literal("operator="), operator_19779, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19217), Reflex::Literal("HEPEUP"), constructor_19780, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HEPEUP"), constructor_19781, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4728, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__lhef__HEPEUP_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__lhef__HEPEUP_funcmem_bld);
}

//------Delayed data member builder for class HEPEUP -------------------
void __lhef__HEPEUP_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67, Reflex::Literal("NUP"), OffsetOf(__shadow__::__lhef__HEPEUP, NUP), ::Reflex::PUBLIC)
  .AddDataMember(type_67, Reflex::Literal("IDPRUP"), OffsetOf(__shadow__::__lhef__HEPEUP, IDPRUP), ::Reflex::PUBLIC)
  .AddDataMember(type_102, Reflex::Literal("XWGTUP"), OffsetOf(__shadow__::__lhef__HEPEUP, XWGTUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2768, Reflex::Literal("XPDWUP"), OffsetOf(__shadow__::__lhef__HEPEUP, XPDWUP), ::Reflex::PUBLIC)
  .AddDataMember(type_102, Reflex::Literal("SCALUP"), OffsetOf(__shadow__::__lhef__HEPEUP, SCALUP), ::Reflex::PUBLIC)
  .AddDataMember(type_102, Reflex::Literal("AQEDUP"), OffsetOf(__shadow__::__lhef__HEPEUP, AQEDUP), ::Reflex::PUBLIC)
  .AddDataMember(type_102, Reflex::Literal("AQCDUP"), OffsetOf(__shadow__::__lhef__HEPEUP, AQCDUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2802, Reflex::Literal("IDUP"), OffsetOf(__shadow__::__lhef__HEPEUP, IDUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2802, Reflex::Literal("ISTUP"), OffsetOf(__shadow__::__lhef__HEPEUP, ISTUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2815, Reflex::Literal("MOTHUP"), OffsetOf(__shadow__::__lhef__HEPEUP, MOTHUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2815, Reflex::Literal("ICOLUP"), OffsetOf(__shadow__::__lhef__HEPEUP, ICOLUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2814, Reflex::Literal("PUP"), OffsetOf(__shadow__::__lhef__HEPEUP, PUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2807, Reflex::Literal("VTIMUP"), OffsetOf(__shadow__::__lhef__HEPEUP, VTIMUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2807, Reflex::Literal("SPINUP"), OffsetOf(__shadow__::__lhef__HEPEUP, SPINUP), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class HEPEUP -------------------
void __lhef__HEPEUP_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("resize"), method_19782, 0, "nup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("resize"), method_19783, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class FiveVector -------------------------------
static void destructor_24337(void*, void * o, const std::vector<void*>&, void *) {
(((::lhef::HEPEUP::FiveVector*)o)->::lhef::HEPEUP::FiveVector::~FiveVector)();
}
static  void operator_24338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::lhef::HEPEUP::FiveVector*)o)->operator=)(*(const ::lhef::HEPEUP::FiveVector*)arg[0]);
  else   (((::lhef::HEPEUP::FiveVector*)o)->operator=)(*(const ::lhef::HEPEUP::FiveVector*)arg[0]);
}

static void constructor_24339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lhef::HEPEUP::FiveVector(*(const ::lhef::HEPEUP::FiveVector*)arg[0]);
  else ::new(mem) ::lhef::HEPEUP::FiveVector(*(const ::lhef::HEPEUP::FiveVector*)arg[0]);
}

static void constructor_24340( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lhef::HEPEUP::FiveVector();
  else ::new(mem) ::lhef::HEPEUP::FiveVector();
}

static  void operator_24341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::lhef::HEPEUP::FiveVector*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::lhef::HEPEUP::FiveVector*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_24342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::lhef::HEPEUP::FiveVector*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::lhef::HEPEUP::FiveVector*)o)->operator[])(*(unsigned int*)arg[0]);
}

static void method_newdel_10846( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP::FiveVector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP::FiveVector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP::FiveVector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP::FiveVector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::lhef::HEPEUP::FiveVector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FiveVector -------------------------------
void __lhef__HEPEUP__FiveVector_db_datamem(Reflex::Class*);
void __lhef__HEPEUP__FiveVector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __lhef__HEPEUP__FiveVector_datamem_bld(&__lhef__HEPEUP__FiveVector_db_datamem);
Reflex::GenreflexMemberBuilder __lhef__HEPEUP__FiveVector_funcmem_bld(&__lhef__HEPEUP__FiveVector_db_funcmem);
void __lhef__HEPEUP__FiveVector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("lhef::HEPEUP::FiveVector"), typeid(::lhef::HEPEUP::FiveVector), sizeof(::lhef::HEPEUP::FiveVector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FiveVector"), destructor_24337, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855, type_10857), Reflex::Literal("operator="), operator_24338, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10857), Reflex::Literal("FiveVector"), constructor_24339, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FiveVector"), constructor_24340, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_10846, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__lhef__HEPEUP__FiveVector_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__lhef__HEPEUP__FiveVector_funcmem_bld);
}

//------Delayed data member builder for class FiveVector -------------------
void __lhef__HEPEUP__FiveVector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_29984, Reflex::Literal("x"), OffsetOf(__shadow__::__lhef__HEPEUP__FiveVector, x), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class FiveVector -------------------
void __lhef__HEPEUP__FiveVector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102, type_198), Reflex::Literal("operator[]"), operator_24341, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6891, type_198), Reflex::Literal("operator[]"), operator_24342, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class vector<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> > -------------------------------
static void constructor_10866( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>();
  else ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>();
}

static void constructor_10867( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(const ::std::allocator<lhef::HEPEUP::FiveVector>*)arg[0]);
  else ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(const ::std::allocator<lhef::HEPEUP::FiveVector>*)arg[0]);
}

static void constructor_10868( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(::std::size_t*)arg[0],
      *(const ::lhef::HEPEUP::FiveVector*)arg[1]);
  else ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(::std::size_t*)arg[0],
      *(const ::lhef::HEPEUP::FiveVector*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(::std::size_t*)arg[0],
      *(const ::lhef::HEPEUP::FiveVector*)arg[1],
      *(const ::std::allocator<lhef::HEPEUP::FiveVector>*)arg[2]);
  else ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(::std::size_t*)arg[0],
      *(const ::lhef::HEPEUP::FiveVector*)arg[1],
      *(const ::std::allocator<lhef::HEPEUP::FiveVector>*)arg[2]);
  }
}

static void constructor_10869( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(const ::std::vector<lhef::HEPEUP::FiveVector>*)arg[0]);
  else ::new(mem) ::std::vector<lhef::HEPEUP::FiveVector>(*(const ::std::vector<lhef::HEPEUP::FiveVector>*)arg[0]);
}

static void destructor_10870(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<lhef::HEPEUP::FiveVector>*)o)->::std::vector<lhef::HEPEUP::FiveVector>::~vector)();
}
static  void operator_10871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<lhef::HEPEUP::FiveVector>*)o)->operator=)(*(const ::std::vector<lhef::HEPEUP::FiveVector>*)arg[0]);
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->operator=)(*(const ::std::vector<lhef::HEPEUP::FiveVector>*)arg[0]);
}

static  void method_10872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::lhef::HEPEUP::FiveVector*)arg[1]);
}

static  void method_10873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >)((((::std::vector<lhef::HEPEUP::FiveVector>*)o)->begin)());
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->begin)();
}

static  void method_10874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >)((((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->begin)());
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->begin)();
}

static  void method_10875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >)((((::std::vector<lhef::HEPEUP::FiveVector>*)o)->end)());
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->end)();
}

static  void method_10876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >)((((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->end)());
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->end)();
}

static  void method_10881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->size)());
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->size)();
}

static  void method_10882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->max_size)());
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->max_size)();
}

static  void method_10883( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::lhef::HEPEUP::FiveVector*)arg[1]);
  }
}

static  void method_10884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->capacity)());
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->capacity)();
}

static  void method_10885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->empty)());
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->empty)();
}

static  void method_10886( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<lhef::HEPEUP::FiveVector>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<lhef::HEPEUP::FiveVector>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<lhef::HEPEUP::FiveVector>*)o)->front)();
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->front)();
}

static  void method_10893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->front)();
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->front)();
}

static  void method_10894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<lhef::HEPEUP::FiveVector>*)o)->back)();
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->back)();
}

static  void method_10895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->back)();
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->back)();
}

static  void method_10896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<lhef::HEPEUP::FiveVector>*)o)->data)());
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->data)();
}

static  void method_10897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->data)());
  else   (((const ::std::vector<lhef::HEPEUP::FiveVector>*)o)->data)();
}

static  void method_10898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->push_back)(*(const ::lhef::HEPEUP::FiveVector*)arg[0]);
}

static  void method_10899( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->pop_back)();
}

static  void method_10900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >)((((::std::vector<lhef::HEPEUP::FiveVector>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[0],
    *(const ::lhef::HEPEUP::FiveVector*)arg[1]));
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[0],
    *(const ::lhef::HEPEUP::FiveVector*)arg[1]);
}

static  void method_10901( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::lhef::HEPEUP::FiveVector*)arg[2]);
}

static  void method_10902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >)((((::std::vector<lhef::HEPEUP::FiveVector>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[0]));
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[0]);
}

static  void method_10903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >)((((::std::vector<lhef::HEPEUP::FiveVector>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[1]));
  else   (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<lhef::HEPEUP::FiveVector*,std::vector<lhef::HEPEUP::FiveVector> >*)arg[1]);
}

static  void method_10904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->swap)(*(::std::vector<lhef::HEPEUP::FiveVector>*)arg[0]);
}

static  void method_10905( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<lhef::HEPEUP::FiveVector>*)o)->clear)();
}

static void method_newdel_2814( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<lhef::HEPEUP::FiveVector> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<lhef::HEPEUP::FiveVector> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<lhef::HEPEUP::FiveVector> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<lhef::HEPEUP::FiveVector> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<lhef::HEPEUP::FiveVector> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> >")), ::Reflex::BaseOffset< ::std::vector<lhef::HEPEUP::FiveVector>,::std::_Vector_base<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<lhef::HEPEUP::FiveVector> >::Generate();
  else ::Reflex::Proxy< ::std::vector<lhef::HEPEUP::FiveVector> >::Generate();
}

//------Dictionary for class vector<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> > -------------------------------
void __std__vector_lhef__HEPEUP__FiveVector__db_datamem(Reflex::Class*);
void __std__vector_lhef__HEPEUP__FiveVector__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_lhef__HEPEUP__FiveVector__datamem_bld(&__std__vector_lhef__HEPEUP__FiveVector__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_lhef__HEPEUP__FiveVector__funcmem_bld(&__std__vector_lhef__HEPEUP__FiveVector__db_funcmem);
void __std__vector_lhef__HEPEUP__FiveVector__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>"), typeid(::std::vector<lhef::HEPEUP::FiveVector>), sizeof(::std::vector<lhef::HEPEUP::FiveVector>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2295, ::Reflex::BaseOffset< ::std::vector<lhef::HEPEUP::FiveVector>, ::std::_Vector_base<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10846, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::_Alloc_value_type"))
  .AddTypedef(type_2295, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::_Base"))
  .AddTypedef(type_3069, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::_Tp_alloc_type"))
  .AddTypedef(type_5515, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::_Alloc_traits"))
  .AddTypedef(type_10846, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::value_type"))
  .AddTypedef(type_6344, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::pointer"))
  .AddTypedef(type_10853, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::const_pointer"))
  .AddTypedef(type_10855, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::reference"))
  .AddTypedef(type_10857, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::const_reference"))
  .AddTypedef(type_5446, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::iterator"))
  .AddTypedef(type_5447, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::const_iterator"))
  .AddTypedef(type_3213, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::const_reverse_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::reverse_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::difference_type"))
  .AddTypedef(type_3069, Reflex::Literal("std::vector<lhef::HEPEUP::FiveVector>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10866, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23502), Reflex::Literal("vector"), constructor_10867, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3033, type_10857, type_23502), Reflex::Literal("vector"), constructor_10868, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24344), Reflex::Literal("vector"), constructor_10869, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10870, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2814, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_lhef__HEPEUP__FiveVector__funcmem_bld);
}

//------Delayed data member builder for class vector<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> > -------------------
void __std__vector_lhef__HEPEUP__FiveVector__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<lhef::HEPEUP::FiveVector,std::allocator<lhef::HEPEUP::FiveVector> > -------------------
void __std__vector_lhef__HEPEUP__FiveVector__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24345, type_24344), Reflex::Literal("operator="), operator_10871, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_10857), Reflex::Literal("assign"), method_10872, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5446), Reflex::Literal("begin"), method_10873, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5447), Reflex::Literal("begin"), method_10874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5446), Reflex::Literal("end"), method_10875, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5447), Reflex::Literal("end"), method_10876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_10881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_10882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033, type_10846), Reflex::Literal("resize"), method_10883, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_10884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_10885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_10886, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855, type_3033), Reflex::Literal("operator[]"), operator_10887, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857, type_3033), Reflex::Literal("operator[]"), operator_10888, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855, type_3033), Reflex::Literal("at"), method_10890, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857, type_3033), Reflex::Literal("at"), method_10891, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855), Reflex::Literal("front"), method_10892, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857), Reflex::Literal("front"), method_10893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855), Reflex::Literal("back"), method_10894, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857), Reflex::Literal("back"), method_10895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6344), Reflex::Literal("data"), method_10896, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10853), Reflex::Literal("data"), method_10897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10857), Reflex::Literal("push_back"), method_10898, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("pop_back"), method_10899, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5446, type_5446, type_10857), Reflex::Literal("insert"), method_10900, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_5446, type_3033, type_10857), Reflex::Literal("insert"), method_10901, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5446, type_5446), Reflex::Literal("erase"), method_10902, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5446, type_5446, type_5446), Reflex::Literal("erase"), method_10903, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24345), Reflex::Literal("swap"), method_10904, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_10905, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<int,HepMC::GenVertex*,std::greater<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------------------
static void destructor_12402(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->::std::map<int,HepMC::GenVertex*,std::greater<int> >::~map)();
}
static void constructor_12403( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >();
  else ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >();
}

static void constructor_12404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >(*(const ::std::greater<int>*)arg[0]);
  else ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >(*(const ::std::greater<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >(*(const ::std::greater<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,HepMC::GenVertex*> >*)arg[1]);
  else ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >(*(const ::std::greater<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,HepMC::GenVertex*> >*)arg[1]);
  }
}

static void constructor_12405( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >(*(const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)arg[0]);
  else ::new(mem) ::std::map<int,HepMC::GenVertex*,std::greater<int> >(*(const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)arg[0]);
}

static  void operator_12406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->operator=)(*(const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)arg[0]);
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->operator=)(*(const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)arg[0]);
}

static  void method_12407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->get_allocator)());
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->get_allocator)();
}

static  void method_12408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->begin)());
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->begin)();
}

static  void method_12409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->begin)());
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->begin)();
}

static  void method_12410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->end)());
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->end)();
}

static  void method_12411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->end)());
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->end)();
}

static  void method_12416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->empty)());
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->empty)();
}

static  void method_12417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->size)());
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->size)();
}

static  void method_12418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->max_size)());
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->max_size)();
}

static  void operator_12419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_12422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >,bool>)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->insert)(*(const ::std::pair<const int,HepMC::GenVertex*>*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->insert)(*(const ::std::pair<const int,HepMC::GenVertex*>*)arg[0]);
}

static  void method_12423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0],
    *(const ::std::pair<const int,HepMC::GenVertex*>*)arg[1]));
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0],
    *(const ::std::pair<const int,HepMC::GenVertex*>*)arg[1]);
}

static  void method_12424( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0]);
}

static  void method_12425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12426( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[1]);
}

static  void method_12427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->swap)(*(::std::map<int,HepMC::GenVertex*,std::greater<int> >*)arg[0]);
}

static  void method_12428( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->clear)();
}

static  void method_12429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::greater<int>)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->key_comp)());
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->key_comp)();
}

static  void method_12431( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_12433( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_12434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >,std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> > >)((((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >,std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> > >)((((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*,std::greater<int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2955( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*,std::greater<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*,std::greater<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*,std::greater<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*,std::greater<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*,std::greater<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,HepMC::GenVertex*,std::greater<int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<int,HepMC::GenVertex*,std::greater<int> > >::Generate();
}

//------Dictionary for class map<int,HepMC::GenVertex*,std::greater<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------------------
void __std__map_int_HepMC__GenVertexp_std__greater_int_s__db_datamem(Reflex::Class*);
void __std__map_int_HepMC__GenVertexp_std__greater_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_HepMC__GenVertexp_std__greater_int_s__datamem_bld(&__std__map_int_HepMC__GenVertexp_std__greater_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_HepMC__GenVertexp_std__greater_int_s__funcmem_bld(&__std__map_int_HepMC__GenVertexp_std__greater_int_s__db_funcmem);
void __std__map_int_HepMC__GenVertexp_std__greater_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >"), typeid(::std::map<int,HepMC::GenVertex*,std::greater<int> >), sizeof(::std::map<int,HepMC::GenVertex*,std::greater<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_67, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::key_type"))
  .AddTypedef(type_9248, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::mapped_type"))
  .AddTypedef(type_2751, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::value_type"))
  .AddTypedef(type_2914, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::key_compare"))
  .AddTypedef(type_3051, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::allocator_type"))
  .AddTypedef(type_2751, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::_Alloc_value_type"))
  .AddTypedef(type_3051, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::_Pair_alloc_type"))
  .AddTypedef(type_2495, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::_Rep_type"))
  .AddTypedef(type_7878, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::pointer"))
  .AddTypedef(type_7880, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::const_pointer"))
  .AddTypedef(type_7882, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::reference"))
  .AddTypedef(type_7884, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::const_reference"))
  .AddTypedef(type_2891, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::iterator"))
  .AddTypedef(type_2595, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::const_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::difference_type"))
  .AddTypedef(type_3190, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::reverse_iterator"))
  .AddTypedef(type_3189, Reflex::Literal("std::map<int,HepMC::GenVertex*,std::greater<int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12402, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12403, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24051, type_24041), Reflex::Literal("map"), constructor_12404, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24518), Reflex::Literal("map"), constructor_12405, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2955, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_HepMC__GenVertexp_std__greater_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_HepMC__GenVertexp_std__greater_int_s__funcmem_bld);
}

//------Delayed data member builder for class map<int,HepMC::GenVertex*,std::greater<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------
void __std__map_int_HepMC__GenVertexp_std__greater_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2495, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_HepMC__GenVertexp_std__greater_int_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,HepMC::GenVertex*,std::greater<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------
void __std__map_int_HepMC__GenVertexp_std__greater_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24519, type_24518), Reflex::Literal("operator="), operator_12406, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3051), Reflex::Literal("get_allocator"), method_12407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891), Reflex::Literal("begin"), method_12408, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595), Reflex::Literal("begin"), method_12409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891), Reflex::Literal("end"), method_12410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595), Reflex::Literal("end"), method_12411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_12416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_12417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_12418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9253, type_10150), Reflex::Literal("operator[]"), operator_12419, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9253, type_10150), Reflex::Literal("at"), method_12420, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24290, type_10150), Reflex::Literal("at"), method_12421, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755, type_7884), Reflex::Literal("insert"), method_12422, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_2891, type_7884), Reflex::Literal("insert"), method_12423, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_2891), Reflex::Literal("erase"), method_12424, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_10150), Reflex::Literal("erase"), method_12425, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_2891, type_2891), Reflex::Literal("erase"), method_12426, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24519), Reflex::Literal("swap"), method_12427, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_12428, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2914), Reflex::Literal("key_comp"), method_12429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_10150), Reflex::Literal("find"), method_12431, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595, type_10150), Reflex::Literal("find"), method_12432, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_10150), Reflex::Literal("count"), method_12433, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_10150), Reflex::Literal("lower_bound"), method_12434, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595, type_10150), Reflex::Literal("lower_bound"), method_12435, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_10150), Reflex::Literal("upper_bound"), method_12436, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595, type_10150), Reflex::Literal("upper_bound"), method_12437, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2754, type_10150), Reflex::Literal("equal_range"), method_12438, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_10150), Reflex::Literal("equal_range"), method_12439, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,HepMC::GenParticle*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenParticle*> > > -------------------------------
static void destructor_12460(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,HepMC::GenParticle*>*)o)->::std::map<int,HepMC::GenParticle*>::~map)();
}
static void constructor_12461( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenParticle*>();
  else ::new(mem) ::std::map<int,HepMC::GenParticle*>();
}

static void constructor_12462( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenParticle*>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,HepMC::GenParticle*>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenParticle*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,HepMC::GenParticle*> >*)arg[1]);
  else ::new(mem) ::std::map<int,HepMC::GenParticle*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,HepMC::GenParticle*> >*)arg[1]);
  }
}

static void constructor_12463( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenParticle*>(*(const ::std::map<int,HepMC::GenParticle*>*)arg[0]);
  else ::new(mem) ::std::map<int,HepMC::GenParticle*>(*(const ::std::map<int,HepMC::GenParticle*>*)arg[0]);
}

static  void operator_12464( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenParticle*>*)o)->operator=)(*(const ::std::map<int,HepMC::GenParticle*>*)arg[0]);
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->operator=)(*(const ::std::map<int,HepMC::GenParticle*>*)arg[0]);
}

static  void method_12465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,HepMC::GenParticle*> >)((((const ::std::map<int,HepMC::GenParticle*>*)o)->get_allocator)());
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->get_allocator)();
}

static  void method_12466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >)((((::std::map<int,HepMC::GenParticle*>*)o)->begin)());
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->begin)();
}

static  void method_12467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >)((((const ::std::map<int,HepMC::GenParticle*>*)o)->begin)());
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->begin)();
}

static  void method_12468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >)((((::std::map<int,HepMC::GenParticle*>*)o)->end)());
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->end)();
}

static  void method_12469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >)((((const ::std::map<int,HepMC::GenParticle*>*)o)->end)());
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->end)();
}

static  void method_12474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,HepMC::GenParticle*>*)o)->empty)());
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->empty)();
}

static  void method_12475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenParticle*>*)o)->size)());
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->size)();
}

static  void method_12476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenParticle*>*)o)->max_size)());
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->max_size)();
}

static  void operator_12477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenParticle*>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12478( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenParticle*>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,HepMC::GenParticle*>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12480( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >,bool>)((((::std::map<int,HepMC::GenParticle*>*)o)->insert)(*(const ::std::pair<const int,HepMC::GenParticle*>*)arg[0]));
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->insert)(*(const ::std::pair<const int,HepMC::GenParticle*>*)arg[0]);
}

static  void method_12481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >)((((::std::map<int,HepMC::GenParticle*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0],
    *(const ::std::pair<const int,HepMC::GenParticle*>*)arg[1]));
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0],
    *(const ::std::pair<const int,HepMC::GenParticle*>*)arg[1]);
}

static  void method_12482( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenParticle*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0]);
}

static  void method_12483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,HepMC::GenParticle*>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenParticle*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[1]);
}

static  void method_12485( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenParticle*>*)o)->swap)(*(::std::map<int,HepMC::GenParticle*>*)arg[0]);
}

static  void method_12486( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,HepMC::GenParticle*>*)o)->clear)();
}

static  void method_12487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,HepMC::GenParticle*>*)o)->key_comp)());
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->key_comp)();
}

static  void method_12489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >)((((::std::map<int,HepMC::GenParticle*>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >)((((const ::std::map<int,HepMC::GenParticle*>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenParticle*>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->count)(*(const int*)arg[0]);
}

static  void method_12492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >)((((::std::map<int,HepMC::GenParticle*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >)((((const ::std::map<int,HepMC::GenParticle*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >)((((::std::map<int,HepMC::GenParticle*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12495( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >)((((const ::std::map<int,HepMC::GenParticle*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >,std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> > >)((((::std::map<int,HepMC::GenParticle*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenParticle*>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >,std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> > >)((((const ::std::map<int,HepMC::GenParticle*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenParticle*>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2956( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenParticle*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenParticle*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenParticle*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenParticle*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenParticle*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,HepMC::GenParticle*> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,HepMC::GenParticle*> >::Generate();
}

//------Dictionary for class map<int,HepMC::GenParticle*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenParticle*> > > -------------------------------
void __std__map_int_HepMC__GenParticlep__db_datamem(Reflex::Class*);
void __std__map_int_HepMC__GenParticlep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_HepMC__GenParticlep__datamem_bld(&__std__map_int_HepMC__GenParticlep__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_HepMC__GenParticlep__funcmem_bld(&__std__map_int_HepMC__GenParticlep__db_funcmem);
void __std__map_int_HepMC__GenParticlep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,HepMC::GenParticle*>"), typeid(::std::map<int,HepMC::GenParticle*>), sizeof(::std::map<int,HepMC::GenParticle*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_67, Reflex::Literal("std::map<int,HepMC::GenParticle*>::key_type"))
  .AddTypedef(type_6865, Reflex::Literal("std::map<int,HepMC::GenParticle*>::mapped_type"))
  .AddTypedef(type_2752, Reflex::Literal("std::map<int,HepMC::GenParticle*>::value_type"))
  .AddTypedef(type_2442, Reflex::Literal("std::map<int,HepMC::GenParticle*>::key_compare"))
  .AddTypedef(type_3052, Reflex::Literal("std::map<int,HepMC::GenParticle*>::allocator_type"))
  .AddTypedef(type_2752, Reflex::Literal("std::map<int,HepMC::GenParticle*>::_Alloc_value_type"))
  .AddTypedef(type_3052, Reflex::Literal("std::map<int,HepMC::GenParticle*>::_Pair_alloc_type"))
  .AddTypedef(type_2494, Reflex::Literal("std::map<int,HepMC::GenParticle*>::_Rep_type"))
  .AddTypedef(type_7983, Reflex::Literal("std::map<int,HepMC::GenParticle*>::pointer"))
  .AddTypedef(type_7985, Reflex::Literal("std::map<int,HepMC::GenParticle*>::const_pointer"))
  .AddTypedef(type_7987, Reflex::Literal("std::map<int,HepMC::GenParticle*>::reference"))
  .AddTypedef(type_7989, Reflex::Literal("std::map<int,HepMC::GenParticle*>::const_reference"))
  .AddTypedef(type_2892, Reflex::Literal("std::map<int,HepMC::GenParticle*>::iterator"))
  .AddTypedef(type_2596, Reflex::Literal("std::map<int,HepMC::GenParticle*>::const_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::map<int,HepMC::GenParticle*>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::map<int,HepMC::GenParticle*>::difference_type"))
  .AddTypedef(type_3196, Reflex::Literal("std::map<int,HepMC::GenParticle*>::reverse_iterator"))
  .AddTypedef(type_3195, Reflex::Literal("std::map<int,HepMC::GenParticle*>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12460, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12461, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23975, type_24048), Reflex::Literal("map"), constructor_12462, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24520), Reflex::Literal("map"), constructor_12463, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2956, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_HepMC__GenParticlep__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_HepMC__GenParticlep__funcmem_bld);
}

//------Delayed data member builder for class map<int,HepMC::GenParticle*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenParticle*> > > -------------------
void __std__map_int_HepMC__GenParticlep__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2494, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_HepMC__GenParticlep_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,HepMC::GenParticle*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenParticle*> > > -------------------
void __std__map_int_HepMC__GenParticlep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24521, type_24520), Reflex::Literal("operator="), operator_12464, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("get_allocator"), method_12465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("begin"), method_12466, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596), Reflex::Literal("begin"), method_12467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("end"), method_12468, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596), Reflex::Literal("end"), method_12469, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_12474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_12475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_12476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9241, type_10150), Reflex::Literal("operator[]"), operator_12477, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9241, type_10150), Reflex::Literal("at"), method_12478, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6870, type_10150), Reflex::Literal("at"), method_12479, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2759, type_7989), Reflex::Literal("insert"), method_12480, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892, type_2892, type_7989), Reflex::Literal("insert"), method_12481, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_2892), Reflex::Literal("erase"), method_12482, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_10150), Reflex::Literal("erase"), method_12483, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_2892, type_2892), Reflex::Literal("erase"), method_12484, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24521), Reflex::Literal("swap"), method_12485, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_12486, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2442), Reflex::Literal("key_comp"), method_12487, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892, type_10150), Reflex::Literal("find"), method_12489, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596, type_10150), Reflex::Literal("find"), method_12490, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_10150), Reflex::Literal("count"), method_12491, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892, type_10150), Reflex::Literal("lower_bound"), method_12492, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596, type_10150), Reflex::Literal("lower_bound"), method_12493, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892, type_10150), Reflex::Literal("upper_bound"), method_12494, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2596, type_10150), Reflex::Literal("upper_bound"), method_12495, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2758, type_10150), Reflex::Literal("equal_range"), method_12496, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2757, type_10150), Reflex::Literal("equal_range"), method_12497, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,HepMC::GenVertex*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------------------
static void destructor_12518(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,HepMC::GenVertex*>*)o)->::std::map<int,HepMC::GenVertex*>::~map)();
}
static void constructor_12519( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*>();
  else ::new(mem) ::std::map<int,HepMC::GenVertex*>();
}

static void constructor_12520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,HepMC::GenVertex*>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,HepMC::GenVertex*> >*)arg[1]);
  else ::new(mem) ::std::map<int,HepMC::GenVertex*>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,HepMC::GenVertex*> >*)arg[1]);
  }
}

static void constructor_12521( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,HepMC::GenVertex*>(*(const ::std::map<int,HepMC::GenVertex*>*)arg[0]);
  else ::new(mem) ::std::map<int,HepMC::GenVertex*>(*(const ::std::map<int,HepMC::GenVertex*>*)arg[0]);
}

static  void operator_12522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenVertex*>*)o)->operator=)(*(const ::std::map<int,HepMC::GenVertex*>*)arg[0]);
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->operator=)(*(const ::std::map<int,HepMC::GenVertex*>*)arg[0]);
}

static  void method_12523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*>*)o)->get_allocator)());
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->get_allocator)();
}

static  void method_12524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*>*)o)->begin)());
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->begin)();
}

static  void method_12525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*>*)o)->begin)());
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->begin)();
}

static  void method_12526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*>*)o)->end)());
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->end)();
}

static  void method_12527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*>*)o)->end)());
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->end)();
}

static  void method_12532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,HepMC::GenVertex*>*)o)->empty)());
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->empty)();
}

static  void method_12533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenVertex*>*)o)->size)());
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->size)();
}

static  void method_12534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenVertex*>*)o)->max_size)());
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->max_size)();
}

static  void operator_12535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenVertex*>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_12536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,HepMC::GenVertex*>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,HepMC::GenVertex*>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->at)(*(const int*)arg[0]);
}

static  void method_12538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >,bool>)((((::std::map<int,HepMC::GenVertex*>*)o)->insert)(*(const ::std::pair<const int,HepMC::GenVertex*>*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->insert)(*(const ::std::pair<const int,HepMC::GenVertex*>*)arg[0]);
}

static  void method_12539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0],
    *(const ::std::pair<const int,HepMC::GenVertex*>*)arg[1]));
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0],
    *(const ::std::pair<const int,HepMC::GenVertex*>*)arg[1]);
}

static  void method_12540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenVertex*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0]);
}

static  void method_12541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,HepMC::GenVertex*>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_12542( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenVertex*>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[1]);
}

static  void method_12543( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,HepMC::GenVertex*>*)o)->swap)(*(::std::map<int,HepMC::GenVertex*>*)arg[0]);
}

static  void method_12544( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,HepMC::GenVertex*>*)o)->clear)();
}

static  void method_12545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,HepMC::GenVertex*>*)o)->key_comp)());
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->key_comp)();
}

static  void method_12547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->find)(*(const int*)arg[0]);
}

static  void method_12549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,HepMC::GenVertex*>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->count)(*(const int*)arg[0]);
}

static  void method_12550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_12552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >)((((::std::map<int,HepMC::GenVertex*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >)((((const ::std::map<int,HepMC::GenVertex*>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_12554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >,std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> > >)((((::std::map<int,HepMC::GenVertex*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,HepMC::GenVertex*>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_12555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >,std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> > >)((((const ::std::map<int,HepMC::GenVertex*>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,HepMC::GenVertex*>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_2957( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,HepMC::GenVertex*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,HepMC::GenVertex*> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,HepMC::GenVertex*> >::Generate();
}

//------Dictionary for class map<int,HepMC::GenVertex*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------------------
void __std__map_int_HepMC__GenVertexp__db_datamem(Reflex::Class*);
void __std__map_int_HepMC__GenVertexp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_HepMC__GenVertexp__datamem_bld(&__std__map_int_HepMC__GenVertexp__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_HepMC__GenVertexp__funcmem_bld(&__std__map_int_HepMC__GenVertexp__db_funcmem);
void __std__map_int_HepMC__GenVertexp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,HepMC::GenVertex*>"), typeid(::std::map<int,HepMC::GenVertex*>), sizeof(::std::map<int,HepMC::GenVertex*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_67, Reflex::Literal("std::map<int,HepMC::GenVertex*>::key_type"))
  .AddTypedef(type_9248, Reflex::Literal("std::map<int,HepMC::GenVertex*>::mapped_type"))
  .AddTypedef(type_2751, Reflex::Literal("std::map<int,HepMC::GenVertex*>::value_type"))
  .AddTypedef(type_2442, Reflex::Literal("std::map<int,HepMC::GenVertex*>::key_compare"))
  .AddTypedef(type_3051, Reflex::Literal("std::map<int,HepMC::GenVertex*>::allocator_type"))
  .AddTypedef(type_2751, Reflex::Literal("std::map<int,HepMC::GenVertex*>::_Alloc_value_type"))
  .AddTypedef(type_3051, Reflex::Literal("std::map<int,HepMC::GenVertex*>::_Pair_alloc_type"))
  .AddTypedef(type_2493, Reflex::Literal("std::map<int,HepMC::GenVertex*>::_Rep_type"))
  .AddTypedef(type_7878, Reflex::Literal("std::map<int,HepMC::GenVertex*>::pointer"))
  .AddTypedef(type_7880, Reflex::Literal("std::map<int,HepMC::GenVertex*>::const_pointer"))
  .AddTypedef(type_7882, Reflex::Literal("std::map<int,HepMC::GenVertex*>::reference"))
  .AddTypedef(type_7884, Reflex::Literal("std::map<int,HepMC::GenVertex*>::const_reference"))
  .AddTypedef(type_2891, Reflex::Literal("std::map<int,HepMC::GenVertex*>::iterator"))
  .AddTypedef(type_2595, Reflex::Literal("std::map<int,HepMC::GenVertex*>::const_iterator"))
  .AddTypedef(type_3033, Reflex::Literal("std::map<int,HepMC::GenVertex*>::size_type"))
  .AddTypedef(type_2927, Reflex::Literal("std::map<int,HepMC::GenVertex*>::difference_type"))
  .AddTypedef(type_3190, Reflex::Literal("std::map<int,HepMC::GenVertex*>::reverse_iterator"))
  .AddTypedef(type_3189, Reflex::Literal("std::map<int,HepMC::GenVertex*>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12518, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12519, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23975, type_24041), Reflex::Literal("map"), constructor_12520, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24522), Reflex::Literal("map"), constructor_12521, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2957, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_HepMC__GenVertexp__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_HepMC__GenVertexp__funcmem_bld);
}

//------Delayed data member builder for class map<int,HepMC::GenVertex*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------
void __std__map_int_HepMC__GenVertexp__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2493, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_HepMC__GenVertexp_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,HepMC::GenVertex*,std::less<int>,std::allocator<std::pair<const int, HepMC::GenVertex*> > > -------------------
void __std__map_int_HepMC__GenVertexp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24523, type_24522), Reflex::Literal("operator="), operator_12522, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3051), Reflex::Literal("get_allocator"), method_12523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891), Reflex::Literal("begin"), method_12524, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595), Reflex::Literal("begin"), method_12525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891), Reflex::Literal("end"), method_12526, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595), Reflex::Literal("end"), method_12527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_12532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_12533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("max_size"), method_12534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9253, type_10150), Reflex::Literal("operator[]"), operator_12535, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9253, type_10150), Reflex::Literal("at"), method_12536, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24290, type_10150), Reflex::Literal("at"), method_12537, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755, type_7884), Reflex::Literal("insert"), method_12538, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_2891, type_7884), Reflex::Literal("insert"), method_12539, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_2891), Reflex::Literal("erase"), method_12540, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_10150), Reflex::Literal("erase"), method_12541, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_2891, type_2891), Reflex::Literal("erase"), method_12542, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24523), Reflex::Literal("swap"), method_12543, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_12544, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2442), Reflex::Literal("key_comp"), method_12545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_10150), Reflex::Literal("find"), method_12547, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595, type_10150), Reflex::Literal("find"), method_12548, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033, type_10150), Reflex::Literal("count"), method_12549, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_10150), Reflex::Literal("lower_bound"), method_12550, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595, type_10150), Reflex::Literal("lower_bound"), method_12551, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2891, type_10150), Reflex::Literal("upper_bound"), method_12552, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2595, type_10150), Reflex::Literal("upper_bound"), method_12553, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2754, type_10150), Reflex::Literal("equal_range"), method_12554, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_10150), Reflex::Literal("equal_range"), method_12555, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PdfInfo -------------------------------
static void constructor_15062( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::PdfInfo();
  else ::new(mem) ::HepMC::PdfInfo();
}

static void constructor_15063( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::PdfInfo(*(int*)arg[0],
      *(int*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]);
  else ::new(mem) ::HepMC::PdfInfo(*(int*)arg[0],
      *(int*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::PdfInfo(*(int*)arg[0],
      *(int*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(int*)arg[7]);
  else ::new(mem) ::HepMC::PdfInfo(*(int*)arg[0],
      *(int*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(int*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::PdfInfo(*(int*)arg[0],
      *(int*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8]);
  else ::new(mem) ::HepMC::PdfInfo(*(int*)arg[0],
      *(int*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8]);
  }
}

static void destructor_15064(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::PdfInfo*)o)->::HepMC::PdfInfo::~PdfInfo)();
}
static void constructor_15065( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::PdfInfo(*(const ::HepMC::PdfInfo*)arg[0]);
  else ::new(mem) ::HepMC::PdfInfo(*(const ::HepMC::PdfInfo*)arg[0]);
}

static  void operator_15066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::PdfInfo*)o)->operator=)(*(const ::HepMC::PdfInfo*)arg[0]);
  else   (((::HepMC::PdfInfo*)o)->operator=)(*(const ::HepMC::PdfInfo*)arg[0]);
}

static  void method_15067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->swap)(*(::HepMC::PdfInfo*)arg[0]);
}

static  void operator_15068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::PdfInfo*)o)->operator==)(*(const ::HepMC::PdfInfo*)arg[0]));
  else   (((const ::HepMC::PdfInfo*)o)->operator==)(*(const ::HepMC::PdfInfo*)arg[0]);
}

static  void operator_15069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::PdfInfo*)o)->operator!=)(*(const ::HepMC::PdfInfo*)arg[0]));
  else   (((const ::HepMC::PdfInfo*)o)->operator!=)(*(const ::HepMC::PdfInfo*)arg[0]);
}

static  void method_15070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::PdfInfo*)o)->id1)());
  else   (((const ::HepMC::PdfInfo*)o)->id1)();
}

static  void method_15071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::PdfInfo*)o)->id2)());
  else   (((const ::HepMC::PdfInfo*)o)->id2)();
}

static  void method_15072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::PdfInfo*)o)->pdf_id1)());
  else   (((const ::HepMC::PdfInfo*)o)->pdf_id1)();
}

static  void method_15073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::PdfInfo*)o)->pdf_id2)());
  else   (((const ::HepMC::PdfInfo*)o)->pdf_id2)();
}

static  void method_15074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::PdfInfo*)o)->x1)());
  else   (((const ::HepMC::PdfInfo*)o)->x1)();
}

static  void method_15075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::PdfInfo*)o)->x2)());
  else   (((const ::HepMC::PdfInfo*)o)->x2)();
}

static  void method_15076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::PdfInfo*)o)->scalePDF)());
  else   (((const ::HepMC::PdfInfo*)o)->scalePDF)();
}

static  void method_15077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::PdfInfo*)o)->pdf1)());
  else   (((const ::HepMC::PdfInfo*)o)->pdf1)();
}

static  void method_15078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::PdfInfo*)o)->pdf2)());
  else   (((const ::HepMC::PdfInfo*)o)->pdf2)();
}

static  void method_15079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::PdfInfo*)o)->is_valid)());
  else   (((const ::HepMC::PdfInfo*)o)->is_valid)();
}

static  void method_15080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_id1)(*(const int*)arg[0]);
}

static  void method_15081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_id2)(*(const int*)arg[0]);
}

static  void method_15082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_pdf_id1)(*(const int*)arg[0]);
}

static  void method_15083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_pdf_id2)(*(const int*)arg[0]);
}

static  void method_15084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_x1)(*(const double*)arg[0]);
}

static  void method_15085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_x2)(*(const double*)arg[0]);
}

static  void method_15086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_scalePDF)(*(const double*)arg[0]);
}

static  void method_15087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_pdf1)(*(const double*)arg[0]);
}

static  void method_15088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::PdfInfo*)o)->set_pdf2)(*(const double*)arg[0]);
}

static void method_newdel_3447( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::PdfInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::PdfInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::PdfInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::PdfInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::PdfInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PdfInfo -------------------------------
void __HepMC__PdfInfo_db_datamem(Reflex::Class*);
void __HepMC__PdfInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__PdfInfo_datamem_bld(&__HepMC__PdfInfo_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__PdfInfo_funcmem_bld(&__HepMC__PdfInfo_db_funcmem);
void __HepMC__PdfInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::PdfInfo"), typeid(::HepMC::PdfInfo), sizeof(::HepMC::PdfInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PdfInfo"), constructor_15062, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_67, type_67, type_102, type_102, type_102, type_102, type_102, type_67, type_67), Reflex::Literal("PdfInfo"), constructor_15063, 0, "i1;i2;xin1;xin2;q;p1;p2;pid1=0;pid2=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PdfInfo"), destructor_15064, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24797), Reflex::Literal("PdfInfo"), constructor_15065, 0, "orig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3447, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__PdfInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__PdfInfo_funcmem_bld);
}

//------Delayed data member builder for class PdfInfo -------------------
void __HepMC__PdfInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67, Reflex::Literal("m_id1"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_id1), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_id2"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_id2), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_pdf_id1"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_pdf_id1), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_pdf_id2"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_pdf_id2), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_x1"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_x1), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_x2"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_x2), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_scalePDF"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_scalePDF), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_pdf1"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_pdf1), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_pdf2"), OffsetOf(__shadow__::__HepMC__PdfInfo, m_pdf2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PdfInfo -------------------
void __HepMC__PdfInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24798, type_24797), Reflex::Literal("operator="), operator_15066, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24798), Reflex::Literal("swap"), method_15067, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24797), Reflex::Literal("operator=="), operator_15068, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24797), Reflex::Literal("operator!="), operator_15069, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("id1"), method_15070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("id2"), method_15071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("pdf_id1"), method_15072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("pdf_id2"), method_15073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("x1"), method_15074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("x2"), method_15075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("scalePDF"), method_15076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("pdf1"), method_15077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("pdf2"), method_15078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("is_valid"), method_15079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_id1"), method_15080, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_id2"), method_15081, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_pdf_id1"), method_15082, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_pdf_id2"), method_15083, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("set_x1"), method_15084, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("set_x2"), method_15085, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("set_scalePDF"), method_15086, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("set_pdf1"), method_15087, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("set_pdf2"), method_15088, 0, "f", ::Reflex::PUBLIC);
}
//------Stub functions for class GenCrossSection -------------------------------
static void constructor_15092( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenCrossSection();
  else ::new(mem) ::HepMC::GenCrossSection();
}

static void destructor_15093(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenCrossSection*)o)->::HepMC::GenCrossSection::~GenCrossSection)();
}
static void constructor_15094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenCrossSection(*(const ::HepMC::GenCrossSection*)arg[0]);
  else ::new(mem) ::HepMC::GenCrossSection(*(const ::HepMC::GenCrossSection*)arg[0]);
}

static  void method_15095( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenCrossSection*)o)->swap)(*(::HepMC::GenCrossSection*)arg[0]);
}

static  void operator_15096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenCrossSection*)o)->operator=)(*(const ::HepMC::GenCrossSection*)arg[0]);
  else   (((::HepMC::GenCrossSection*)o)->operator=)(*(const ::HepMC::GenCrossSection*)arg[0]);
}

static  void operator_15097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenCrossSection*)o)->operator==)(*(const ::HepMC::GenCrossSection*)arg[0]));
  else   (((const ::HepMC::GenCrossSection*)o)->operator==)(*(const ::HepMC::GenCrossSection*)arg[0]);
}

static  void operator_15098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenCrossSection*)o)->operator!=)(*(const ::HepMC::GenCrossSection*)arg[0]));
  else   (((const ::HepMC::GenCrossSection*)o)->operator!=)(*(const ::HepMC::GenCrossSection*)arg[0]);
}

static  void method_15099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenCrossSection*)o)->cross_section)());
  else   (((const ::HepMC::GenCrossSection*)o)->cross_section)();
}

static  void method_15100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenCrossSection*)o)->cross_section_error)());
  else   (((const ::HepMC::GenCrossSection*)o)->cross_section_error)();
}

static  void method_15101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenCrossSection*)o)->is_set)());
  else   (((const ::HepMC::GenCrossSection*)o)->is_set)();
}

static  void method_15102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenCrossSection*)o)->set_cross_section)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_15103( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenCrossSection*)o)->set_cross_section)(*(double*)arg[0]);
}

static  void method_15104( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenCrossSection*)o)->set_cross_section_error)(*(double*)arg[0]);
}

static  void method_15105( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HepMC::GenCrossSection*)o)->clear)();
}

static  void method_15106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenCrossSection*)o)->write)(*(::std::ostream*)arg[0]);
  else   (((const ::HepMC::GenCrossSection*)o)->write)(*(::std::ostream*)arg[0]);
}

static  void method_15107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenCrossSection*)o)->read)(*(::std::istream*)arg[0]);
  else   (((::HepMC::GenCrossSection*)o)->read)(*(::std::istream*)arg[0]);
}

static void method_newdel_3448( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenCrossSection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenCrossSection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenCrossSection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenCrossSection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenCrossSection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenCrossSection -------------------------------
void __HepMC__GenCrossSection_db_datamem(Reflex::Class*);
void __HepMC__GenCrossSection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenCrossSection_datamem_bld(&__HepMC__GenCrossSection_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenCrossSection_funcmem_bld(&__HepMC__GenCrossSection_db_funcmem);
void __HepMC__GenCrossSection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenCrossSection"), typeid(::HepMC::GenCrossSection), sizeof(::HepMC::GenCrossSection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenCrossSection"), constructor_15092, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenCrossSection"), destructor_15093, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24799), Reflex::Literal("GenCrossSection"), constructor_15094, 0, "orig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3448, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenCrossSection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenCrossSection_funcmem_bld);
}

//------Delayed data member builder for class GenCrossSection -------------------
void __HepMC__GenCrossSection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_102, Reflex::Literal("m_cross_section"), OffsetOf(__shadow__::__HepMC__GenCrossSection, m_cross_section), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_cross_section_error"), OffsetOf(__shadow__::__HepMC__GenCrossSection, m_cross_section_error), ::Reflex::PRIVATE)
  .AddDataMember(type_1441, Reflex::Literal("m_is_set"), OffsetOf(__shadow__::__HepMC__GenCrossSection, m_is_set), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenCrossSection -------------------
void __HepMC__GenCrossSection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_15333), Reflex::Literal("swap"), method_15095, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15333, type_24799), Reflex::Literal("operator="), operator_15096, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24799), Reflex::Literal("operator=="), operator_15097, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24799), Reflex::Literal("operator!="), operator_15098, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("cross_section"), method_15099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("cross_section_error"), method_15100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("is_set"), method_15101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102, type_102), Reflex::Literal("set_cross_section"), method_15102, 0, "xs;xserr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("set_cross_section"), method_15103, 0, "xs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("set_cross_section_error"), method_15104, 0, "xserr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_15105, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4752, type_4752), Reflex::Literal("write"), method_15106, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761, type_4761), Reflex::Literal("read"), method_15107, 0, "", ::Reflex::PUBLIC);
}
//------Stub functions for class GenParticle -------------------------------
static void constructor_15117( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenParticle();
  else ::new(mem) ::HepMC::GenParticle();
}

static void constructor_15118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(const ::HepMC::Flow*)arg[3]);
  else ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(const ::HepMC::Flow*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(const ::HepMC::Flow*)arg[3],
      *(const ::HepMC::Polarization*)arg[4]);
  else ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(const ::HepMC::Flow*)arg[3],
      *(const ::HepMC::Polarization*)arg[4]);
  }
}

static void constructor_15119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::GenParticle*)arg[0]);
  else ::new(mem) ::HepMC::GenParticle(*(const ::HepMC::GenParticle*)arg[0]);
}

static void destructor_15120(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenParticle*)o)->::HepMC::GenParticle::~GenParticle)();
}
static  void method_15121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenParticle*)o)->swap)(*(::HepMC::GenParticle*)arg[0]);
}

static  void operator_15122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenParticle*)o)->operator=)(*(const ::HepMC::GenParticle*)arg[0]);
  else   (((::HepMC::GenParticle*)o)->operator=)(*(const ::HepMC::GenParticle*)arg[0]);
}

static  void operator_15123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenParticle*)o)->operator==)(*(const ::HepMC::GenParticle*)arg[0]));
  else   (((const ::HepMC::GenParticle*)o)->operator==)(*(const ::HepMC::GenParticle*)arg[0]);
}

static  void operator_15124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenParticle*)o)->operator!=)(*(const ::HepMC::GenParticle*)arg[0]));
  else   (((const ::HepMC::GenParticle*)o)->operator!=)(*(const ::HepMC::GenParticle*)arg[0]);
}

static  void method_15125( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::GenParticle*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::GenParticle*)o)->print)(*(::std::ostream*)arg[0]);
  }
}

static  void converter_15126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::FourVector)((((const ::HepMC::GenParticle*)o)->operator HepMC::FourVector)());
  else   (((const ::HepMC::GenParticle*)o)->operator HepMC::FourVector)();
}

static  void method_15127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenParticle*)o)->momentum)();
  else   (((const ::HepMC::GenParticle*)o)->momentum)();
}

static  void method_15128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenParticle*)o)->pdg_id)());
  else   (((const ::HepMC::GenParticle*)o)->pdg_id)();
}

static  void method_15129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenParticle*)o)->status)());
  else   (((const ::HepMC::GenParticle*)o)->status)();
}

static  void method_15130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenParticle*)o)->flow)();
  else   (((const ::HepMC::GenParticle*)o)->flow)();
}

static  void method_15131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenParticle*)o)->flow)(*(int*)arg[0]));
  else   (((const ::HepMC::GenParticle*)o)->flow)(*(int*)arg[0]);
}

static  void method_15132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenParticle*)o)->polarization)();
  else   (((const ::HepMC::GenParticle*)o)->polarization)();
}

static  void method_15133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenParticle*)o)->production_vertex)());
  else   (((const ::HepMC::GenParticle*)o)->production_vertex)();
}

static  void method_15134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenParticle*)o)->end_vertex)());
  else   (((const ::HepMC::GenParticle*)o)->end_vertex)();
}

static  void method_15135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenParticle*)o)->parent_event)());
  else   (((const ::HepMC::GenParticle*)o)->parent_event)();
}

static  void method_15136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenParticle*)o)->generated_mass)());
  else   (((const ::HepMC::GenParticle*)o)->generated_mass)();
}

static  void method_15137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenParticle*)o)->generatedMass)());
  else   (((const ::HepMC::GenParticle*)o)->generatedMass)();
}

static  void method_15138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenParticle*)o)->barcode)());
  else   (((const ::HepMC::GenParticle*)o)->barcode)();
}

static  void method_15139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenParticle*)o)->is_undecayed)());
  else   (((const ::HepMC::GenParticle*)o)->is_undecayed)();
}

static  void method_15140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenParticle*)o)->has_decayed)());
  else   (((const ::HepMC::GenParticle*)o)->has_decayed)();
}

static  void method_15141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenParticle*)o)->is_beam)());
  else   (((const ::HepMC::GenParticle*)o)->is_beam)();
}

static  void method_15142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::GenParticleProductionRange)((((::HepMC::GenParticle*)o)->particles_in)());
    else     (((::HepMC::GenParticle*)o)->particles_in)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::GenParticleProductionRange)((((::HepMC::GenParticle*)o)->particles_in)(*(::HepMC::IteratorRange*)arg[0]));
    else     (((::HepMC::GenParticle*)o)->particles_in)(*(::HepMC::IteratorRange*)arg[0]);
  }
}

static  void method_15143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleProductionRange)((((const ::HepMC::GenParticle*)o)->particles_in)());
    else     (((const ::HepMC::GenParticle*)o)->particles_in)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleProductionRange)((((const ::HepMC::GenParticle*)o)->particles_in)(*(::HepMC::IteratorRange*)arg[0]));
    else     (((const ::HepMC::GenParticle*)o)->particles_in)(*(::HepMC::IteratorRange*)arg[0]);
  }
}

static  void method_15144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::GenParticleEndRange)((((::HepMC::GenParticle*)o)->particles_out)());
    else     (((::HepMC::GenParticle*)o)->particles_out)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::GenParticleEndRange)((((::HepMC::GenParticle*)o)->particles_out)(*(::HepMC::IteratorRange*)arg[0]));
    else     (((::HepMC::GenParticle*)o)->particles_out)(*(::HepMC::IteratorRange*)arg[0]);
  }
}

static  void method_15145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleEndRange)((((const ::HepMC::GenParticle*)o)->particles_out)());
    else     (((const ::HepMC::GenParticle*)o)->particles_out)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleEndRange)((((const ::HepMC::GenParticle*)o)->particles_out)(*(::HepMC::IteratorRange*)arg[0]));
    else     (((const ::HepMC::GenParticle*)o)->particles_out)(*(::HepMC::IteratorRange*)arg[0]);
  }
}

static  void method_15146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HepMC::GenParticle*)o)->suggest_barcode)(*(int*)arg[0]));
  else   (((::HepMC::GenParticle*)o)->suggest_barcode)(*(int*)arg[0]);
}

static  void method_15147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenParticle*)o)->set_momentum)(*(const ::HepMC::FourVector*)arg[0]);
}

static  void method_15148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenParticle*)o)->set_pdg_id)(*(int*)arg[0]);
}

static  void method_15149( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::HepMC::GenParticle*)o)->set_status)();
  }
  else if ( arg.size() == 1 ) { 
    (((::HepMC::GenParticle*)o)->set_status)(*(int*)arg[0]);
  }
}

static  void method_15150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenParticle*)o)->set_flow)(*(const ::HepMC::Flow*)arg[0]);
}

static  void method_15151( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::HepMC::GenParticle*)o)->set_flow)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::HepMC::GenParticle*)o)->set_flow)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_15152( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::HepMC::GenParticle*)o)->set_polarization)();
  }
  else if ( arg.size() == 1 ) { 
    (((::HepMC::GenParticle*)o)->set_polarization)(*(const ::HepMC::Polarization*)arg[0]);
  }
}

static  void method_15153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenParticle*)o)->set_generated_mass)(*(const double*)arg[0]);
}

static  void method_15154( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenParticle*)o)->setGeneratedMass)(*(const double*)arg[0]);
}

static void method_newdel_3450( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenParticle -------------------------------
void __HepMC__GenParticle_db_datamem(Reflex::Class*);
void __HepMC__GenParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenParticle_datamem_bld(&__HepMC__GenParticle_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenParticle_funcmem_bld(&__HepMC__GenParticle_db_funcmem);
void __HepMC__GenParticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenParticle"), typeid(::HepMC::GenParticle), sizeof(::HepMC::GenParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenParticle"), constructor_15117, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24800, type_67, type_67, type_15336, type_15335), Reflex::Literal("GenParticle"), constructor_15118, 0, "momentum;pdg_id;status=0;itsflow=HepMC::Flow(0u);polar=HepMC::Polarization(0.0, 0.0)", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15334), Reflex::Literal("GenParticle"), constructor_15119, 0, "inparticle", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenParticle"), destructor_15120, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenParticle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenParticle_funcmem_bld);
}

//------Delayed data member builder for class GenParticle -------------------
void __HepMC__GenParticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3455, Reflex::Literal("m_momentum"), OffsetOf(__shadow__::__HepMC__GenParticle, m_momentum), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_pdg_id"), OffsetOf(__shadow__::__HepMC__GenParticle, m_pdg_id), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_status"), OffsetOf(__shadow__::__HepMC__GenParticle, m_status), ::Reflex::PRIVATE)
  .AddDataMember(type_3453, Reflex::Literal("m_flow"), OffsetOf(__shadow__::__HepMC__GenParticle, m_flow), ::Reflex::PRIVATE)
  .AddDataMember(type_3475, Reflex::Literal("m_polarization"), OffsetOf(__shadow__::__HepMC__GenParticle, m_polarization), ::Reflex::PRIVATE)
  .AddDataMember(type_9248, Reflex::Literal("m_production_vertex"), OffsetOf(__shadow__::__HepMC__GenParticle, m_production_vertex), ::Reflex::PRIVATE)
  .AddDataMember(type_9248, Reflex::Literal("m_end_vertex"), OffsetOf(__shadow__::__HepMC__GenParticle, m_end_vertex), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_barcode"), OffsetOf(__shadow__::__HepMC__GenParticle, m_barcode), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_generated_mass"), OffsetOf(__shadow__::__HepMC__GenParticle, m_generated_mass), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenParticle -------------------
void __HepMC__GenParticle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24801), Reflex::Literal("swap"), method_15121, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24801, type_15334), Reflex::Literal("operator="), operator_15122, 0, "inparticle", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15334), Reflex::Literal("operator=="), operator_15123, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15334), Reflex::Literal("operator!="), operator_15124, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("print"), method_15125, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455), Reflex::Literal("operator HepMC::FourVector"), converter_15126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24800), Reflex::Literal("momentum"), method_15127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("pdg_id"), method_15128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("status"), method_15129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15336), Reflex::Literal("flow"), method_15130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67, type_67), Reflex::Literal("flow"), method_15131, 0, "code_index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15335), Reflex::Literal("polarization"), method_15132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9248), Reflex::Literal("production_vertex"), method_15133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9248), Reflex::Literal("end_vertex"), method_15134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24802), Reflex::Literal("parent_event"), method_15135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("generated_mass"), method_15136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("generatedMass"), method_15137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("barcode"), method_15138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("is_undecayed"), method_15139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("has_decayed"), method_15140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("is_beam"), method_15141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3481, type_3457), Reflex::Literal("particles_in"), method_15142, 0, "range=relatives", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3478, type_3457), Reflex::Literal("particles_in"), method_15143, 0, "range=relatives", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3456, type_3457), Reflex::Literal("particles_out"), method_15144, 0, "range=relatives", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3485, type_3457), Reflex::Literal("particles_out"), method_15145, 0, "range=relatives", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_67), Reflex::Literal("suggest_barcode"), method_15146, 0, "the_bar_code", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24800), Reflex::Literal("set_momentum"), method_15147, 0, "vec4", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("set_pdg_id"), method_15148, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("set_status"), method_15149, 0, "st=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_15336), Reflex::Literal("set_flow"), method_15150, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67, type_67), Reflex::Literal("set_flow"), method_15151, 0, "code_index;code=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_15335), Reflex::Literal("set_polarization"), method_15152, 0, "polar=HepMC::Polarization(0.0, 0.0)", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("set_generated_mass"), method_15153, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("setGeneratedMass"), method_15154, 0, "m", ::Reflex::PUBLIC);
}
//------Stub functions for class Flow -------------------------------
static void constructor_15172( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Flow();
  else ::new(mem) ::HepMC::Flow();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Flow((::HepMC::GenParticle*)arg[0]);
  else ::new(mem) ::HepMC::Flow((::HepMC::GenParticle*)arg[0]);
  }
}

static void constructor_15173( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Flow(*(const ::HepMC::Flow*)arg[0]);
  else ::new(mem) ::HepMC::Flow(*(const ::HepMC::Flow*)arg[0]);
}

static void destructor_15174(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::Flow*)o)->::HepMC::Flow::~Flow)();
}
static  void method_15175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::Flow*)o)->swap)(*(::HepMC::Flow*)arg[0]);
}

static  void operator_15176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::Flow*)o)->operator=)(*(const ::HepMC::Flow*)arg[0]);
  else   (((::HepMC::Flow*)o)->operator=)(*(const ::HepMC::Flow*)arg[0]);
}

static  void operator_15177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::Flow*)o)->operator==)(*(const ::HepMC::Flow*)arg[0]));
  else   (((const ::HepMC::Flow*)o)->operator==)(*(const ::HepMC::Flow*)arg[0]);
}

static  void operator_15178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::Flow*)o)->operator!=)(*(const ::HepMC::Flow*)arg[0]));
  else   (((const ::HepMC::Flow*)o)->operator!=)(*(const ::HepMC::Flow*)arg[0]);
}

static  void method_15179( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::Flow*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::Flow*)o)->print)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<HepMC::GenParticle*>)((((const ::HepMC::Flow*)o)->connected_partners)(*(int*)arg[0]));
    else     (((const ::HepMC::Flow*)o)->connected_partners)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<HepMC::GenParticle*>)((((const ::HepMC::Flow*)o)->connected_partners)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::HepMC::Flow*)o)->connected_partners)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<HepMC::GenParticle*>)((((const ::HepMC::Flow*)o)->connected_partners)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]));
    else     (((const ::HepMC::Flow*)o)->connected_partners)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_15181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<HepMC::GenParticle*>)((((const ::HepMC::Flow*)o)->dangling_connected_partners)(*(int*)arg[0]));
    else     (((const ::HepMC::Flow*)o)->dangling_connected_partners)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<HepMC::GenParticle*>)((((const ::HepMC::Flow*)o)->dangling_connected_partners)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::HepMC::Flow*)o)->dangling_connected_partners)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<HepMC::GenParticle*>)((((const ::HepMC::Flow*)o)->dangling_connected_partners)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]));
    else     (((const ::HepMC::Flow*)o)->dangling_connected_partners)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_15182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::Flow*)o)->particle_owner)());
  else   (((const ::HepMC::Flow*)o)->particle_owner)();
}

static  void method_15183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::HepMC::Flow*)o)->icode)());
    else     (((const ::HepMC::Flow*)o)->icode)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::HepMC::Flow*)o)->icode)(*(int*)arg[0]));
    else     (((const ::HepMC::Flow*)o)->icode)(*(int*)arg[0]);
  }
}

static  void method_15184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::Flow)((((::HepMC::Flow*)o)->set_icode)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::HepMC::Flow*)o)->set_icode)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_15185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::Flow)((((::HepMC::Flow*)o)->set_unique_icode)());
    else     (((::HepMC::Flow*)o)->set_unique_icode)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::Flow)((((::HepMC::Flow*)o)->set_unique_icode)(*(int*)arg[0]));
    else     (((::HepMC::Flow*)o)->set_unique_icode)(*(int*)arg[0]);
  }
}

static  void method_15186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::Flow*)o)->empty)());
  else   (((const ::HepMC::Flow*)o)->empty)();
}

static  void method_15187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::Flow*)o)->size)());
  else   (((const ::HepMC::Flow*)o)->size)();
}

static  void method_15188( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HepMC::Flow*)o)->clear)();
}

static  void method_15189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HepMC::Flow*)o)->erase)(*(int*)arg[0]));
  else   (((::HepMC::Flow*)o)->erase)(*(int*)arg[0]);
}

static  void method_15190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::HepMC::Flow*)o)->begin)());
  else   (((::HepMC::Flow*)o)->begin)();
}

static  void method_15191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::HepMC::Flow*)o)->end)());
  else   (((::HepMC::Flow*)o)->end)();
}

static  void method_15192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::HepMC::Flow*)o)->begin)());
  else   (((const ::HepMC::Flow*)o)->begin)();
}

static  void method_15193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::HepMC::Flow*)o)->end)());
  else   (((const ::HepMC::Flow*)o)->end)();
}

static void constructor_x46( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Flow();
  else ::new(mem) ::HepMC::Flow();
}

static void method_newdel_3453( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::Flow >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::Flow >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::Flow >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::Flow >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::Flow >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Flow -------------------------------
void __HepMC__Flow_db_datamem(Reflex::Class*);
void __HepMC__Flow_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__Flow_datamem_bld(&__HepMC__Flow_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__Flow_funcmem_bld(&__HepMC__Flow_db_funcmem);
void __HepMC__Flow_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::Flow"), typeid(::HepMC::Flow), sizeof(::HepMC::Flow), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_2893, Reflex::Literal("HepMC::Flow::iterator"))
  .AddTypedef(type_2597, Reflex::Literal("HepMC::Flow::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6865), Reflex::Literal("Flow"), constructor_15172, 0, "particle_owner=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15336), Reflex::Literal("Flow"), constructor_15173, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Flow"), destructor_15174, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Flow"), constructor_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3453, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__Flow_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__Flow_funcmem_bld);
}

//------Delayed data member builder for class Flow -------------------
void __HepMC__Flow_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6865, Reflex::Literal("m_particle_owner"), OffsetOf(__shadow__::__HepMC__Flow, m_particle_owner), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_2958, Reflex::Literal("m_icode"), OffsetOf(__shadow__::__HepMC__Flow, m_icode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Flow -------------------
void __HepMC__Flow_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24803), Reflex::Literal("swap"), method_15175, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24803, type_15336), Reflex::Literal("operator="), operator_15176, 0, "inflow", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15336), Reflex::Literal("operator=="), operator_15177, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15336), Reflex::Literal("operator!="), operator_15178, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("print"), method_15179, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2804, type_67, type_67, type_67), Reflex::Literal("connected_partners"), method_15180, 0, "code;code_index=1;num_indices=2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2804, type_67, type_67, type_67), Reflex::Literal("dangling_connected_partners"), method_15181, 0, "code;code_index=1;num_indices=2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12816), Reflex::Literal("particle_owner"), method_15182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67, type_67), Reflex::Literal("icode"), method_15183, 0, "code_index=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3453, type_67, type_67), Reflex::Literal("set_icode"), method_15184, 0, "code_index;code", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3453, type_67), Reflex::Literal("set_unique_icode"), method_15185, 0, "flow_num=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_15186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("size"), method_15187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_15188, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_67), Reflex::Literal("erase"), method_15189, 0, "code_index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2893), Reflex::Literal("begin"), method_15190, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2893), Reflex::Literal("end"), method_15191, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2597), Reflex::Literal("begin"), method_15192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2597), Reflex::Literal("end"), method_15193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class FourVector -------------------------------
static void destructor_15214(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::FourVector*)o)->::HepMC::FourVector::~FourVector)();
}
static void constructor_15215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::FourVector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::HepMC::FourVector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::FourVector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::HepMC::FourVector(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
}

static void constructor_15216( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::FourVector(*(double*)arg[0]);
  else ::new(mem) ::HepMC::FourVector(*(double*)arg[0]);
}

static void constructor_15217( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::FourVector();
  else ::new(mem) ::HepMC::FourVector();
}

static void constructor_15218( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::FourVector(*(const ::HepMC::FourVector*)arg[0]);
  else ::new(mem) ::HepMC::FourVector(*(const ::HepMC::FourVector*)arg[0]);
}

static  void method_15219( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->swap)(*(::HepMC::FourVector*)arg[0]);
}

static  void method_15220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->px)());
  else   (((const ::HepMC::FourVector*)o)->px)();
}

static  void method_15221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->py)());
  else   (((const ::HepMC::FourVector*)o)->py)();
}

static  void method_15222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->pz)());
  else   (((const ::HepMC::FourVector*)o)->pz)();
}

static  void method_15223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->e)());
  else   (((const ::HepMC::FourVector*)o)->e)();
}

static  void method_15224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->x)());
  else   (((const ::HepMC::FourVector*)o)->x)();
}

static  void method_15225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->y)());
  else   (((const ::HepMC::FourVector*)o)->y)();
}

static  void method_15226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->z)());
  else   (((const ::HepMC::FourVector*)o)->z)();
}

static  void method_15227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->t)());
  else   (((const ::HepMC::FourVector*)o)->t)();
}

static  void method_15228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->m2)());
  else   (((const ::HepMC::FourVector*)o)->m2)();
}

static  void method_15229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->m)());
  else   (((const ::HepMC::FourVector*)o)->m)();
}

static  void method_15230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->perp2)());
  else   (((const ::HepMC::FourVector*)o)->perp2)();
}

static  void method_15231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->perp)());
  else   (((const ::HepMC::FourVector*)o)->perp)();
}

static  void method_15232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->theta)());
  else   (((const ::HepMC::FourVector*)o)->theta)();
}

static  void method_15233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->phi)());
  else   (((const ::HepMC::FourVector*)o)->phi)();
}

static  void method_15234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->rho)());
  else   (((const ::HepMC::FourVector*)o)->rho)();
}

static  void operator_15235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::FourVector*)o)->operator=)(*(const ::HepMC::FourVector*)arg[0]);
  else   (((::HepMC::FourVector*)o)->operator=)(*(const ::HepMC::FourVector*)arg[0]);
}

static  void operator_15236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::FourVector*)o)->operator==)(*(const ::HepMC::FourVector*)arg[0]));
  else   (((const ::HepMC::FourVector*)o)->operator==)(*(const ::HepMC::FourVector*)arg[0]);
}

static  void operator_15237( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::FourVector*)o)->operator!=)(*(const ::HepMC::FourVector*)arg[0]));
  else   (((const ::HepMC::FourVector*)o)->operator!=)(*(const ::HepMC::FourVector*)arg[0]);
}

static  void method_15238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->pseudoRapidity)());
  else   (((const ::HepMC::FourVector*)o)->pseudoRapidity)();
}

static  void method_15239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::FourVector*)o)->eta)());
  else   (((const ::HepMC::FourVector*)o)->eta)();
}

static  void method_15240( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->set)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]);
}

static  void method_15241( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setX)(*(double*)arg[0]);
}

static  void method_15242( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setY)(*(double*)arg[0]);
}

static  void method_15243( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setZ)(*(double*)arg[0]);
}

static  void method_15244( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setT)(*(double*)arg[0]);
}

static  void method_15245( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setPx)(*(double*)arg[0]);
}

static  void method_15246( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setPy)(*(double*)arg[0]);
}

static  void method_15247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setPz)(*(double*)arg[0]);
}

static  void method_15248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::FourVector*)o)->setE)(*(double*)arg[0]);
}

static void method_newdel_3455( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::FourVector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::FourVector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::FourVector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::FourVector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::FourVector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FourVector -------------------------------
void __HepMC__FourVector_db_datamem(Reflex::Class*);
void __HepMC__FourVector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__FourVector_datamem_bld(&__HepMC__FourVector_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__FourVector_funcmem_bld(&__HepMC__FourVector_db_funcmem);
void __HepMC__FourVector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::FourVector"), typeid(::HepMC::FourVector), sizeof(::HepMC::FourVector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FourVector"), destructor_15214, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_102, type_102, type_102, type_102), Reflex::Literal("FourVector"), constructor_15215, 0, "xin;yin;zin;tin=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_102), Reflex::Literal("FourVector"), constructor_15216, 0, "tin", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FourVector"), constructor_15217, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24800), Reflex::Literal("FourVector"), constructor_15218, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3455, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__FourVector_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__FourVector_funcmem_bld);
}

//------Delayed data member builder for class FourVector -------------------
void __HepMC__FourVector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_102, Reflex::Literal("m_x"), OffsetOf(__shadow__::__HepMC__FourVector, m_x), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_y"), OffsetOf(__shadow__::__HepMC__FourVector, m_y), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_z"), OffsetOf(__shadow__::__HepMC__FourVector, m_z), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_t"), OffsetOf(__shadow__::__HepMC__FourVector, m_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FourVector -------------------
void __HepMC__FourVector_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24875), Reflex::Literal("swap"), method_15219, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("px"), method_15220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("py"), method_15221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("pz"), method_15222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("e"), method_15223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("x"), method_15224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("y"), method_15225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("z"), method_15226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("t"), method_15227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("m2"), method_15228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("m"), method_15229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("perp2"), method_15230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("perp"), method_15231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("theta"), method_15232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("phi"), method_15233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("rho"), method_15234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24875, type_24800), Reflex::Literal("operator="), operator_15235, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24800), Reflex::Literal("operator=="), operator_15236, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24800), Reflex::Literal("operator!="), operator_15237, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("pseudoRapidity"), method_15238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("eta"), method_15239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102, type_102, type_102, type_102), Reflex::Literal("set"), method_15240, 0, "xin;yin;zin;tin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setX"), method_15241, 0, "xin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setY"), method_15242, 0, "yin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setZ"), method_15243, 0, "zin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setT"), method_15244, 0, "tin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setPx"), method_15245, 0, "xin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setPy"), method_15246, 0, "yin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setPz"), method_15247, 0, "zin", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("setE"), method_15248, 0, "tin", ::Reflex::PUBLIC);
}
//------Stub functions for class HeavyIon -------------------------------
static void constructor_15296( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon();
  else ::new(mem) ::HepMC::HeavyIon();
}

static void constructor_15297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 6 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9],
      *(float*)arg[10]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9],
      *(float*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9],
      *(float*)arg[10],
      *(float*)arg[11]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9],
      *(float*)arg[10],
      *(float*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9],
      *(float*)arg[10],
      *(float*)arg[11],
      *(float*)arg[12]);
  else ::new(mem) ::HepMC::HeavyIon(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7],
      *(int*)arg[8],
      *(float*)arg[9],
      *(float*)arg[10],
      *(float*)arg[11],
      *(float*)arg[12]);
  }
}

static void destructor_15298(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::HeavyIon*)o)->::HepMC::HeavyIon::~HeavyIon)();
}
static void constructor_15299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::HeavyIon(*(const ::HepMC::HeavyIon*)arg[0]);
  else ::new(mem) ::HepMC::HeavyIon(*(const ::HepMC::HeavyIon*)arg[0]);
}

static  void operator_15300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::HeavyIon*)o)->operator=)(*(const ::HepMC::HeavyIon*)arg[0]);
  else   (((::HepMC::HeavyIon*)o)->operator=)(*(const ::HepMC::HeavyIon*)arg[0]);
}

static  void method_15301( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->swap)(*(::HepMC::HeavyIon*)arg[0]);
}

static  void operator_15302( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::HeavyIon*)o)->operator==)(*(const ::HepMC::HeavyIon*)arg[0]));
  else   (((const ::HepMC::HeavyIon*)o)->operator==)(*(const ::HepMC::HeavyIon*)arg[0]);
}

static  void operator_15303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::HeavyIon*)o)->operator!=)(*(const ::HepMC::HeavyIon*)arg[0]));
  else   (((const ::HepMC::HeavyIon*)o)->operator!=)(*(const ::HepMC::HeavyIon*)arg[0]);
}

static  void method_15304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->Ncoll_hard)());
  else   (((const ::HepMC::HeavyIon*)o)->Ncoll_hard)();
}

static  void method_15305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->Npart_proj)());
  else   (((const ::HepMC::HeavyIon*)o)->Npart_proj)();
}

static  void method_15306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->Npart_targ)());
  else   (((const ::HepMC::HeavyIon*)o)->Npart_targ)();
}

static  void method_15307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->Ncoll)());
  else   (((const ::HepMC::HeavyIon*)o)->Ncoll)();
}

static  void method_15308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->spectator_neutrons)());
  else   (((const ::HepMC::HeavyIon*)o)->spectator_neutrons)();
}

static  void method_15309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->spectator_protons)());
  else   (((const ::HepMC::HeavyIon*)o)->spectator_protons)();
}

static  void method_15310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->N_Nwounded_collisions)());
  else   (((const ::HepMC::HeavyIon*)o)->N_Nwounded_collisions)();
}

static  void method_15311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->Nwounded_N_collisions)());
  else   (((const ::HepMC::HeavyIon*)o)->Nwounded_N_collisions)();
}

static  void method_15312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::HeavyIon*)o)->Nwounded_Nwounded_collisions)());
  else   (((const ::HepMC::HeavyIon*)o)->Nwounded_Nwounded_collisions)();
}

static  void method_15313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HepMC::HeavyIon*)o)->impact_parameter)());
  else   (((const ::HepMC::HeavyIon*)o)->impact_parameter)();
}

static  void method_15314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HepMC::HeavyIon*)o)->event_plane_angle)());
  else   (((const ::HepMC::HeavyIon*)o)->event_plane_angle)();
}

static  void method_15315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HepMC::HeavyIon*)o)->eccentricity)());
  else   (((const ::HepMC::HeavyIon*)o)->eccentricity)();
}

static  void method_15316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HepMC::HeavyIon*)o)->sigma_inel_NN)());
  else   (((const ::HepMC::HeavyIon*)o)->sigma_inel_NN)();
}

static  void method_15317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::HeavyIon*)o)->is_valid)());
  else   (((const ::HepMC::HeavyIon*)o)->is_valid)();
}

static  void method_15318( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_Ncoll_hard)(*(const int*)arg[0]);
}

static  void method_15319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_Npart_proj)(*(const int*)arg[0]);
}

static  void method_15320( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_Npart_targ)(*(const int*)arg[0]);
}

static  void method_15321( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_Ncoll)(*(const int*)arg[0]);
}

static  void method_15322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_spectator_neutrons)(*(const int*)arg[0]);
}

static  void method_15323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_spectator_protons)(*(const int*)arg[0]);
}

static  void method_15324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_N_Nwounded_collisions)(*(const int*)arg[0]);
}

static  void method_15325( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_Nwounded_N_collisions)(*(const int*)arg[0]);
}

static  void method_15326( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_Nwounded_Nwounded_collisions)(*(const int*)arg[0]);
}

static  void method_15327( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_impact_parameter)(*(const float*)arg[0]);
}

static  void method_15328( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_event_plane_angle)(*(const float*)arg[0]);
}

static  void method_15329( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_eccentricity)(*(const float*)arg[0]);
}

static  void method_15330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::HeavyIon*)o)->set_sigma_inel_NN)(*(const float*)arg[0]);
}

static void method_newdel_3459( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::HeavyIon >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::HeavyIon >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::HeavyIon >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::HeavyIon >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::HeavyIon >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HeavyIon -------------------------------
void __HepMC__HeavyIon_db_datamem(Reflex::Class*);
void __HepMC__HeavyIon_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__HeavyIon_datamem_bld(&__HepMC__HeavyIon_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__HeavyIon_funcmem_bld(&__HepMC__HeavyIon_db_funcmem);
void __HepMC__HeavyIon_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::HeavyIon"), typeid(::HepMC::HeavyIon), sizeof(::HepMC::HeavyIon), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HeavyIon"), constructor_15296, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_67, type_67, type_67, type_67, type_67, type_67, type_67, type_67, type_67, type_796, type_796, type_796, type_796), Reflex::Literal("HeavyIon"), constructor_15297, 0, "nh;np;nt;nc;ns;nsp;nnw=0;nwn=0;nwnw=0;im=0.0;pl=0.0;ec=0.0;s=0.0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HeavyIon"), destructor_15298, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24880), Reflex::Literal("HeavyIon"), constructor_15299, 0, "orig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3459, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__HeavyIon_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__HeavyIon_funcmem_bld);
}

//------Delayed data member builder for class HeavyIon -------------------
void __HepMC__HeavyIon_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67, Reflex::Literal("m_Ncoll_hard"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_Ncoll_hard), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_Npart_proj"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_Npart_proj), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_Npart_targ"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_Npart_targ), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_Ncoll"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_Ncoll), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_spectator_neutrons"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_spectator_neutrons), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_spectator_protons"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_spectator_protons), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_N_Nwounded_collisions"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_N_Nwounded_collisions), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_Nwounded_N_collisions"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_Nwounded_N_collisions), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_Nwounded_Nwounded_collisions"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_Nwounded_Nwounded_collisions), ::Reflex::PRIVATE)
  .AddDataMember(type_796, Reflex::Literal("m_impact_parameter"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_impact_parameter), ::Reflex::PRIVATE)
  .AddDataMember(type_796, Reflex::Literal("m_event_plane_angle"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_event_plane_angle), ::Reflex::PRIVATE)
  .AddDataMember(type_796, Reflex::Literal("m_eccentricity"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_eccentricity), ::Reflex::PRIVATE)
  .AddDataMember(type_796, Reflex::Literal("m_sigma_inel_NN"), OffsetOf(__shadow__::__HepMC__HeavyIon, m_sigma_inel_NN), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HeavyIon -------------------
void __HepMC__HeavyIon_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24881, type_24880), Reflex::Literal("operator="), operator_15300, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24881), Reflex::Literal("swap"), method_15301, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24880), Reflex::Literal("operator=="), operator_15302, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24880), Reflex::Literal("operator!="), operator_15303, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("Ncoll_hard"), method_15304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("Npart_proj"), method_15305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("Npart_targ"), method_15306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("Ncoll"), method_15307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("spectator_neutrons"), method_15308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("spectator_protons"), method_15309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("N_Nwounded_collisions"), method_15310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("Nwounded_N_collisions"), method_15311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("Nwounded_Nwounded_collisions"), method_15312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_796), Reflex::Literal("impact_parameter"), method_15313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_796), Reflex::Literal("event_plane_angle"), method_15314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_796), Reflex::Literal("eccentricity"), method_15315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_796), Reflex::Literal("sigma_inel_NN"), method_15316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("is_valid"), method_15317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_Ncoll_hard"), method_15318, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_Npart_proj"), method_15319, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_Npart_targ"), method_15320, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_Ncoll"), method_15321, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_spectator_neutrons"), method_15322, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_spectator_protons"), method_15323, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_N_Nwounded_collisions"), method_15324, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_Nwounded_N_collisions"), method_15325, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10150), Reflex::Literal("set_Nwounded_Nwounded_collisions"), method_15326, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10408), Reflex::Literal("set_impact_parameter"), method_15327, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10408), Reflex::Literal("set_event_plane_angle"), method_15328, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10408), Reflex::Literal("set_eccentricity"), method_15329, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_10408), Reflex::Literal("set_sigma_inel_NN"), method_15330, 0, "f", ::Reflex::PUBLIC);
}
//------Stub functions for class WeightContainer -------------------------------
static void constructor_15355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::WeightContainer();
  else ::new(mem) ::HepMC::WeightContainer();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::WeightContainer(*(::std::size_t*)arg[0]);
  else ::new(mem) ::HepMC::WeightContainer(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::WeightContainer(*(::std::size_t*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::HepMC::WeightContainer(*(::std::size_t*)arg[0],
      *(double*)arg[1]);
  }
}

static void constructor_15356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::WeightContainer(*(const ::std::vector<double>*)arg[0]);
  else ::new(mem) ::HepMC::WeightContainer(*(const ::std::vector<double>*)arg[0]);
}

static void constructor_15357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::WeightContainer(*(const ::HepMC::WeightContainer*)arg[0]);
  else ::new(mem) ::HepMC::WeightContainer(*(const ::HepMC::WeightContainer*)arg[0]);
}

static void destructor_15358(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::WeightContainer*)o)->::HepMC::WeightContainer::~WeightContainer)();
}
static  void method_15359( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::WeightContainer*)o)->swap)(*(::HepMC::WeightContainer*)arg[0]);
}

static  void operator_15360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::WeightContainer*)o)->operator=)(*(const ::HepMC::WeightContainer*)arg[0]);
  else   (((::HepMC::WeightContainer*)o)->operator=)(*(const ::HepMC::WeightContainer*)arg[0]);
}

static  void operator_15361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::WeightContainer*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
  else   (((::HepMC::WeightContainer*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_15362( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::WeightContainer*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::WeightContainer*)o)->print)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15363( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::WeightContainer*)o)->write)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::WeightContainer*)o)->write)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::HepMC::WeightContainer*)o)->size)());
  else   (((const ::HepMC::WeightContainer*)o)->size)();
}

static  void method_15365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::WeightContainer*)o)->empty)());
  else   (((const ::HepMC::WeightContainer*)o)->empty)();
}

static  void method_15366( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::WeightContainer*)o)->push_back)(*(const double*)arg[0]);
}

static  void method_15367( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HepMC::WeightContainer*)o)->pop_back)();
}

static  void method_15368( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HepMC::WeightContainer*)o)->clear)();
}

static  void method_15369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::WeightContainer*)o)->has_key)(*(const ::std::string*)arg[0]));
  else   (((const ::HepMC::WeightContainer*)o)->has_key)(*(const ::std::string*)arg[0]);
}

static  void operator_15370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::WeightContainer*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::HepMC::WeightContainer*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_15371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::WeightContainer*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::HepMC::WeightContainer*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_15372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::WeightContainer*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((::HepMC::WeightContainer*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_15373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::WeightContainer*)o)->operator[])(*(const ::std::string*)arg[0]);
  else   (((const ::HepMC::WeightContainer*)o)->operator[])(*(const ::std::string*)arg[0]);
}

static  void operator_15374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::WeightContainer*)o)->operator==)(*(const ::HepMC::WeightContainer*)arg[0]));
  else   (((const ::HepMC::WeightContainer*)o)->operator==)(*(const ::HepMC::WeightContainer*)arg[0]);
}

static  void operator_15375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::WeightContainer*)o)->operator!=)(*(const ::HepMC::WeightContainer*)arg[0]));
  else   (((const ::HepMC::WeightContainer*)o)->operator!=)(*(const ::HepMC::WeightContainer*)arg[0]);
}

static  void method_15376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::WeightContainer*)o)->front)();
  else   (((::HepMC::WeightContainer*)o)->front)();
}

static  void method_15377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::WeightContainer*)o)->front)();
  else   (((const ::HepMC::WeightContainer*)o)->front)();
}

static  void method_15378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::WeightContainer*)o)->back)();
  else   (((::HepMC::WeightContainer*)o)->back)();
}

static  void method_15379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::WeightContainer*)o)->back)();
  else   (((const ::HepMC::WeightContainer*)o)->back)();
}

static  void method_15380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::HepMC::WeightContainer*)o)->begin)());
  else   (((::HepMC::WeightContainer*)o)->begin)();
}

static  void method_15381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::HepMC::WeightContainer*)o)->end)());
  else   (((::HepMC::WeightContainer*)o)->end)();
}

static  void method_15382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::HepMC::WeightContainer*)o)->begin)());
  else   (((const ::HepMC::WeightContainer*)o)->begin)();
}

static  void method_15383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::HepMC::WeightContainer*)o)->end)());
  else   (((const ::HepMC::WeightContainer*)o)->end)();
}

static void constructor_x50( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::WeightContainer();
  else ::new(mem) ::HepMC::WeightContainer();
}

static void method_newdel_3474( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::WeightContainer >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::WeightContainer >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::WeightContainer >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::WeightContainer >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::WeightContainer >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___HepMC__WeightContainer_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_m_weights = oldObj->GetId("m_weights");
#endif
  struct __HepMC__WeightContainer_Onfile {
    std::vector<double> &m_weights;
    __HepMC__WeightContainer_Onfile( std::vector<double> &onfile_m_weights ): m_weights(onfile_m_weights){}
  };
  static Long_t offset_Onfile___HepMC__WeightContainer_m_weights = oldObj->GetClass()->GetDataMemberOffset("m_weights");
  char *onfile_add = (char*)oldObj->GetObject();
  __HepMC__WeightContainer_Onfile onfile(
         *(std::vector<double>*)(onfile_add+offset_Onfile___HepMC__WeightContainer_m_weights) );

  std::map<std::basic_string<char>,unsigned long> &m_names = *(std::map<std::basic_string<char>,unsigned long>*)(target + OffsetOf(__shadow__::__HepMC__WeightContainer, m_names));

  //--- User's code ---
   hepmc_rootio::weightcontainer_set_default_names(onfile.m_weights.size(),m_names);
   
}

//------Dictionary for class WeightContainer -------------------------------
void __HepMC__WeightContainer_db_datamem(Reflex::Class*);
void __HepMC__WeightContainer_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__WeightContainer_datamem_bld(&__HepMC__WeightContainer_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__WeightContainer_funcmem_bld(&__HepMC__WeightContainer_db_funcmem);
void __HepMC__WeightContainer_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "HepMC::WeightContainer";
  rule->fTarget      = "m_names";
  rule->fSource      = "std::vector<double> m_weights";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___HepMC__WeightContainer_0);
  rule->fCode        = "\n   hepmc_rootio::weightcontainer_set_default_names(onfile.m_weights.size(),m_names);\n   \n";
  rule->fVersion     = "[1-10]";
  rule->fInclude     = "iostream";


  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::WeightContainer"), typeid(::HepMC::WeightContainer), sizeof(::HepMC::WeightContainer), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddProperty("ioread", readrules )
  .AddTypedef(type_3033, Reflex::Literal("HepMC::WeightContainer::size_type"))
  .AddTypedef(type_5436, Reflex::Literal("HepMC::WeightContainer::iterator"))
  .AddTypedef(type_5435, Reflex::Literal("HepMC::WeightContainer::const_iterator"))
  .AddTypedef(type_2894, Reflex::Literal("HepMC::WeightContainer::map_iterator"))
  .AddTypedef(type_2598, Reflex::Literal("HepMC::WeightContainer::const_map_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3033, type_102), Reflex::Literal("WeightContainer"), constructor_15355, 0, "n=0;value=0.0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9222), Reflex::Literal("WeightContainer"), constructor_15356, 0, "weights", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24888), Reflex::Literal("WeightContainer"), constructor_15357, 0, "in", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~WeightContainer"), destructor_15358, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("WeightContainer"), constructor_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3474, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__WeightContainer_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__WeightContainer_funcmem_bld);
}

//------Delayed data member builder for class WeightContainer -------------------
void __HepMC__WeightContainer_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2807, Reflex::Literal("m_weights"), OffsetOf(__shadow__::__HepMC__WeightContainer, m_weights), ::Reflex::PRIVATE)
  .AddDataMember(type_2954, Reflex::Literal("m_names"), OffsetOf(__shadow__::__HepMC__WeightContainer, m_names), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class WeightContainer -------------------
void __HepMC__WeightContainer_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24889), Reflex::Literal("swap"), method_15359, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24889, type_24888), Reflex::Literal("operator="), operator_15360, 0, "in", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24889, type_9222), Reflex::Literal("operator="), operator_15361, 0, "in", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("print"), method_15362, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("write"), method_15363, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_15364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_15365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6881), Reflex::Literal("push_back"), method_15366, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("pop_back"), method_15367, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_15368, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_12177), Reflex::Literal("has_key"), method_15369, 0, "s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6891, type_3033), Reflex::Literal("operator[]"), operator_15370, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881, type_3033), Reflex::Literal("operator[]"), operator_15371, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6891, type_12177), Reflex::Literal("operator[]"), operator_15372, 0, "s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881, type_12177), Reflex::Literal("operator[]"), operator_15373, 0, "s", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24888), Reflex::Literal("operator=="), operator_15374, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24888), Reflex::Literal("operator!="), operator_15375, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6891), Reflex::Literal("front"), method_15376, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881), Reflex::Literal("front"), method_15377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6891), Reflex::Literal("back"), method_15378, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6881), Reflex::Literal("back"), method_15379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5436), Reflex::Literal("begin"), method_15380, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5436), Reflex::Literal("end"), method_15381, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5435), Reflex::Literal("begin"), method_15382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5435), Reflex::Literal("end"), method_15383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Polarization -------------------------------
static void constructor_15392( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Polarization();
  else ::new(mem) ::HepMC::Polarization();
}

static void constructor_15393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Polarization(*(double*)arg[0]);
  else ::new(mem) ::HepMC::Polarization(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Polarization(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::HepMC::Polarization(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static void constructor_15394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Polarization(*(const ::HepMC::Polarization*)arg[0]);
  else ::new(mem) ::HepMC::Polarization(*(const ::HepMC::Polarization*)arg[0]);
}

static void constructor_15395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::Polarization(*(const ::HepMC::ThreeVector*)arg[0]);
  else ::new(mem) ::HepMC::Polarization(*(const ::HepMC::ThreeVector*)arg[0]);
}

static void destructor_15396(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::Polarization*)o)->::HepMC::Polarization::~Polarization)();
}
static  void method_15397( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::Polarization*)o)->swap)(*(::HepMC::Polarization*)arg[0]);
}

static  void operator_15398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::Polarization*)o)->operator=)(*(const ::HepMC::Polarization*)arg[0]);
  else   (((::HepMC::Polarization*)o)->operator=)(*(const ::HepMC::Polarization*)arg[0]);
}

static  void operator_15399( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::Polarization*)o)->operator==)(*(const ::HepMC::Polarization*)arg[0]));
  else   (((const ::HepMC::Polarization*)o)->operator==)(*(const ::HepMC::Polarization*)arg[0]);
}

static  void operator_15400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::Polarization*)o)->operator!=)(*(const ::HepMC::Polarization*)arg[0]));
  else   (((const ::HepMC::Polarization*)o)->operator!=)(*(const ::HepMC::Polarization*)arg[0]);
}

static  void method_15401( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::Polarization*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::Polarization*)o)->print)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::Polarization*)o)->theta)());
  else   (((const ::HepMC::Polarization*)o)->theta)();
}

static  void method_15403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::Polarization*)o)->phi)());
  else   (((const ::HepMC::Polarization*)o)->phi)();
}

static  void method_15404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::ThreeVector)((((const ::HepMC::Polarization*)o)->normal3d)());
  else   (((const ::HepMC::Polarization*)o)->normal3d)();
}

static  void method_15405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::Polarization*)o)->is_defined)());
  else   (((const ::HepMC::Polarization*)o)->is_defined)();
}

static  void method_15406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::HepMC::Polarization*)o)->set_theta)(*(double*)arg[0]));
  else   (((::HepMC::Polarization*)o)->set_theta)(*(double*)arg[0]);
}

static  void method_15407( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::HepMC::Polarization*)o)->set_phi)(*(double*)arg[0]));
  else   (((::HepMC::Polarization*)o)->set_phi)(*(double*)arg[0]);
}

static  void method_15408( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::Polarization*)o)->set_theta_phi)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_15409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::ThreeVector)((((::HepMC::Polarization*)o)->set_normal3d)(*(const ::HepMC::ThreeVector*)arg[0]));
  else   (((::HepMC::Polarization*)o)->set_normal3d)(*(const ::HepMC::ThreeVector*)arg[0]);
}

static  void method_15410( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HepMC::Polarization*)o)->set_undefined)();
}

static void method_newdel_3475( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::Polarization >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::Polarization >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::Polarization >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::Polarization >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::Polarization >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___HepMC__Polarization_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  bool &m_defined = *(bool*)(target + OffsetOf(__shadow__::__HepMC__Polarization, m_defined));

  //--- User's code ---
   m_defined=true;
   
}

//------Dictionary for class Polarization -------------------------------
void __HepMC__Polarization_db_datamem(Reflex::Class*);
void __HepMC__Polarization_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__Polarization_datamem_bld(&__HepMC__Polarization_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__Polarization_funcmem_bld(&__HepMC__Polarization_db_funcmem);
void __HepMC__Polarization_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "HepMC::Polarization";
  rule->fTarget      = "m_defined";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___HepMC__Polarization_0);
  rule->fCode        = "\n   m_defined=true;\n   \n";
  rule->fVersion     = "[1-10]";


  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::Polarization"), typeid(::HepMC::Polarization), sizeof(::HepMC::Polarization), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Polarization"), constructor_15392, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_102, type_102), Reflex::Literal("Polarization"), constructor_15393, 0, "theta;phi=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15335), Reflex::Literal("Polarization"), constructor_15394, 0, "inpolar", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24878), Reflex::Literal("Polarization"), constructor_15395, 0, "vec3in", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Polarization"), destructor_15396, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3475, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__Polarization_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__Polarization_funcmem_bld);
}

//------Delayed data member builder for class Polarization -------------------
void __HepMC__Polarization_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_102, Reflex::Literal("m_theta"), OffsetOf(__shadow__::__HepMC__Polarization, m_theta), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_phi"), OffsetOf(__shadow__::__HepMC__Polarization, m_phi), ::Reflex::PRIVATE)
  .AddDataMember(type_1441, Reflex::Literal("m_defined"), OffsetOf(__shadow__::__HepMC__Polarization, m_defined), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Polarization -------------------
void __HepMC__Polarization_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24890), Reflex::Literal("swap"), method_15397, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24890, type_15335), Reflex::Literal("operator="), operator_15398, 0, "inpolar", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15335), Reflex::Literal("operator=="), operator_15399, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15335), Reflex::Literal("operator!="), operator_15400, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("print"), method_15401, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("theta"), method_15402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("phi"), method_15403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3458), Reflex::Literal("normal3d"), method_15404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("is_defined"), method_15405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102, type_102), Reflex::Literal("set_theta"), method_15406, 0, "theta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102, type_102), Reflex::Literal("set_phi"), method_15407, 0, "phi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102, type_102), Reflex::Literal("set_theta_phi"), method_15408, 0, "theta;phi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3458, type_24878), Reflex::Literal("set_normal3d"), method_15409, 0, "vec3in", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("set_undefined"), method_15410, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class GenVertex -------------------------------
static void constructor_15462( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenVertex();
  else ::new(mem) ::HepMC::GenVertex();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::FourVector*)arg[0]);
  else ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::FourVector*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(const ::HepMC::WeightContainer*)arg[2]);
  else ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::FourVector*)arg[0],
      *(int*)arg[1],
      *(const ::HepMC::WeightContainer*)arg[2]);
  }
}

static void constructor_15463( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::GenVertex*)arg[0]);
  else ::new(mem) ::HepMC::GenVertex(*(const ::HepMC::GenVertex*)arg[0]);
}

static void destructor_15464(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenVertex*)o)->::HepMC::GenVertex::~GenVertex)();
}
static  void method_15465( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenVertex*)o)->swap)(*(::HepMC::GenVertex*)arg[0]);
}

static  void operator_15466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenVertex*)o)->operator=)(*(const ::HepMC::GenVertex*)arg[0]);
  else   (((::HepMC::GenVertex*)o)->operator=)(*(const ::HepMC::GenVertex*)arg[0]);
}

static  void operator_15467( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenVertex*)o)->operator==)(*(const ::HepMC::GenVertex*)arg[0]));
  else   (((const ::HepMC::GenVertex*)o)->operator==)(*(const ::HepMC::GenVertex*)arg[0]);
}

static  void operator_15468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenVertex*)o)->operator!=)(*(const ::HepMC::GenVertex*)arg[0]));
  else   (((const ::HepMC::GenVertex*)o)->operator!=)(*(const ::HepMC::GenVertex*)arg[0]);
}

static  void method_15469( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::GenVertex*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::GenVertex*)o)->print)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenVertex*)o)->check_momentum_conservation)());
  else   (((const ::HepMC::GenVertex*)o)->check_momentum_conservation)();
}

static  void method_15471( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenVertex*)o)->add_particle_in)((::HepMC::GenParticle*)arg[0]);
}

static  void method_15472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenVertex*)o)->add_particle_out)((::HepMC::GenParticle*)arg[0]);
}

static  void method_15473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::HepMC::GenVertex*)o)->remove_particle)((::HepMC::GenParticle*)arg[0]));
  else   (((::HepMC::GenVertex*)o)->remove_particle)((::HepMC::GenParticle*)arg[0]);
}

static  void converter_15474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::FourVector)((((const ::HepMC::GenVertex*)o)->operator HepMC::FourVector)());
  else   (((const ::HepMC::GenVertex*)o)->operator HepMC::FourVector)();
}

static  void converter_15475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::ThreeVector)((((const ::HepMC::GenVertex*)o)->operator HepMC::ThreeVector)());
  else   (((const ::HepMC::GenVertex*)o)->operator HepMC::ThreeVector)();
}

static  void method_15476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenVertex*)o)->parent_event)());
  else   (((const ::HepMC::GenVertex*)o)->parent_event)();
}

static  void method_15477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::ThreeVector)((((const ::HepMC::GenVertex*)o)->point3d)());
  else   (((const ::HepMC::GenVertex*)o)->point3d)();
}

static  void method_15478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenVertex*)o)->position)();
  else   (((const ::HepMC::GenVertex*)o)->position)();
}

static  void method_15479( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::HepMC::GenVertex*)o)->set_position)();
  }
  else if ( arg.size() == 1 ) { 
    (((::HepMC::GenVertex*)o)->set_position)(*(const ::HepMC::FourVector*)arg[0]);
  }
}

static  void method_15480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenVertex*)o)->id)());
  else   (((const ::HepMC::GenVertex*)o)->id)();
}

static  void method_15481( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenVertex*)o)->set_id)(*(int*)arg[0]);
}

static  void method_15482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenVertex*)o)->barcode)());
  else   (((const ::HepMC::GenVertex*)o)->barcode)();
}

static  void method_15483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HepMC::GenVertex*)o)->suggest_barcode)(*(int*)arg[0]));
  else   (((::HepMC::GenVertex*)o)->suggest_barcode)(*(int*)arg[0]);
}

static  void method_15484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenVertex*)o)->weights)();
  else   (((::HepMC::GenVertex*)o)->weights)();
}

static  void method_15485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenVertex*)o)->weights)();
  else   (((const ::HepMC::GenVertex*)o)->weights)();
}

static  void method_15486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::GenVertexParticleRange)((((::HepMC::GenVertex*)o)->particles)());
    else     (((::HepMC::GenVertex*)o)->particles)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::GenVertexParticleRange)((((::HepMC::GenVertex*)o)->particles)(*(::HepMC::IteratorRange*)arg[0]));
    else     (((::HepMC::GenVertex*)o)->particles)(*(::HepMC::IteratorRange*)arg[0]);
  }
}

static  void method_15487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (HepMC::GenParticleProductionRange)((((::HepMC::GenVertex*)o)->particles_in)(*(::HepMC::GenParticle*)arg[0]));
    else     (((::HepMC::GenVertex*)o)->particles_in)(*(::HepMC::GenParticle*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (HepMC::GenParticleProductionRange)((((::HepMC::GenVertex*)o)->particles_in)(*(::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]));
    else     (((::HepMC::GenVertex*)o)->particles_in)(*(::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]);
  }
}

static  void method_15488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleProductionRange)((((const ::HepMC::GenVertex*)o)->particles_in)(*(const ::HepMC::GenParticle*)arg[0]));
    else     (((const ::HepMC::GenVertex*)o)->particles_in)(*(const ::HepMC::GenParticle*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleProductionRange)((((const ::HepMC::GenVertex*)o)->particles_in)(*(const ::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]));
    else     (((const ::HepMC::GenVertex*)o)->particles_in)(*(const ::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]);
  }
}

static  void method_15489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (HepMC::GenParticleEndRange)((((::HepMC::GenVertex*)o)->particles_out)(*(::HepMC::GenParticle*)arg[0]));
    else     (((::HepMC::GenVertex*)o)->particles_out)(*(::HepMC::GenParticle*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (HepMC::GenParticleEndRange)((((::HepMC::GenVertex*)o)->particles_out)(*(::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]));
    else     (((::HepMC::GenVertex*)o)->particles_out)(*(::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]);
  }
}

static  void method_15490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleEndRange)((((const ::HepMC::GenVertex*)o)->particles_out)(*(const ::HepMC::GenParticle*)arg[0]));
    else     (((const ::HepMC::GenVertex*)o)->particles_out)(*(const ::HepMC::GenParticle*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (HepMC::ConstGenParticleEndRange)((((const ::HepMC::GenVertex*)o)->particles_out)(*(const ::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]));
    else     (((const ::HepMC::GenVertex*)o)->particles_out)(*(const ::HepMC::GenParticle*)arg[0],
      *(::HepMC::IteratorRange*)arg[1]);
  }
}

static  void method_15491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> >)((((const ::HepMC::GenVertex*)o)->particles_in_const_begin)());
  else   (((const ::HepMC::GenVertex*)o)->particles_in_const_begin)();
}

static  void method_15492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> >)((((const ::HepMC::GenVertex*)o)->particles_in_const_end)());
  else   (((const ::HepMC::GenVertex*)o)->particles_in_const_end)();
}

static  void method_15493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> >)((((const ::HepMC::GenVertex*)o)->particles_out_const_begin)());
  else   (((const ::HepMC::GenVertex*)o)->particles_out_const_begin)();
}

static  void method_15494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HepMC::GenParticle* const*,std::vector<HepMC::GenParticle*> >)((((const ::HepMC::GenVertex*)o)->particles_out_const_end)());
  else   (((const ::HepMC::GenVertex*)o)->particles_out_const_end)();
}

static  void method_15495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenVertex*)o)->particles_in_size)());
  else   (((const ::HepMC::GenVertex*)o)->particles_in_size)();
}

static  void method_15496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenVertex*)o)->particles_out_size)());
  else   (((const ::HepMC::GenVertex*)o)->particles_out_size)();
}

static  void method_15503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::GenVertex::vertex_iterator)((((::HepMC::GenVertex*)o)->vertices_begin)());
    else     (((::HepMC::GenVertex*)o)->vertices_begin)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::GenVertex::vertex_iterator)((((::HepMC::GenVertex*)o)->vertices_begin)(*(::HepMC::IteratorRange*)arg[0]));
    else     (((::HepMC::GenVertex*)o)->vertices_begin)(*(::HepMC::IteratorRange*)arg[0]);
  }
}

static  void method_15504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenVertex::vertex_iterator)((((::HepMC::GenVertex*)o)->vertices_end)(*(::HepMC::IteratorRange*)arg[0]));
  else   (((::HepMC::GenVertex*)o)->vertices_end)(*(::HepMC::IteratorRange*)arg[0]);
}

static  void method_15505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (HepMC::GenVertex::particle_iterator)((((::HepMC::GenVertex*)o)->particles_begin)());
    else     (((::HepMC::GenVertex*)o)->particles_begin)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (HepMC::GenVertex::particle_iterator)((((::HepMC::GenVertex*)o)->particles_begin)(*(::HepMC::IteratorRange*)arg[0]));
    else     (((::HepMC::GenVertex*)o)->particles_begin)(*(::HepMC::IteratorRange*)arg[0]);
  }
}

static  void method_15506( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenVertex::particle_iterator)((((::HepMC::GenVertex*)o)->particles_end)(*(::HepMC::IteratorRange*)arg[0]));
  else   (((::HepMC::GenVertex*)o)->particles_end)(*(::HepMC::IteratorRange*)arg[0]);
}

static void constructor_x53( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenVertex();
  else ::new(mem) ::HepMC::GenVertex();
}

static void method_newdel_3482( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenVertex >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenVertex >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenVertex >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenVertex >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenVertex >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenVertex -------------------------------
void __HepMC__GenVertex_db_datamem(Reflex::Class*);
void __HepMC__GenVertex_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenVertex_datamem_bld(&__HepMC__GenVertex_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenVertex_funcmem_bld(&__HepMC__GenVertex_db_funcmem);
void __HepMC__GenVertex_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenVertex"), typeid(::HepMC::GenVertex), sizeof(::HepMC::GenVertex), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_5433, Reflex::Literal("HepMC::GenVertex::particles_in_const_iterator"))
  .AddTypedef(type_5433, Reflex::Literal("HepMC::GenVertex::particles_out_const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24800, type_67, type_24888), Reflex::Literal("GenVertex"), constructor_15462, 0, "position=HepMC::FourVector(0.0, 0.0, 0.0, 0.0);id=0;weights=std::vector<double, std::allocator<double> >()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15337), Reflex::Literal("GenVertex"), constructor_15463, 0, "invertex", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenVertex"), destructor_15464, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenVertex"), constructor_x53, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3482, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenVertex_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenVertex_funcmem_bld);
}

//------Delayed data member builder for class GenVertex -------------------
void __HepMC__GenVertex_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3455, Reflex::Literal("m_position"), OffsetOf(__shadow__::__HepMC__GenVertex, m_position), ::Reflex::PRIVATE)
  .AddDataMember(type_2804, Reflex::Literal("m_particles_in"), OffsetOf(__shadow__::__HepMC__GenVertex, m_particles_in), ::Reflex::PRIVATE)
  .AddDataMember(type_2804, Reflex::Literal("m_particles_out"), OffsetOf(__shadow__::__HepMC__GenVertex, m_particles_out), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_id"), OffsetOf(__shadow__::__HepMC__GenVertex, m_id), ::Reflex::PRIVATE)
  .AddDataMember(type_3474, Reflex::Literal("m_weights"), OffsetOf(__shadow__::__HepMC__GenVertex, m_weights), ::Reflex::PRIVATE)
  .AddDataMember(type_24802, Reflex::Literal("m_event"), OffsetOf(__shadow__::__HepMC__GenVertex, m_event), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_barcode"), OffsetOf(__shadow__::__HepMC__GenVertex, m_barcode), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenVertex -------------------
void __HepMC__GenVertex_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24959), Reflex::Literal("swap"), method_15465, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24959, type_15337), Reflex::Literal("operator="), operator_15466, 0, "invertex", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15337), Reflex::Literal("operator=="), operator_15467, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_15337), Reflex::Literal("operator!="), operator_15468, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("print"), method_15469, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("check_momentum_conservation"), method_15470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6865), Reflex::Literal("add_particle_in"), method_15471, 0, "inparticle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_6865), Reflex::Literal("add_particle_out"), method_15472, 0, "outparticle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6865, type_6865), Reflex::Literal("remove_particle"), method_15473, 0, "particle", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3455), Reflex::Literal("operator HepMC::FourVector"), converter_15474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3458), Reflex::Literal("operator HepMC::ThreeVector"), converter_15475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24802), Reflex::Literal("parent_event"), method_15476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3458), Reflex::Literal("point3d"), method_15477, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24800), Reflex::Literal("position"), method_15478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24800), Reflex::Literal("set_position"), method_15479, 0, "pos=HepMC::FourVector(0.0, 0.0, 0.0, 0.0)", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("id"), method_15480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("set_id"), method_15481, 0, "pid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("barcode"), method_15482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_67), Reflex::Literal("suggest_barcode"), method_15483, 0, "the_bar_code", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24889), Reflex::Literal("weights"), method_15484, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24888), Reflex::Literal("weights"), method_15485, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483, type_3457), Reflex::Literal("particles"), method_15486, 0, "range=relatives", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3481, type_24801, type_3457), Reflex::Literal("particles_in"), method_15487, 0, ";range=relatives", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3478, type_15334, type_3457), Reflex::Literal("particles_in"), method_15488, 0, ";range=relatives", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3456, type_24801, type_3457), Reflex::Literal("particles_out"), method_15489, 0, ";range=relatives", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3485, type_15334, type_3457), Reflex::Literal("particles_out"), method_15490, 0, ";range=relatives", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5433), Reflex::Literal("particles_in_const_begin"), method_15491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5433), Reflex::Literal("particles_in_const_end"), method_15492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5433), Reflex::Literal("particles_out_const_begin"), method_15493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5433), Reflex::Literal("particles_out_const_end"), method_15494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("particles_in_size"), method_15495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("particles_out_size"), method_15496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15460, type_3457), Reflex::Literal("vertices_begin"), method_15503, 0, "range=relatives", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15460, type_3457), Reflex::Literal("vertices_end"), method_15504, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15461, type_3457), Reflex::Literal("particles_begin"), method_15505, 0, "range=relatives", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15461, type_3457), Reflex::Literal("particles_end"), method_15506, 0, "", ::Reflex::PUBLIC);
}
//------Stub functions for class GenEvent -------------------------------
static void constructor_15549( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent();
  else ::new(mem) ::HepMC::GenEvent();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(::HepMC::Units::MomentumUnit*)arg[5]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(::HepMC::Units::MomentumUnit*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(::HepMC::Units::MomentumUnit*)arg[5],
      *(::HepMC::Units::LengthUnit*)arg[6]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(::HepMC::Units::MomentumUnit*)arg[5],
      *(::HepMC::Units::LengthUnit*)arg[6]);
  }
}

static void constructor_15550( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(const ::HepMC::HeavyIon*)arg[5],
      *(const ::HepMC::PdfInfo*)arg[6]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(const ::HepMC::HeavyIon*)arg[5],
      *(const ::HepMC::PdfInfo*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(const ::HepMC::HeavyIon*)arg[5],
      *(const ::HepMC::PdfInfo*)arg[6],
      *(::HepMC::Units::MomentumUnit*)arg[7]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(const ::HepMC::HeavyIon*)arg[5],
      *(const ::HepMC::PdfInfo*)arg[6],
      *(::HepMC::Units::MomentumUnit*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(const ::HepMC::HeavyIon*)arg[5],
      *(const ::HepMC::PdfInfo*)arg[6],
      *(::HepMC::Units::MomentumUnit*)arg[7],
      *(::HepMC::Units::LengthUnit*)arg[8]);
  else ::new(mem) ::HepMC::GenEvent(*(int*)arg[0],
      *(int*)arg[1],
      (::HepMC::GenVertex*)arg[2],
      *(const ::HepMC::WeightContainer*)arg[3],
      *(const ::std::vector<long>*)arg[4],
      *(const ::HepMC::HeavyIon*)arg[5],
      *(const ::HepMC::PdfInfo*)arg[6],
      *(::HepMC::Units::MomentumUnit*)arg[7],
      *(::HepMC::Units::LengthUnit*)arg[8]);
  }
}

static void constructor_15551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1]);
  else ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4]);
  else ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4],
      *(const ::HepMC::WeightContainer*)arg[5]);
  else ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4],
      *(const ::HepMC::WeightContainer*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4],
      *(const ::HepMC::WeightContainer*)arg[5],
      *(const ::std::vector<long>*)arg[6]);
  else ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4],
      *(const ::HepMC::WeightContainer*)arg[5],
      *(const ::std::vector<long>*)arg[6]);
  }
}

static void constructor_15552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4],
      *(const ::HepMC::WeightContainer*)arg[5],
      *(const ::std::vector<long>*)arg[6],
      *(const ::HepMC::HeavyIon*)arg[7],
      *(const ::HepMC::PdfInfo*)arg[8]);
  else ::new(mem) ::HepMC::GenEvent(*(::HepMC::Units::MomentumUnit*)arg[0],
      *(::HepMC::Units::LengthUnit*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      (::HepMC::GenVertex*)arg[4],
      *(const ::HepMC::WeightContainer*)arg[5],
      *(const ::std::vector<long>*)arg[6],
      *(const ::HepMC::HeavyIon*)arg[7],
      *(const ::HepMC::PdfInfo*)arg[8]);
}

static void constructor_15553( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent(*(const ::HepMC::GenEvent*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent(*(const ::HepMC::GenEvent*)arg[0]);
}

static  void operator_15554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent*)o)->operator=)(*(const ::HepMC::GenEvent*)arg[0]);
  else   (((::HepMC::GenEvent*)o)->operator=)(*(const ::HepMC::GenEvent*)arg[0]);
}

static void destructor_15555(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenEvent*)o)->::HepMC::GenEvent::~GenEvent)();
}
static  void method_15556( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->swap)(*(::HepMC::GenEvent*)arg[0]);
}

static  void method_15557( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::GenEvent*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::GenEvent*)o)->print)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15558( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::GenEvent*)o)->print_version)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::GenEvent*)o)->print_version)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent*)o)->barcode_to_particle)(*(int*)arg[0]));
  else   (((const ::HepMC::GenEvent*)o)->barcode_to_particle)(*(int*)arg[0]);
}

static  void method_15560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent*)o)->barcode_to_vertex)(*(int*)arg[0]));
  else   (((const ::HepMC::GenEvent*)o)->barcode_to_vertex)(*(int*)arg[0]);
}

static  void method_15561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenEvent*)o)->signal_process_id)());
  else   (((const ::HepMC::GenEvent*)o)->signal_process_id)();
}

static  void method_15562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenEvent*)o)->event_number)());
  else   (((const ::HepMC::GenEvent*)o)->event_number)();
}

static  void method_15563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenEvent*)o)->mpi)());
  else   (((const ::HepMC::GenEvent*)o)->mpi)();
}

static  void method_15564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenEvent*)o)->event_scale)());
  else   (((const ::HepMC::GenEvent*)o)->event_scale)();
}

static  void method_15565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenEvent*)o)->alphaQCD)());
  else   (((const ::HepMC::GenEvent*)o)->alphaQCD)();
}

static  void method_15566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HepMC::GenEvent*)o)->alphaQED)());
  else   (((const ::HepMC::GenEvent*)o)->alphaQED)();
}

static  void method_15567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent*)o)->signal_process_vertex)());
  else   (((const ::HepMC::GenEvent*)o)->signal_process_vertex)();
}

static  void method_15568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent*)o)->valid_beam_particles)());
  else   (((const ::HepMC::GenEvent*)o)->valid_beam_particles)();
}

static  void method_15569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::pair<HepMC::GenParticle*,HepMC::GenParticle*>)((((const ::HepMC::GenEvent*)o)->beam_particles)());
  else   (((const ::HepMC::GenEvent*)o)->beam_particles)();
}

static  void method_15570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent*)o)->is_valid)());
  else   (((const ::HepMC::GenEvent*)o)->is_valid)();
}

static  void method_15571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent*)o)->weights)();
  else   (((::HepMC::GenEvent*)o)->weights)();
}

static  void method_15572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenEvent*)o)->weights)();
  else   (((const ::HepMC::GenEvent*)o)->weights)();
}

static  void method_15573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent*)o)->cross_section)());
  else   (((const ::HepMC::GenEvent*)o)->cross_section)();
}

static  void method_15574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::HepMC::GenEvent*)o)->cross_section)());
  else   (((::HepMC::GenEvent*)o)->cross_section)();
}

static  void method_15575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent*)o)->heavy_ion)());
  else   (((const ::HepMC::GenEvent*)o)->heavy_ion)();
}

static  void method_15576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::HepMC::GenEvent*)o)->heavy_ion)());
  else   (((::HepMC::GenEvent*)o)->heavy_ion)();
}

static  void method_15577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent*)o)->pdf_info)());
  else   (((const ::HepMC::GenEvent*)o)->pdf_info)();
}

static  void method_15578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::HepMC::GenEvent*)o)->pdf_info)());
  else   (((::HepMC::GenEvent*)o)->pdf_info)();
}

static  void method_15579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HepMC::GenEvent*)o)->random_states)();
  else   (((const ::HepMC::GenEvent*)o)->random_states)();
}

static  void method_15580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenEvent*)o)->particles_size)());
  else   (((const ::HepMC::GenEvent*)o)->particles_size)();
}

static  void method_15581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent*)o)->particles_empty)());
  else   (((const ::HepMC::GenEvent*)o)->particles_empty)();
}

static  void method_15582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenEvent*)o)->vertices_size)());
  else   (((const ::HepMC::GenEvent*)o)->vertices_size)();
}

static  void method_15583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent*)o)->vertices_empty)());
  else   (((const ::HepMC::GenEvent*)o)->vertices_empty)();
}

static  void method_15584( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::GenEvent*)o)->write_units)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::GenEvent*)o)->write_units)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15585( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::HepMC::GenEvent*)o)->write_cross_section)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::HepMC::GenEvent*)o)->write_cross_section)(*(::std::ostream*)arg[0]);
  }
}

static  void method_15586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenEvent*)o)->momentum_unit)());
  else   (((const ::HepMC::GenEvent*)o)->momentum_unit)();
}

static  void method_15587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HepMC::GenEvent*)o)->length_unit)());
  else   (((const ::HepMC::GenEvent*)o)->length_unit)();
}

static  void method_15588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent*)o)->write)(*(::std::ostream*)arg[0]);
  else   (((::HepMC::GenEvent*)o)->write)(*(::std::ostream*)arg[0]);
}

static  void method_15589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent*)o)->read)(*(::std::istream*)arg[0]);
  else   (((::HepMC::GenEvent*)o)->read)(*(::std::istream*)arg[0]);
}

static  void method_15590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HepMC::GenEvent*)o)->add_vertex)((::HepMC::GenVertex*)arg[0]));
  else   (((::HepMC::GenEvent*)o)->add_vertex)((::HepMC::GenVertex*)arg[0]);
}

static  void method_15591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HepMC::GenEvent*)o)->remove_vertex)((::HepMC::GenVertex*)arg[0]));
  else   (((::HepMC::GenEvent*)o)->remove_vertex)((::HepMC::GenVertex*)arg[0]);
}

static  void method_15592( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HepMC::GenEvent*)o)->clear)();
}

static  void method_15593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_signal_process_id)(*(int*)arg[0]);
}

static  void method_15594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_event_number)(*(int*)arg[0]);
}

static  void method_15595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_mpi)(*(int*)arg[0]);
}

static  void method_15596( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_event_scale)(*(double*)arg[0]);
}

static  void method_15597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_alphaQCD)(*(double*)arg[0]);
}

static  void method_15598( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_alphaQED)(*(double*)arg[0]);
}

static  void method_15599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_signal_process_vertex)((::HepMC::GenVertex*)arg[0]);
}

static  void method_15600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HepMC::GenEvent*)o)->set_beam_particles)((::HepMC::GenParticle*)arg[0],
    (::HepMC::GenParticle*)arg[1]));
  else   (((::HepMC::GenEvent*)o)->set_beam_particles)((::HepMC::GenParticle*)arg[0],
    (::HepMC::GenParticle*)arg[1]);
}

static  void method_15601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HepMC::GenEvent*)o)->set_beam_particles)(*(const ::std::pair<HepMC::GenParticle*,HepMC::GenParticle*>*)arg[0]));
  else   (((::HepMC::GenEvent*)o)->set_beam_particles)(*(const ::std::pair<HepMC::GenParticle*,HepMC::GenParticle*>*)arg[0]);
}

static  void method_15602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_random_states)(*(const ::std::vector<long>*)arg[0]);
}

static  void method_15603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_cross_section)(*(const ::HepMC::GenCrossSection*)arg[0]);
}

static  void method_15604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_heavy_ion)(*(const ::HepMC::HeavyIon*)arg[0]);
}

static  void method_15605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->set_pdf_info)(*(const ::HepMC::PdfInfo*)arg[0]);
}

static  void method_15606( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->use_units)(*(::HepMC::Units::MomentumUnit*)arg[0],
    *(::HepMC::Units::LengthUnit*)arg[1]);
}

static  void method_15607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HepMC::GenEvent*)o)->use_units)(*(::std::string*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_15608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEventVertexRange)((((::HepMC::GenEvent*)o)->vertex_range)());
  else   (((::HepMC::GenEvent*)o)->vertex_range)();
}

static  void method_15609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::ConstGenEventVertexRange)((((const ::HepMC::GenEvent*)o)->vertex_range)());
  else   (((const ::HepMC::GenEvent*)o)->vertex_range)();
}

static  void method_15610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEventParticleRange)((((::HepMC::GenEvent*)o)->particle_range)());
  else   (((::HepMC::GenEvent*)o)->particle_range)();
}

static  void method_15611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::ConstGenEventParticleRange)((((const ::HepMC::GenEvent*)o)->particle_range)());
  else   (((const ::HepMC::GenEvent*)o)->particle_range)();
}

static  void method_15612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::vertex_const_iterator)((((const ::HepMC::GenEvent*)o)->vertices_begin)());
  else   (((const ::HepMC::GenEvent*)o)->vertices_begin)();
}

static  void method_15613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::vertex_const_iterator)((((const ::HepMC::GenEvent*)o)->vertices_end)());
  else   (((const ::HepMC::GenEvent*)o)->vertices_end)();
}

static  void method_15614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::vertex_iterator)((((::HepMC::GenEvent*)o)->vertices_begin)());
  else   (((::HepMC::GenEvent*)o)->vertices_begin)();
}

static  void method_15615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::vertex_iterator)((((::HepMC::GenEvent*)o)->vertices_end)());
  else   (((::HepMC::GenEvent*)o)->vertices_end)();
}

static  void method_15616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::particle_const_iterator)((((const ::HepMC::GenEvent*)o)->particles_begin)());
  else   (((const ::HepMC::GenEvent*)o)->particles_begin)();
}

static  void method_15617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::particle_const_iterator)((((const ::HepMC::GenEvent*)o)->particles_end)());
  else   (((const ::HepMC::GenEvent*)o)->particles_end)();
}

static  void method_15618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::particle_iterator)((((::HepMC::GenEvent*)o)->particles_begin)());
  else   (((::HepMC::GenEvent*)o)->particles_begin)();
}

static  void method_15619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::particle_iterator)((((::HepMC::GenEvent*)o)->particles_end)());
  else   (((::HepMC::GenEvent*)o)->particles_end)();
}

static void constructor_x55( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent();
  else ::new(mem) ::HepMC::GenEvent();
}

static void method_newdel_3486( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenEvent -------------------------------
void __HepMC__GenEvent_db_datamem(Reflex::Class*);
void __HepMC__GenEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent_datamem_bld(&__HepMC__GenEvent_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent_funcmem_bld(&__HepMC__GenEvent_db_funcmem);
void __HepMC__GenEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenEvent"), typeid(::HepMC::GenEvent), sizeof(::HepMC::GenEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_67, type_67, type_9248, type_24888, type_24326, type_15160, type_15161), Reflex::Literal("GenEvent"), constructor_15549, 0, "signal_process_id=0;event_number=0;signal_vertex=0;weights=std::vector<double, std::allocator<double> >();randomstates=std::vector<long int, std::allocator<long int> >();;", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_67, type_67, type_9248, type_24888, type_24326, type_24880, type_24797, type_15160, type_15161), Reflex::Literal("GenEvent"), constructor_15550, 0, "signal_process_id;event_number;signal_vertex;weights;randomstates;ion;pdf;;", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15160, type_15161, type_67, type_67, type_9248, type_24888, type_24326), Reflex::Literal("GenEvent"), constructor_15551, 0, ";;signal_process_id=0;event_number=0;signal_vertex=0;weights=std::vector<double, std::allocator<double> >();randomstates=std::vector<long int, std::allocator<long int> >()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15160, type_15161, type_67, type_67, type_9248, type_24888, type_24326, type_24880, type_24797), Reflex::Literal("GenEvent"), constructor_15552, 0, ";;signal_process_id;event_number;signal_vertex;weights;randomstates;ion;pdf", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24891), Reflex::Literal("GenEvent"), constructor_15553, 0, "inevent", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenEvent"), destructor_15555, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenEvent"), constructor_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3486, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenEvent_funcmem_bld);
}

//------Delayed data member builder for class GenEvent -------------------
void __HepMC__GenEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_67, Reflex::Literal("m_signal_process_id"), OffsetOf(__shadow__::__HepMC__GenEvent, m_signal_process_id), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_event_number"), OffsetOf(__shadow__::__HepMC__GenEvent, m_event_number), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("m_mpi"), OffsetOf(__shadow__::__HepMC__GenEvent, m_mpi), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_event_scale"), OffsetOf(__shadow__::__HepMC__GenEvent, m_event_scale), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_alphaQCD"), OffsetOf(__shadow__::__HepMC__GenEvent, m_alphaQCD), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("m_alphaQED"), OffsetOf(__shadow__::__HepMC__GenEvent, m_alphaQED), ::Reflex::PRIVATE)
  .AddDataMember(type_9248, Reflex::Literal("m_signal_process_vertex"), OffsetOf(__shadow__::__HepMC__GenEvent, m_signal_process_vertex), ::Reflex::PRIVATE)
  .AddDataMember(type_6865, Reflex::Literal("m_beam_particle_1"), OffsetOf(__shadow__::__HepMC__GenEvent, m_beam_particle_1), ::Reflex::PRIVATE)
  .AddDataMember(type_6865, Reflex::Literal("m_beam_particle_2"), OffsetOf(__shadow__::__HepMC__GenEvent, m_beam_particle_2), ::Reflex::PRIVATE)
  .AddDataMember(type_3474, Reflex::Literal("m_weights"), OffsetOf(__shadow__::__HepMC__GenEvent, m_weights), ::Reflex::PRIVATE)
  .AddDataMember(type_2808, Reflex::Literal("m_random_states"), OffsetOf(__shadow__::__HepMC__GenEvent, m_random_states), ::Reflex::PRIVATE)
  .AddDataMember(type_2955, Reflex::Literal("m_vertex_barcodes"), OffsetOf(__shadow__::__HepMC__GenEvent, m_vertex_barcodes), ::Reflex::PRIVATE)
  .AddDataMember(type_2956, Reflex::Literal("m_particle_barcodes"), OffsetOf(__shadow__::__HepMC__GenEvent, m_particle_barcodes), ::Reflex::PRIVATE)
  .AddDataMember(type_24964, Reflex::Literal("m_cross_section"), OffsetOf(__shadow__::__HepMC__GenEvent, m_cross_section), ::Reflex::PRIVATE)
  .AddDataMember(type_15340, Reflex::Literal("m_heavy_ion"), OffsetOf(__shadow__::__HepMC__GenEvent, m_heavy_ion), ::Reflex::PRIVATE)
  .AddDataMember(type_15339, Reflex::Literal("m_pdf_info"), OffsetOf(__shadow__::__HepMC__GenEvent, m_pdf_info), ::Reflex::PRIVATE)
  .AddDataMember(type_15160, Reflex::Literal("m_momentum_unit"), OffsetOf(__shadow__::__HepMC__GenEvent, m_momentum_unit), ::Reflex::PRIVATE)
  .AddDataMember(type_15161, Reflex::Literal("m_position_unit"), OffsetOf(__shadow__::__HepMC__GenEvent, m_position_unit), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenEvent -------------------
void __HepMC__GenEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15159, type_24891), Reflex::Literal("operator="), operator_15554, 0, "inevent", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_15159), Reflex::Literal("swap"), method_15556, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("print"), method_15557, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("print_version"), method_15558, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6865, type_67), Reflex::Literal("barcode_to_particle"), method_15559, 0, "barCode", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9248, type_67), Reflex::Literal("barcode_to_vertex"), method_15560, 0, "barCode", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("signal_process_id"), method_15561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("event_number"), method_15562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("mpi"), method_15563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("event_scale"), method_15564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("alphaQCD"), method_15565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("alphaQED"), method_15566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9248), Reflex::Literal("signal_process_vertex"), method_15567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("valid_beam_particles"), method_15568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2756), Reflex::Literal("beam_particles"), method_15569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("is_valid"), method_15570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24889), Reflex::Literal("weights"), method_15571, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24888), Reflex::Literal("weights"), method_15572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25019), Reflex::Literal("cross_section"), method_15573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24964), Reflex::Literal("cross_section"), method_15574, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15332), Reflex::Literal("heavy_ion"), method_15575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15340), Reflex::Literal("heavy_ion"), method_15576, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15331), Reflex::Literal("pdf_info"), method_15577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15339), Reflex::Literal("pdf_info"), method_15578, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24326), Reflex::Literal("random_states"), method_15579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("particles_size"), method_15580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("particles_empty"), method_15581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("vertices_size"), method_15582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("vertices_empty"), method_15583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("write_units"), method_15584, 0, "os=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4752), Reflex::Literal("write_cross_section"), method_15585, 0, "ostr=std::cout", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15160), Reflex::Literal("momentum_unit"), method_15586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15161), Reflex::Literal("length_unit"), method_15587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4752, type_4752), Reflex::Literal("write"), method_15588, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761, type_4761), Reflex::Literal("read"), method_15589, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_9248), Reflex::Literal("add_vertex"), method_15590, 0, "vtx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_9248), Reflex::Literal("remove_vertex"), method_15591, 0, "vtx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_15592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("set_signal_process_id"), method_15593, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("set_event_number"), method_15594, 0, "eventno", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("set_mpi"), method_15595, 0, "nmpi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("set_event_scale"), method_15596, 0, "sc", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("set_alphaQCD"), method_15597, 0, "a", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_102), Reflex::Literal("set_alphaQED"), method_15598, 0, "a", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_9248), Reflex::Literal("set_signal_process_vertex"), method_15599, 0, "vtx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_6865, type_6865), Reflex::Literal("set_beam_particles"), method_15600, 0, ";", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_24292), Reflex::Literal("set_beam_particles"), method_15601, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24326), Reflex::Literal("set_random_states"), method_15602, 0, "randomstates", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24799), Reflex::Literal("set_cross_section"), method_15603, 0, "xs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24880), Reflex::Literal("set_heavy_ion"), method_15604, 0, "ion", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24797), Reflex::Literal("set_pdf_info"), method_15605, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_15160, type_15161), Reflex::Literal("use_units"), method_15606, 0, "new_m;new_l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_16542, type_16542), Reflex::Literal("use_units"), method_15607, 0, "new_m;new_l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3473), Reflex::Literal("vertex_range"), method_15608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3477), Reflex::Literal("vertex_range"), method_15609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3479), Reflex::Literal("particle_range"), method_15610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3480), Reflex::Literal("particle_range"), method_15611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15545), Reflex::Literal("vertices_begin"), method_15612, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15545), Reflex::Literal("vertices_end"), method_15613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15546), Reflex::Literal("vertices_begin"), method_15614, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15546), Reflex::Literal("vertices_end"), method_15615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15547), Reflex::Literal("particles_begin"), method_15616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15547), Reflex::Literal("particles_end"), method_15617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15548), Reflex::Literal("particles_begin"), method_15618, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15548), Reflex::Literal("particles_end"), method_15619, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------------------
static void destructor_18446(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::~RefVector)();
}
static void constructor_18447( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>();
  else ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>();
}

static void constructor_18448( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
  else ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
}

static void constructor_18449( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0]);
}

static  void method_18450( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->push_back)(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
}

static  void operator_18451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->refVector)();
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->refVector)();
}

static  void method_18454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->empty)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->empty)();
}

static  void method_18455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->size)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->size)();
}

static  void method_18456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->capacity)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->capacity)();
}

static  void method_18457( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_18458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->begin)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->begin)();
}

static  void method_18459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->end)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->end)();
}

static  void method_18460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->id)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->id)();
}

static  void method_18461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->productGetter)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->productGetter)();
}

static  void method_18462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNull)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNull)();
}

static  void method_18463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNonnull)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNonnull)();
}

static  void operator_18464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator!)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator!)();
}

static  void method_18465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->product)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->product)();
}

static  void method_18466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isAvailable)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isAvailable)();
}

static  void method_18467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isTransient)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isTransient)();
}

static  void method_18468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>)((((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->erase)(*(const ::edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]));
  else   (((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->erase)(*(const ::edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
}

static  void method_18469( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->clear)();
}

static  void method_18470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->swap)(*(::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
}

static  void operator_18471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator=)(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
  else   (((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator=)(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
}

static  void method_18472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->hasProductCache)();
}

static  void method_18473( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_18474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->Class_Version)());
  else   (((::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->Class_Version)();
}

static void method_newdel_4093( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------------------
void __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_datamem(Reflex::Class*);
void __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__datamem_bld(&__edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__funcmem_bld(&__edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_funcmem);
void __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>"), typeid(::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>), sizeof(::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::Class_Version())
  .AddTypedef(type_4198, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::collection_type"))
  .AddTypedef(type_3482, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::member_type"))
  .AddTypedef(type_15959, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::finder_type"))
  .AddTypedef(type_4077, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::iterator"))
  .AddTypedef(type_4077, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::const_iterator"))
  .AddTypedef(type_4196, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::value_type"))
  .AddTypedef(type_4196c, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::const_reference"))
  .AddTypedef(type_4196c, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::reference"))
  .AddTypedef(type_67, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::key_type"))
  .AddTypedef(type_2802, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::KeyVec"))
  .AddTypedef(type_3033, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::size_type"))
  .AddTypedef(type_4182, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_18446, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_18447, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28800), Reflex::Literal("RefVector"), constructor_18448, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751), Reflex::Literal("RefVector"), constructor_18449, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4093, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__funcmem_bld);
}

//------Delayed data member builder for class RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------
void __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4182, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------
void __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_28801), Reflex::Literal("push_back"), method_18450, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4196c, type_3033), Reflex::Literal("operator[]"), operator_18451, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4196c, type_3033), Reflex::Literal("at"), method_18452, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28802), Reflex::Literal("refVector"), method_18453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_18454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_18455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_18456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_18457, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4077), Reflex::Literal("begin"), method_18458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4077), Reflex::Literal("end"), method_18459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4207), Reflex::Literal("id"), method_18460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18986), Reflex::Literal("productGetter"), method_18461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNull"), method_18462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNonnull"), method_18463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("operator!"), operator_18464, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10205), Reflex::Literal("product"), method_18465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isAvailable"), method_18466, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isTransient"), method_18467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4077, type_28803), Reflex::Literal("erase"), method_18468, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_18469, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_28804), Reflex::Literal("swap"), method_18470, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28804, type_28800), Reflex::Literal("operator="), operator_18471, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasProductCache"), method_18472, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28805), Reflex::Literal("fillView"), method_18473, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_173), Reflex::Literal("Class_Version"), method_18474, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------------------
static void destructor_18488(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::~RefVector)();
}
static void constructor_18489( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>();
  else ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>();
}

static void constructor_18490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
  else ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
}

static void constructor_18491( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0]);
}

static  void method_18492( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->push_back)(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
}

static  void operator_18493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->refVector)();
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->refVector)();
}

static  void method_18496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->empty)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->empty)();
}

static  void method_18497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->size)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->size)();
}

static  void method_18498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->capacity)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->capacity)();
}

static  void method_18499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_18500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->begin)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->begin)();
}

static  void method_18501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->end)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->end)();
}

static  void method_18502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->id)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->id)();
}

static  void method_18503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->productGetter)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->productGetter)();
}

static  void method_18504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNull)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNull)();
}

static  void method_18505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNonnull)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNonnull)();
}

static  void operator_18506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator!)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator!)();
}

static  void method_18507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->product)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->product)();
}

static  void method_18508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isAvailable)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isAvailable)();
}

static  void method_18509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isTransient)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isTransient)();
}

static  void method_18510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>)((((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->erase)(*(const ::edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]));
  else   (((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->erase)(*(const ::edm::RefVectorIterator<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
}

static  void method_18511( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->clear)();
}

static  void method_18512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->swap)(*(::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
}

static  void operator_18513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator=)(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
  else   (((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator=)(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
}

static  void method_18514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->hasProductCache)();
}

static  void method_18515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_18516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->Class_Version)());
  else   (((::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->Class_Version)();
}

static void method_newdel_4094( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------------------
void __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_datamem(Reflex::Class*);
void __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__datamem_bld(&__edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__funcmem_bld(&__edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_funcmem);
void __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>"), typeid(::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>), sizeof(::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::Class_Version())
  .AddTypedef(type_4198, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::collection_type"))
  .AddTypedef(type_3450, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::member_type"))
  .AddTypedef(type_15970, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::finder_type"))
  .AddTypedef(type_4078, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::iterator"))
  .AddTypedef(type_4078, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::const_iterator"))
  .AddTypedef(type_4197, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::value_type"))
  .AddTypedef(type_4197c, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::const_reference"))
  .AddTypedef(type_4197c, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::reference"))
  .AddTypedef(type_67, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::key_type"))
  .AddTypedef(type_2802, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::KeyVec"))
  .AddTypedef(type_3033, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::size_type"))
  .AddTypedef(type_4182, Reflex::Literal("edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_18488, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_18489, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28807), Reflex::Literal("RefVector"), constructor_18490, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751), Reflex::Literal("RefVector"), constructor_18491, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4094, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__funcmem_bld);
}

//------Delayed data member builder for class RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------
void __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4182, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------
void __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_28808), Reflex::Literal("push_back"), method_18492, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197c, type_3033), Reflex::Literal("operator[]"), operator_18493, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4197c, type_3033), Reflex::Literal("at"), method_18494, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28802), Reflex::Literal("refVector"), method_18495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("empty"), method_18496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("size"), method_18497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3033), Reflex::Literal("capacity"), method_18498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_3033), Reflex::Literal("reserve"), method_18499, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4078), Reflex::Literal("begin"), method_18500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4078), Reflex::Literal("end"), method_18501, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4207), Reflex::Literal("id"), method_18502, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18986), Reflex::Literal("productGetter"), method_18503, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNull"), method_18504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNonnull"), method_18505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("operator!"), operator_18506, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10205), Reflex::Literal("product"), method_18507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isAvailable"), method_18508, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isTransient"), method_18509, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4078, type_28809), Reflex::Literal("erase"), method_18510, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("clear"), method_18511, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_28810), Reflex::Literal("swap"), method_18512, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28810, type_28807), Reflex::Literal("operator="), operator_18513, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasProductCache"), method_18514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28805), Reflex::Literal("fillView"), method_18515, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_173), Reflex::Literal("Class_Version"), method_18516, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<LHEXMLStringProduct> -------------------------------
static void constructor_18521( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHEXMLStringProduct>();
  else ::new(mem) ::edm::Wrapper<LHEXMLStringProduct>();
}

static void constructor_18522( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHEXMLStringProduct>(*(::std::auto_ptr<LHEXMLStringProduct>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LHEXMLStringProduct>(*(::std::auto_ptr<LHEXMLStringProduct>*)arg[0]);
}

static void destructor_18523(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<LHEXMLStringProduct>*)o)->::edm::Wrapper<LHEXMLStringProduct>::~Wrapper)();
}
static  void method_18524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->product)());
  else   (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->product)();
}

static  void operator_18525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->operator->)());
  else   (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->operator->)();
}

static  void method_18526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LHEXMLStringProduct>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<LHEXMLStringProduct>*)o)->productTypeInfo)();
}

static  void method_18527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LHEXMLStringProduct>*)o)->typeInfo)();
  else   (((::edm::Wrapper<LHEXMLStringProduct>*)o)->typeInfo)();
}

static void constructor_18528( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHEXMLStringProduct>((::LHEXMLStringProduct*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LHEXMLStringProduct>((::LHEXMLStringProduct*)arg[0]);
}

static  void method_18529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<LHEXMLStringProduct>*)o)->getInterface)());
  else   (((::edm::Wrapper<LHEXMLStringProduct>*)o)->getInterface)();
}

static  void method_18530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->dynamicTypeInfo)();
}

static  void method_18534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->isPresent)();
}

static  void method_18535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<LHEXMLStringProduct>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEXMLStringProduct> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEXMLStringProduct> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEXMLStringProduct> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEXMLStringProduct> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEXMLStringProduct> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<LHEXMLStringProduct> -------------------------------
void __edm__Wrapper_LHEXMLStringProduct__db_datamem(Reflex::Class*);
void __edm__Wrapper_LHEXMLStringProduct__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LHEXMLStringProduct__datamem_bld(&__edm__Wrapper_LHEXMLStringProduct__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LHEXMLStringProduct__funcmem_bld(&__edm__Wrapper_LHEXMLStringProduct__db_funcmem);
void __edm__Wrapper_LHEXMLStringProduct__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<LHEXMLStringProduct>"), typeid(::edm::Wrapper<LHEXMLStringProduct>), sizeof(::edm::Wrapper<LHEXMLStringProduct>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_690, Reflex::Literal("edm::Wrapper<LHEXMLStringProduct>::value_type"))
  .AddTypedef(type_690, Reflex::Literal("edm::Wrapper<LHEXMLStringProduct>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18521, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2543), Reflex::Literal("Wrapper"), constructor_18522, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18523, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28812), Reflex::Literal("Wrapper"), constructor_18528, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_LHEXMLStringProduct__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_LHEXMLStringProduct__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<LHEXMLStringProduct> -------------------
void __edm__Wrapper_LHEXMLStringProduct__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_LHEXMLStringProduct_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_690, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_LHEXMLStringProduct_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<LHEXMLStringProduct> -------------------
void __edm__Wrapper_LHEXMLStringProduct__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28811), Reflex::Literal("product"), method_18524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28811), Reflex::Literal("operator->"), operator_18525, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18526, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18527, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28813), Reflex::Literal("getInterface"), method_18529, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18530, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18531, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18532, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<LHEEventProduct> -------------------------------
static void constructor_18542( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHEEventProduct>();
  else ::new(mem) ::edm::Wrapper<LHEEventProduct>();
}

static void constructor_18543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHEEventProduct>(*(::std::auto_ptr<LHEEventProduct>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LHEEventProduct>(*(::std::auto_ptr<LHEEventProduct>*)arg[0]);
}

static void destructor_18544(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<LHEEventProduct>*)o)->::edm::Wrapper<LHEEventProduct>::~Wrapper)();
}
static  void method_18545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LHEEventProduct>*)o)->product)());
  else   (((const ::edm::Wrapper<LHEEventProduct>*)o)->product)();
}

static  void operator_18546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LHEEventProduct>*)o)->operator->)());
  else   (((const ::edm::Wrapper<LHEEventProduct>*)o)->operator->)();
}

static  void method_18547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LHEEventProduct>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<LHEEventProduct>*)o)->productTypeInfo)();
}

static  void method_18548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LHEEventProduct>*)o)->typeInfo)();
  else   (((::edm::Wrapper<LHEEventProduct>*)o)->typeInfo)();
}

static void constructor_18549( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHEEventProduct>((::LHEEventProduct*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LHEEventProduct>((::LHEEventProduct*)arg[0]);
}

static  void method_18550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<LHEEventProduct>*)o)->getInterface)());
  else   (((::edm::Wrapper<LHEEventProduct>*)o)->getInterface)();
}

static  void method_18551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHEEventProduct>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18552( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHEEventProduct>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHEEventProduct>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LHEEventProduct>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<LHEEventProduct>*)o)->dynamicTypeInfo)();
}

static  void method_18555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<LHEEventProduct>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<LHEEventProduct>*)o)->isPresent)();
}

static  void method_18556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LHEEventProduct>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<LHEEventProduct>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEEventProduct> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEEventProduct> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEEventProduct> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEEventProduct> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHEEventProduct> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<LHEEventProduct> -------------------------------
void __edm__Wrapper_LHEEventProduct__db_datamem(Reflex::Class*);
void __edm__Wrapper_LHEEventProduct__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LHEEventProduct__datamem_bld(&__edm__Wrapper_LHEEventProduct__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LHEEventProduct__funcmem_bld(&__edm__Wrapper_LHEEventProduct__db_funcmem);
void __edm__Wrapper_LHEEventProduct__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<LHEEventProduct>"), typeid(::edm::Wrapper<LHEEventProduct>), sizeof(::edm::Wrapper<LHEEventProduct>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_459, Reflex::Literal("edm::Wrapper<LHEEventProduct>::value_type"))
  .AddTypedef(type_459, Reflex::Literal("edm::Wrapper<LHEEventProduct>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18542, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2544), Reflex::Literal("Wrapper"), constructor_18543, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18544, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28817), Reflex::Literal("Wrapper"), constructor_18549, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_LHEEventProduct__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_LHEEventProduct__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<LHEEventProduct> -------------------
void __edm__Wrapper_LHEEventProduct__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_LHEEventProduct_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_459, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_LHEEventProduct_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<LHEEventProduct> -------------------
void __edm__Wrapper_LHEEventProduct__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28816), Reflex::Literal("product"), method_18545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28816), Reflex::Literal("operator->"), operator_18546, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18547, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18548, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28818), Reflex::Literal("getInterface"), method_18550, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18551, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18552, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18553, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<LHERunInfoProduct> -------------------------------
static void constructor_18563( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHERunInfoProduct>();
  else ::new(mem) ::edm::Wrapper<LHERunInfoProduct>();
}

static void constructor_18564( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHERunInfoProduct>(*(::std::auto_ptr<LHERunInfoProduct>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LHERunInfoProduct>(*(::std::auto_ptr<LHERunInfoProduct>*)arg[0]);
}

static void destructor_18565(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<LHERunInfoProduct>*)o)->::edm::Wrapper<LHERunInfoProduct>::~Wrapper)();
}
static  void method_18566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LHERunInfoProduct>*)o)->product)());
  else   (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->product)();
}

static  void operator_18567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LHERunInfoProduct>*)o)->operator->)());
  else   (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->operator->)();
}

static  void method_18568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LHERunInfoProduct>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<LHERunInfoProduct>*)o)->productTypeInfo)();
}

static  void method_18569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LHERunInfoProduct>*)o)->typeInfo)();
  else   (((::edm::Wrapper<LHERunInfoProduct>*)o)->typeInfo)();
}

static void constructor_18570( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LHERunInfoProduct>((::LHERunInfoProduct*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LHERunInfoProduct>((::LHERunInfoProduct*)arg[0]);
}

static  void method_18571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<LHERunInfoProduct>*)o)->getInterface)());
  else   (((::edm::Wrapper<LHERunInfoProduct>*)o)->getInterface)();
}

static  void method_18572( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18574( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LHERunInfoProduct>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->dynamicTypeInfo)();
}

static  void method_18576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<LHERunInfoProduct>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->isPresent)();
}

static  void method_18577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LHERunInfoProduct>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<LHERunInfoProduct>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4105( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHERunInfoProduct> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHERunInfoProduct> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHERunInfoProduct> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHERunInfoProduct> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LHERunInfoProduct> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<LHERunInfoProduct> -------------------------------
void __edm__Wrapper_LHERunInfoProduct__db_datamem(Reflex::Class*);
void __edm__Wrapper_LHERunInfoProduct__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LHERunInfoProduct__datamem_bld(&__edm__Wrapper_LHERunInfoProduct__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LHERunInfoProduct__funcmem_bld(&__edm__Wrapper_LHERunInfoProduct__db_funcmem);
void __edm__Wrapper_LHERunInfoProduct__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<LHERunInfoProduct>"), typeid(::edm::Wrapper<LHERunInfoProduct>), sizeof(::edm::Wrapper<LHERunInfoProduct>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_818, Reflex::Literal("edm::Wrapper<LHERunInfoProduct>::value_type"))
  .AddTypedef(type_818, Reflex::Literal("edm::Wrapper<LHERunInfoProduct>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18563, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2545), Reflex::Literal("Wrapper"), constructor_18564, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18565, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28822), Reflex::Literal("Wrapper"), constructor_18570, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_LHERunInfoProduct__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_LHERunInfoProduct__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<LHERunInfoProduct> -------------------
void __edm__Wrapper_LHERunInfoProduct__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_LHERunInfoProduct_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_818, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_LHERunInfoProduct_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<LHERunInfoProduct> -------------------
void __edm__Wrapper_LHERunInfoProduct__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28821), Reflex::Literal("product"), method_18566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28821), Reflex::Literal("operator->"), operator_18567, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18568, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18569, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28823), Reflex::Literal("getInterface"), method_18571, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18572, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18573, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18574, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<GenLumiInfoProduct> -------------------------------
static void constructor_18584( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenLumiInfoProduct>();
  else ::new(mem) ::edm::Wrapper<GenLumiInfoProduct>();
}

static void constructor_18585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenLumiInfoProduct>(*(::std::auto_ptr<GenLumiInfoProduct>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenLumiInfoProduct>(*(::std::auto_ptr<GenLumiInfoProduct>*)arg[0]);
}

static void destructor_18586(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<GenLumiInfoProduct>*)o)->::edm::Wrapper<GenLumiInfoProduct>::~Wrapper)();
}
static  void method_18587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->product)());
  else   (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->product)();
}

static  void operator_18588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->operator->)());
  else   (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->operator->)();
}

static  void method_18589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenLumiInfoProduct>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<GenLumiInfoProduct>*)o)->productTypeInfo)();
}

static  void method_18590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenLumiInfoProduct>*)o)->typeInfo)();
  else   (((::edm::Wrapper<GenLumiInfoProduct>*)o)->typeInfo)();
}

static void constructor_18591( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenLumiInfoProduct>((::GenLumiInfoProduct*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenLumiInfoProduct>((::GenLumiInfoProduct*)arg[0]);
}

static  void method_18592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<GenLumiInfoProduct>*)o)->getInterface)());
  else   (((::edm::Wrapper<GenLumiInfoProduct>*)o)->getInterface)();
}

static  void method_18593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->dynamicTypeInfo)();
}

static  void method_18597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->isPresent)();
}

static  void method_18598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<GenLumiInfoProduct>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenLumiInfoProduct> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenLumiInfoProduct> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenLumiInfoProduct> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenLumiInfoProduct> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenLumiInfoProduct> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<GenLumiInfoProduct> -------------------------------
void __edm__Wrapper_GenLumiInfoProduct__db_datamem(Reflex::Class*);
void __edm__Wrapper_GenLumiInfoProduct__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenLumiInfoProduct__datamem_bld(&__edm__Wrapper_GenLumiInfoProduct__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenLumiInfoProduct__funcmem_bld(&__edm__Wrapper_GenLumiInfoProduct__db_funcmem);
void __edm__Wrapper_GenLumiInfoProduct__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<GenLumiInfoProduct>"), typeid(::edm::Wrapper<GenLumiInfoProduct>), sizeof(::edm::Wrapper<GenLumiInfoProduct>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1920, Reflex::Literal("edm::Wrapper<GenLumiInfoProduct>::value_type"))
  .AddTypedef(type_1920, Reflex::Literal("edm::Wrapper<GenLumiInfoProduct>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18584, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2546), Reflex::Literal("Wrapper"), constructor_18585, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18586, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28827), Reflex::Literal("Wrapper"), constructor_18591, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_GenLumiInfoProduct__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_GenLumiInfoProduct__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<GenLumiInfoProduct> -------------------
void __edm__Wrapper_GenLumiInfoProduct__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_GenLumiInfoProduct_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1920, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_GenLumiInfoProduct_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<GenLumiInfoProduct> -------------------
void __edm__Wrapper_GenLumiInfoProduct__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28826), Reflex::Literal("product"), method_18587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28826), Reflex::Literal("operator->"), operator_18588, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18589, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18590, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28828), Reflex::Literal("getInterface"), method_18592, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18593, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18594, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18595, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<GenEventInfoProduct> -------------------------------
static void constructor_18605( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenEventInfoProduct>();
  else ::new(mem) ::edm::Wrapper<GenEventInfoProduct>();
}

static void constructor_18606( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenEventInfoProduct>(*(::std::auto_ptr<GenEventInfoProduct>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenEventInfoProduct>(*(::std::auto_ptr<GenEventInfoProduct>*)arg[0]);
}

static void destructor_18607(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<GenEventInfoProduct>*)o)->::edm::Wrapper<GenEventInfoProduct>::~Wrapper)();
}
static  void method_18608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenEventInfoProduct>*)o)->product)());
  else   (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->product)();
}

static  void operator_18609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenEventInfoProduct>*)o)->operator->)());
  else   (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->operator->)();
}

static  void method_18610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenEventInfoProduct>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<GenEventInfoProduct>*)o)->productTypeInfo)();
}

static  void method_18611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenEventInfoProduct>*)o)->typeInfo)();
  else   (((::edm::Wrapper<GenEventInfoProduct>*)o)->typeInfo)();
}

static void constructor_18612( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenEventInfoProduct>((::GenEventInfoProduct*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenEventInfoProduct>((::GenEventInfoProduct*)arg[0]);
}

static  void method_18613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<GenEventInfoProduct>*)o)->getInterface)());
  else   (((::edm::Wrapper<GenEventInfoProduct>*)o)->getInterface)();
}

static  void method_18614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18615( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenEventInfoProduct>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->dynamicTypeInfo)();
}

static  void method_18618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<GenEventInfoProduct>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->isPresent)();
}

static  void method_18619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenEventInfoProduct>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<GenEventInfoProduct>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenEventInfoProduct> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenEventInfoProduct> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenEventInfoProduct> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenEventInfoProduct> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenEventInfoProduct> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<GenEventInfoProduct> -------------------------------
void __edm__Wrapper_GenEventInfoProduct__db_datamem(Reflex::Class*);
void __edm__Wrapper_GenEventInfoProduct__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenEventInfoProduct__datamem_bld(&__edm__Wrapper_GenEventInfoProduct__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenEventInfoProduct__funcmem_bld(&__edm__Wrapper_GenEventInfoProduct__db_funcmem);
void __edm__Wrapper_GenEventInfoProduct__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<GenEventInfoProduct>"), typeid(::edm::Wrapper<GenEventInfoProduct>), sizeof(::edm::Wrapper<GenEventInfoProduct>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_341, Reflex::Literal("edm::Wrapper<GenEventInfoProduct>::value_type"))
  .AddTypedef(type_341, Reflex::Literal("edm::Wrapper<GenEventInfoProduct>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18605, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2547), Reflex::Literal("Wrapper"), constructor_18606, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18607, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28832), Reflex::Literal("Wrapper"), constructor_18612, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_GenEventInfoProduct__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_GenEventInfoProduct__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<GenEventInfoProduct> -------------------
void __edm__Wrapper_GenEventInfoProduct__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_GenEventInfoProduct_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_341, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_GenEventInfoProduct_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<GenEventInfoProduct> -------------------
void __edm__Wrapper_GenEventInfoProduct__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28831), Reflex::Literal("product"), method_18608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28831), Reflex::Literal("operator->"), operator_18609, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18610, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18611, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28833), Reflex::Literal("getInterface"), method_18613, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18614, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18615, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18616, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<GenFilterInfo> -------------------------------
static void constructor_18626( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenFilterInfo>();
  else ::new(mem) ::edm::Wrapper<GenFilterInfo>();
}

static void constructor_18627( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenFilterInfo>(*(::std::auto_ptr<GenFilterInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenFilterInfo>(*(::std::auto_ptr<GenFilterInfo>*)arg[0]);
}

static void destructor_18628(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<GenFilterInfo>*)o)->::edm::Wrapper<GenFilterInfo>::~Wrapper)();
}
static  void method_18629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenFilterInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<GenFilterInfo>*)o)->product)();
}

static  void operator_18630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenFilterInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<GenFilterInfo>*)o)->operator->)();
}

static  void method_18631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenFilterInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<GenFilterInfo>*)o)->productTypeInfo)();
}

static  void method_18632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenFilterInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<GenFilterInfo>*)o)->typeInfo)();
}

static void constructor_18633( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenFilterInfo>((::GenFilterInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenFilterInfo>((::GenFilterInfo*)arg[0]);
}

static  void method_18634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<GenFilterInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<GenFilterInfo>*)o)->getInterface)();
}

static  void method_18635( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenFilterInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18636( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenFilterInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18637( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenFilterInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenFilterInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<GenFilterInfo>*)o)->dynamicTypeInfo)();
}

static  void method_18639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<GenFilterInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<GenFilterInfo>*)o)->isPresent)();
}

static  void method_18640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenFilterInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<GenFilterInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenFilterInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenFilterInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenFilterInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenFilterInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenFilterInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<GenFilterInfo> -------------------------------
void __edm__Wrapper_GenFilterInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_GenFilterInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenFilterInfo__datamem_bld(&__edm__Wrapper_GenFilterInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenFilterInfo__funcmem_bld(&__edm__Wrapper_GenFilterInfo__db_funcmem);
void __edm__Wrapper_GenFilterInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<GenFilterInfo>"), typeid(::edm::Wrapper<GenFilterInfo>), sizeof(::edm::Wrapper<GenFilterInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_866, Reflex::Literal("edm::Wrapper<GenFilterInfo>::value_type"))
  .AddTypedef(type_866, Reflex::Literal("edm::Wrapper<GenFilterInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18626, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2548), Reflex::Literal("Wrapper"), constructor_18627, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18628, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28837), Reflex::Literal("Wrapper"), constructor_18633, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_GenFilterInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_GenFilterInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<GenFilterInfo> -------------------
void __edm__Wrapper_GenFilterInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_GenFilterInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_866, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_GenFilterInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<GenFilterInfo> -------------------
void __edm__Wrapper_GenFilterInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28836), Reflex::Literal("product"), method_18629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28836), Reflex::Literal("operator->"), operator_18630, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18631, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18632, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28838), Reflex::Literal("getInterface"), method_18634, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18635, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18636, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18637, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<GenRunInfoProduct> -------------------------------
static void constructor_18647( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenRunInfoProduct>();
  else ::new(mem) ::edm::Wrapper<GenRunInfoProduct>();
}

static void constructor_18648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenRunInfoProduct>(*(::std::auto_ptr<GenRunInfoProduct>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenRunInfoProduct>(*(::std::auto_ptr<GenRunInfoProduct>*)arg[0]);
}

static void destructor_18649(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<GenRunInfoProduct>*)o)->::edm::Wrapper<GenRunInfoProduct>::~Wrapper)();
}
static  void method_18650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenRunInfoProduct>*)o)->product)());
  else   (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->product)();
}

static  void operator_18651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenRunInfoProduct>*)o)->operator->)());
  else   (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->operator->)();
}

static  void method_18652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenRunInfoProduct>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<GenRunInfoProduct>*)o)->productTypeInfo)();
}

static  void method_18653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenRunInfoProduct>*)o)->typeInfo)();
  else   (((::edm::Wrapper<GenRunInfoProduct>*)o)->typeInfo)();
}

static void constructor_18654( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenRunInfoProduct>((::GenRunInfoProduct*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenRunInfoProduct>((::GenRunInfoProduct*)arg[0]);
}

static  void method_18655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<GenRunInfoProduct>*)o)->getInterface)());
  else   (((::edm::Wrapper<GenRunInfoProduct>*)o)->getInterface)();
}

static  void method_18656( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18657( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18658( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenRunInfoProduct>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->dynamicTypeInfo)();
}

static  void method_18660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<GenRunInfoProduct>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->isPresent)();
}

static  void method_18661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenRunInfoProduct>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<GenRunInfoProduct>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4109( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenRunInfoProduct> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenRunInfoProduct> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenRunInfoProduct> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenRunInfoProduct> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenRunInfoProduct> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<GenRunInfoProduct> -------------------------------
void __edm__Wrapper_GenRunInfoProduct__db_datamem(Reflex::Class*);
void __edm__Wrapper_GenRunInfoProduct__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenRunInfoProduct__datamem_bld(&__edm__Wrapper_GenRunInfoProduct__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenRunInfoProduct__funcmem_bld(&__edm__Wrapper_GenRunInfoProduct__db_funcmem);
void __edm__Wrapper_GenRunInfoProduct__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<GenRunInfoProduct>"), typeid(::edm::Wrapper<GenRunInfoProduct>), sizeof(::edm::Wrapper<GenRunInfoProduct>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1341, Reflex::Literal("edm::Wrapper<GenRunInfoProduct>::value_type"))
  .AddTypedef(type_1341, Reflex::Literal("edm::Wrapper<GenRunInfoProduct>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18647, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2549), Reflex::Literal("Wrapper"), constructor_18648, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18649, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28842), Reflex::Literal("Wrapper"), constructor_18654, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4109, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_GenRunInfoProduct__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_GenRunInfoProduct__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<GenRunInfoProduct> -------------------
void __edm__Wrapper_GenRunInfoProduct__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_GenRunInfoProduct_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1341, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_GenRunInfoProduct_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<GenRunInfoProduct> -------------------
void __edm__Wrapper_GenRunInfoProduct__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28841), Reflex::Literal("product"), method_18650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28841), Reflex::Literal("operator->"), operator_18651, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18652, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18653, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28843), Reflex::Literal("getInterface"), method_18655, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18656, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18657, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18658, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HepMCProduct -------------------------------
static void constructor_19094( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HepMCProduct();
  else ::new(mem) ::edm::HepMCProduct();
}

static void constructor_19095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HepMCProduct((::HepMC::GenEvent*)arg[0]);
  else ::new(mem) ::edm::HepMCProduct((::HepMC::GenEvent*)arg[0]);
}

static void destructor_19096(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::HepMCProduct*)o)->::edm::HepMCProduct::~HepMCProduct)();
}
static  void method_19097( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::HepMCProduct*)o)->addHepMCData)((::HepMC::GenEvent*)arg[0]);
}

static  void method_19098( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::HepMCProduct*)o)->applyVtxGen)((::HepMC::FourVector*)arg[0]);
}

static  void method_19099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::HepMCProduct*)o)->boostToLab)((::TMatrixD*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_19100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::HepMCProduct*)o)->getHepMCData)();
  else   (((const ::edm::HepMCProduct*)o)->getHepMCData)();
}

static  void method_19101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::HepMCProduct*)o)->GetEvent)());
  else   (((const ::edm::HepMCProduct*)o)->GetEvent)();
}

static  void method_19102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HepMCProduct*)o)->isVtxGenApplied)());
  else   (((const ::edm::HepMCProduct*)o)->isVtxGenApplied)();
}

static  void method_19103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HepMCProduct*)o)->isVtxBoostApplied)());
  else   (((const ::edm::HepMCProduct*)o)->isVtxBoostApplied)();
}

static  void method_19104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HepMCProduct*)o)->isPBoostApplied)());
  else   (((const ::edm::HepMCProduct*)o)->isPBoostApplied)();
}

static void constructor_19105( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HepMCProduct(*(const ::edm::HepMCProduct*)arg[0]);
  else ::new(mem) ::edm::HepMCProduct(*(const ::edm::HepMCProduct*)arg[0]);
}

static  void operator_19106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::HepMCProduct*)o)->operator=)(*(const ::edm::HepMCProduct*)arg[0]);
  else   (((::edm::HepMCProduct*)o)->operator=)(*(const ::edm::HepMCProduct*)arg[0]);
}

static  void method_19107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::HepMCProduct*)o)->swap)(*(::edm::HepMCProduct*)arg[0]);
}

static void method_newdel_4198( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::HepMCProduct >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::HepMCProduct >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::HepMCProduct >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::HepMCProduct >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::HepMCProduct >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HepMCProduct -------------------------------
void __edm__HepMCProduct_db_datamem(Reflex::Class*);
void __edm__HepMCProduct_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__HepMCProduct_datamem_bld(&__edm__HepMCProduct_db_datamem);
Reflex::GenreflexMemberBuilder __edm__HepMCProduct_funcmem_bld(&__edm__HepMCProduct_db_funcmem);
void __edm__HepMCProduct_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::HepMCProduct"), typeid(::edm::HepMCProduct), sizeof(::edm::HepMCProduct), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HepMCProduct"), constructor_19094, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24802), Reflex::Literal("HepMCProduct"), constructor_19095, 0, "evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HepMCProduct"), destructor_19096, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12805), Reflex::Literal("HepMCProduct"), constructor_19105, 0, "orig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4198, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__HepMCProduct_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__HepMCProduct_funcmem_bld);
}

//------Delayed data member builder for class HepMCProduct -------------------
void __edm__HepMCProduct_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_24802, Reflex::Literal("evt_"), OffsetOf(__shadow__::__edm__HepMCProduct, evt_), ::Reflex::PRIVATE)
  .AddDataMember(type_1441, Reflex::Literal("isVtxGenApplied_"), OffsetOf(__shadow__::__edm__HepMCProduct, isVtxGenApplied_), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1441, Reflex::Literal("isVtxBoostApplied_"), OffsetOf(__shadow__::__edm__HepMCProduct, isVtxBoostApplied_), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1441, Reflex::Literal("isPBoostApplied_"), OffsetOf(__shadow__::__edm__HepMCProduct, isPBoostApplied_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class HepMCProduct -------------------
void __edm__HepMCProduct_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_24802), Reflex::Literal("addHepMCData"), method_19097, 0, "evt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_28966), Reflex::Literal("applyVtxGen"), method_19098, 0, "vtxShift", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_28967, type_2320), Reflex::Literal("boostToLab"), method_19099, 0, "lorentz;type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24891), Reflex::Literal("getHepMCData"), method_19100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18345), Reflex::Literal("GetEvent"), method_19101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isVtxGenApplied"), method_19102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isVtxBoostApplied"), method_19103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPBoostApplied"), method_19104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28968, type_12805), Reflex::Literal("operator="), operator_19106, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_28968), Reflex::Literal("swap"), method_19107, 0, "other", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<edm::HepMCProduct> -------------------------------
static void constructor_18668( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HepMCProduct>();
  else ::new(mem) ::edm::Wrapper<edm::HepMCProduct>();
}

static void constructor_18669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HepMCProduct>(*(::std::auto_ptr<edm::HepMCProduct>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::HepMCProduct>(*(::std::auto_ptr<edm::HepMCProduct>*)arg[0]);
}

static void destructor_18670(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::HepMCProduct>*)o)->::edm::Wrapper<edm::HepMCProduct>::~Wrapper)();
}
static  void method_18671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::HepMCProduct>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->product)();
}

static  void operator_18672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::HepMCProduct>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->operator->)();
}

static  void method_18673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::HepMCProduct>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::HepMCProduct>*)o)->productTypeInfo)();
}

static  void method_18674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::HepMCProduct>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::HepMCProduct>*)o)->typeInfo)();
}

static void constructor_18675( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HepMCProduct>((::edm::HepMCProduct*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::HepMCProduct>((::edm::HepMCProduct*)arg[0]);
}

static  void method_18676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::HepMCProduct>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::HepMCProduct>*)o)->getInterface)();
}

static  void method_18677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18678( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::HepMCProduct>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->dynamicTypeInfo)();
}

static  void method_18681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::HepMCProduct>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->isPresent)();
}

static  void method_18682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::HepMCProduct>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::HepMCProduct>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HepMCProduct> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HepMCProduct> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HepMCProduct> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HepMCProduct> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HepMCProduct> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::HepMCProduct> -------------------------------
void __edm__Wrapper_edm__HepMCProduct__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__HepMCProduct__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__HepMCProduct__datamem_bld(&__edm__Wrapper_edm__HepMCProduct__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__HepMCProduct__funcmem_bld(&__edm__Wrapper_edm__HepMCProduct__db_funcmem);
void __edm__Wrapper_edm__HepMCProduct__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::HepMCProduct>"), typeid(::edm::Wrapper<edm::HepMCProduct>), sizeof(::edm::Wrapper<edm::HepMCProduct>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4198, Reflex::Literal("edm::Wrapper<edm::HepMCProduct>::value_type"))
  .AddTypedef(type_4198, Reflex::Literal("edm::Wrapper<edm::HepMCProduct>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18668, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2550), Reflex::Literal("Wrapper"), constructor_18669, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18670, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28846), Reflex::Literal("Wrapper"), constructor_18675, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__HepMCProduct__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__HepMCProduct__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::HepMCProduct> -------------------
void __edm__Wrapper_edm__HepMCProduct__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1441, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__HepMCProduct_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4198, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__HepMCProduct_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::HepMCProduct> -------------------
void __edm__Wrapper_edm__HepMCProduct__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10205), Reflex::Literal("product"), method_18671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10205), Reflex::Literal("operator->"), operator_18672, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("productTypeInfo"), method_18673, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("typeInfo"), method_18674, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28847), Reflex::Literal("getInterface"), method_18676, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_18751, type_24308, type_28729), Reflex::Literal("fillView"), method_18677, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_293, type_7113), Reflex::Literal("setPtr"), method_18678, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_4075, type_24309, type_24308), Reflex::Literal("fillPtrVector"), method_18679, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo"), method_18680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isPresent"), method_18681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("dynamicTypeInfo_"), method_18682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------------------
static  void operator_19018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator=)(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
  else   (((::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator=)(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
}

static void constructor_19019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0]);
}

static void constructor_19020( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>();
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>();
}

static void constructor_19021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0],
      *(int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0],
      *(int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0],
      (const ::HepMC::GenVertex*)arg[1],
      *(int*)arg[2],
      (const ::edm::HepMCProduct*)arg[3]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0],
      (const ::HepMC::GenVertex*)arg[1],
      *(int*)arg[2],
      (const ::edm::HepMCProduct*)arg[3]);
}

static void constructor_19028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19029( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefProd<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefProd<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
}

static void destructor_19030(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::~Ref)();
}
static  void operator_19031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator*)();
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator*)();
}

static  void operator_19032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator->)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator->)();
}

static  void method_19033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->get)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->get)();
}

static  void method_19034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNull)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNull)();
}

static  void method_19035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNonnull)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isNonnull)();
}

static  void operator_19036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator!)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->operator!)();
}

static  void method_19037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->id)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->id)();
}

static  void method_19038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->productGetter)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->productGetter)();
}

static  void method_19039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->product)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->product)();
}

static  void method_19040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->key)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->key)();
}

static  void method_19041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->index)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->index)();
}

static  void method_19042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->hasProductCache)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->hasProductCache)();
}

static  void method_19043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isAvailable)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isAvailable)();
}

static  void method_19044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isTransient)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->isTransient)();
}

static  void method_19045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->refCore)();
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->refCore)();
}

static  void method_19046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->Class_Version)());
  else   (((::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>*)o)->Class_Version)();
}

static void constructor_19047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefCore*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>(*(const ::edm::RefCore*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_4196( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------------------
void __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_datamem(Reflex::Class*);
void __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__datamem_bld(&__edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__funcmem_bld(&__edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_funcmem);
void __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>"), typeid(::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>), sizeof(::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::Class_Version())
  .AddTypedef(type_18426, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::VF"))
  .AddTypedef(type_18425, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::VBF"))
  .AddTypedef(type_4198, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::product_type"))
  .AddTypedef(type_3482, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::value_type"))
  .AddTypedef(type_3482c, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::element_type"))
  .AddTypedef(type_15959, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::finder_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::argument_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find>::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28960, type_28801), Reflex::Literal("operator="), operator_19018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28801), Reflex::Literal("Ref"), constructor_19019, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19020, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28961, type_67, type_1441), Reflex::Literal("Ref"), constructor_19021, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28962, type_67, type_1441), Reflex::Literal("Ref"), constructor_19022, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28800, type_67, type_1441), Reflex::Literal("Ref"), constructor_19023, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10205, type_67, type_1441), Reflex::Literal("Ref"), constructor_19024, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28963, type_67, type_1441), Reflex::Literal("Ref"), constructor_19025, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751, type_67, type_18986), Reflex::Literal("Ref"), constructor_19026, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751, type_12808, type_67, type_10205), Reflex::Literal("Ref"), constructor_19027, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751), Reflex::Literal("Ref"), constructor_19028, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28964, type_67), Reflex::Literal("Ref"), constructor_19029, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19030, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18749, type_10150), Reflex::Literal("Ref"), constructor_19047, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4196, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__funcmem_bld);
}

//------Delayed data member builder for class Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------
void __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4173, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_67, Reflex::Literal("index_"), OffsetOf(__shadow__::__edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find_, index_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenVertex>::Find> -------------------
void __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15337), Reflex::Literal("operator*"), operator_19031, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12808), Reflex::Literal("operator->"), operator_19032, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12808), Reflex::Literal("get"), method_19033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNull"), method_19034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNonnull"), method_19035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("operator!"), operator_19036, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4207), Reflex::Literal("id"), method_19037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18986), Reflex::Literal("productGetter"), method_19038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10205), Reflex::Literal("product"), method_19039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("key"), method_19040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("index"), method_19041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasProductCache"), method_19042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isAvailable"), method_19043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isTransient"), method_19044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18749), Reflex::Literal("refCore"), method_19045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_173), Reflex::Literal("Class_Version"), method_19046, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------------------
static  void operator_19059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator=)(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
  else   (((::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator=)(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
}

static void constructor_19060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0]);
}

static void constructor_19061( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>();
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>();
}

static void constructor_19062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::Handle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19063( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::OrphanHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19064( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19065( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>((const ::edm::HepMCProduct*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19066( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::TestHandle<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_19067( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0],
      *(int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0],
      *(int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19068( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0],
      (const ::HepMC::GenParticle*)arg[1],
      *(int*)arg[2],
      (const ::edm::HepMCProduct*)arg[3]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0],
      (const ::HepMC::GenParticle*)arg[1],
      *(int*)arg[2],
      (const ::edm::HepMCProduct*)arg[3]);
}

static void constructor_19069( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefProd<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefProd<edm::HepMCProduct>*)arg[0],
      *(int*)arg[1]);
}

static void destructor_19071(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::~Ref)();
}
static  void operator_19072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator*)();
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator*)();
}

static  void operator_19073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator->)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator->)();
}

static  void method_19074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->get)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->get)();
}

static  void method_19075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNull)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNull)();
}

static  void method_19076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNonnull)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isNonnull)();
}

static  void operator_19077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator!)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->operator!)();
}

static  void method_19078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->id)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->id)();
}

static  void method_19079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->productGetter)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->productGetter)();
}

static  void method_19080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->product)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->product)();
}

static  void method_19081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->key)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->key)();
}

static  void method_19082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->index)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->index)();
}

static  void method_19083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->hasProductCache)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->hasProductCache)();
}

static  void method_19084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isAvailable)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isAvailable)();
}

static  void method_19085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isTransient)());
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->isTransient)();
}

static  void method_19086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->refCore)();
  else   (((const ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->refCore)();
}

static  void method_19087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->Class_Version)());
  else   (((::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>*)o)->Class_Version)();
}

static void constructor_19088( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefCore*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>(*(const ::edm::RefCore*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_4197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------------------
void __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_datamem(Reflex::Class*);
void __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__datamem_bld(&__edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__funcmem_bld(&__edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_funcmem);
void __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>"), typeid(::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>), sizeof(::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::Class_Version())
  .AddTypedef(type_18428, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::VF"))
  .AddTypedef(type_18427, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::VBF"))
  .AddTypedef(type_4198, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::product_type"))
  .AddTypedef(type_3450, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::value_type"))
  .AddTypedef(type_3450c, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::element_type"))
  .AddTypedef(type_15970, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::finder_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::argument_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find>::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28965, type_28808), Reflex::Literal("operator="), operator_19059, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28808), Reflex::Literal("Ref"), constructor_19060, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_19061, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28961, type_67, type_1441), Reflex::Literal("Ref"), constructor_19062, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28962, type_67, type_1441), Reflex::Literal("Ref"), constructor_19063, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28807, type_67, type_1441), Reflex::Literal("Ref"), constructor_19064, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10205, type_67, type_1441), Reflex::Literal("Ref"), constructor_19065, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28963, type_67, type_1441), Reflex::Literal("Ref"), constructor_19066, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751, type_67, type_18986), Reflex::Literal("Ref"), constructor_19067, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751, type_12816, type_67, type_10205), Reflex::Literal("Ref"), constructor_19068, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751), Reflex::Literal("Ref"), constructor_19069, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28964, type_67), Reflex::Literal("Ref"), constructor_19070, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_19071, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18749, type_10150), Reflex::Literal("Ref"), constructor_19088, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__funcmem_bld);
}

//------Delayed data member builder for class Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------
void __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4173, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_67, Reflex::Literal("index_"), OffsetOf(__shadow__::__edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find_, index_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct, HepMC::GenParticle>::Find> -------------------
void __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15334), Reflex::Literal("operator*"), operator_19072, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12816), Reflex::Literal("operator->"), operator_19073, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12816), Reflex::Literal("get"), method_19074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNull"), method_19075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isNonnull"), method_19076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("operator!"), operator_19077, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4207), Reflex::Literal("id"), method_19078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18986), Reflex::Literal("productGetter"), method_19079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10205), Reflex::Literal("product"), method_19080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("key"), method_19081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("index"), method_19082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasProductCache"), method_19083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isAvailable"), method_19084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isTransient"), method_19085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18749), Reflex::Literal("refCore"), method_19086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_173), Reflex::Literal("Class_Version"), method_19087, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class HEPRUP -------------------------------
static void destructor_19794(void*, void * o, const std::vector<void*>&, void *) {
(((::lhef::HEPRUP*)o)->::lhef::HEPRUP::~HEPRUP)();
}
static  void operator_19795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::lhef::HEPRUP*)o)->operator=)(*(const ::lhef::HEPRUP*)arg[0]);
  else   (((::lhef::HEPRUP*)o)->operator=)(*(const ::lhef::HEPRUP*)arg[0]);
}

static void constructor_19796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lhef::HEPRUP(*(const ::lhef::HEPRUP*)arg[0]);
  else ::new(mem) ::lhef::HEPRUP(*(const ::lhef::HEPRUP*)arg[0]);
}

static void constructor_19797( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lhef::HEPRUP();
  else ::new(mem) ::lhef::HEPRUP();
}

static  void operator_19798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::lhef::HEPRUP*)o)->operator==)(*(const ::lhef::HEPRUP*)arg[0]));
  else   (((const ::lhef::HEPRUP*)o)->operator==)(*(const ::lhef::HEPRUP*)arg[0]);
}

static  void method_19799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::lhef::HEPRUP*)o)->resize)(*(int*)arg[0]);
}

static  void method_19800( void*, void* o, const std::vector<void*>&, void*)
{
  (((::lhef::HEPRUP*)o)->resize)();
}

static void method_newdel_4729( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::lhef::HEPRUP >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::lhef::HEPRUP >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::lhef::HEPRUP >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::lhef::HEPRUP >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::lhef::HEPRUP >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HEPRUP -------------------------------
void __lhef__HEPRUP_db_datamem(Reflex::Class*);
void __lhef__HEPRUP_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __lhef__HEPRUP_datamem_bld(&__lhef__HEPRUP_db_datamem);
Reflex::GenreflexMemberBuilder __lhef__HEPRUP_funcmem_bld(&__lhef__HEPRUP_db_funcmem);
void __lhef__HEPRUP_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("lhef::HEPRUP"), typeid(::lhef::HEPRUP), sizeof(::lhef::HEPRUP), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HEPRUP"), destructor_19794, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29108, type_19757), Reflex::Literal("operator="), operator_19795, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19757), Reflex::Literal("HEPRUP"), constructor_19796, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HEPRUP"), constructor_19797, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4729, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__lhef__HEPRUP_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__lhef__HEPRUP_funcmem_bld);
}

//------Delayed data member builder for class HEPRUP -------------------
void __lhef__HEPRUP_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2767, Reflex::Literal("IDBMUP"), OffsetOf(__shadow__::__lhef__HEPRUP, IDBMUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2768, Reflex::Literal("EBMUP"), OffsetOf(__shadow__::__lhef__HEPRUP, EBMUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2767, Reflex::Literal("PDFGUP"), OffsetOf(__shadow__::__lhef__HEPRUP, PDFGUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2767, Reflex::Literal("PDFSUP"), OffsetOf(__shadow__::__lhef__HEPRUP, PDFSUP), ::Reflex::PUBLIC)
  .AddDataMember(type_67, Reflex::Literal("IDWTUP"), OffsetOf(__shadow__::__lhef__HEPRUP, IDWTUP), ::Reflex::PUBLIC)
  .AddDataMember(type_67, Reflex::Literal("NPRUP"), OffsetOf(__shadow__::__lhef__HEPRUP, NPRUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2807, Reflex::Literal("XSECUP"), OffsetOf(__shadow__::__lhef__HEPRUP, XSECUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2807, Reflex::Literal("XERRUP"), OffsetOf(__shadow__::__lhef__HEPRUP, XERRUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2807, Reflex::Literal("XMAXUP"), OffsetOf(__shadow__::__lhef__HEPRUP, XMAXUP), ::Reflex::PUBLIC)
  .AddDataMember(type_2802, Reflex::Literal("LPRUP"), OffsetOf(__shadow__::__lhef__HEPRUP, LPRUP), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class HEPRUP -------------------
void __lhef__HEPRUP_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19757), Reflex::Literal("operator=="), operator_19798, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_67), Reflex::Literal("resize"), method_19799, 0, "nrup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169), Reflex::Literal("resize"), method_19800, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class XSec -------------------------------
static void destructor_19876(void*, void * o, const std::vector<void*>&, void *) {
(((::GenRunInfoProduct::XSec*)o)->::GenRunInfoProduct::XSec::~XSec)();
}
static  void operator_19877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenRunInfoProduct::XSec*)o)->operator=)(*(const ::GenRunInfoProduct::XSec*)arg[0]);
  else   (((::GenRunInfoProduct::XSec*)o)->operator=)(*(const ::GenRunInfoProduct::XSec*)arg[0]);
}

static void constructor_19878( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenRunInfoProduct::XSec();
  else ::new(mem) ::GenRunInfoProduct::XSec();
}

static void constructor_19879( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenRunInfoProduct::XSec(*(double*)arg[0]);
  else ::new(mem) ::GenRunInfoProduct::XSec(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenRunInfoProduct::XSec(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::GenRunInfoProduct::XSec(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static void constructor_19880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenRunInfoProduct::XSec(*(const ::GenRunInfoProduct::XSec*)arg[0]);
  else ::new(mem) ::GenRunInfoProduct::XSec(*(const ::GenRunInfoProduct::XSec*)arg[0]);
}

static  void method_19881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenRunInfoProduct::XSec*)o)->value)());
  else   (((const ::GenRunInfoProduct::XSec*)o)->value)();
}

static  void method_19882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenRunInfoProduct::XSec*)o)->error)());
  else   (((const ::GenRunInfoProduct::XSec*)o)->error)();
}

static  void method_19883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenRunInfoProduct::XSec*)o)->isSet)());
  else   (((const ::GenRunInfoProduct::XSec*)o)->isSet)();
}

static  void method_19884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenRunInfoProduct::XSec*)o)->hasError)());
  else   (((const ::GenRunInfoProduct::XSec*)o)->hasError)();
}

static  void converter_19885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenRunInfoProduct::XSec*)o)->operator double)());
  else   (((const ::GenRunInfoProduct::XSec*)o)->operator double)();
}

static  void converter_19886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenRunInfoProduct::XSec*)o)->operator bool)());
  else   (((const ::GenRunInfoProduct::XSec*)o)->operator bool)();
}

static  void operator_19887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenRunInfoProduct::XSec*)o)->operator==)(*(const ::GenRunInfoProduct::XSec*)arg[0]));
  else   (((const ::GenRunInfoProduct::XSec*)o)->operator==)(*(const ::GenRunInfoProduct::XSec*)arg[0]);
}

static  void operator_19888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenRunInfoProduct::XSec*)o)->operator!=)(*(const ::GenRunInfoProduct::XSec*)arg[0]));
  else   (((const ::GenRunInfoProduct::XSec*)o)->operator!=)(*(const ::GenRunInfoProduct::XSec*)arg[0]);
}

static void method_newdel_5075( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct::XSec >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct::XSec >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct::XSec >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct::XSec >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenRunInfoProduct::XSec >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class XSec -------------------------------
void __GenRunInfoProduct__XSec_db_datamem(Reflex::Class*);
void __GenRunInfoProduct__XSec_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenRunInfoProduct__XSec_datamem_bld(&__GenRunInfoProduct__XSec_db_datamem);
Reflex::GenreflexMemberBuilder __GenRunInfoProduct__XSec_funcmem_bld(&__GenRunInfoProduct__XSec_db_funcmem);
void __GenRunInfoProduct__XSec_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenRunInfoProduct::XSec"), typeid(::GenRunInfoProduct::XSec), sizeof(::GenRunInfoProduct::XSec), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~XSec"), destructor_19876, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29132, type_19891), Reflex::Literal("operator="), operator_19877, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("XSec"), constructor_19878, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_102, type_102), Reflex::Literal("XSec"), constructor_19879, 0, "value;error=-1.0e+0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19891), Reflex::Literal("XSec"), constructor_19880, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5075, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenRunInfoProduct__XSec_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenRunInfoProduct__XSec_funcmem_bld);
}

//------Delayed data member builder for class XSec -------------------
void __GenRunInfoProduct__XSec_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_102, Reflex::Literal("value_"), OffsetOf(__shadow__::__GenRunInfoProduct__XSec, value_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("error_"), OffsetOf(__shadow__::__GenRunInfoProduct__XSec, error_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class XSec -------------------
void __GenRunInfoProduct__XSec_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("value"), method_19881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("error"), method_19882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isSet"), method_19883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasError"), method_19884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("operator double"), converter_19885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("operator bool"), converter_19886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19891), Reflex::Literal("operator=="), operator_19887, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_19891), Reflex::Literal("operator!="), operator_19888, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class XSec -------------------------------
static void destructor_22323(void*, void * o, const std::vector<void*>&, void *) {
(((::GenLumiInfoProduct::XSec*)o)->::GenLumiInfoProduct::XSec::~XSec)();
}
static  void operator_22324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenLumiInfoProduct::XSec*)o)->operator=)(*(const ::GenLumiInfoProduct::XSec*)arg[0]);
  else   (((::GenLumiInfoProduct::XSec*)o)->operator=)(*(const ::GenLumiInfoProduct::XSec*)arg[0]);
}

static void constructor_22325( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::XSec();
  else ::new(mem) ::GenLumiInfoProduct::XSec();
}

static void constructor_22326( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::XSec(*(double*)arg[0]);
  else ::new(mem) ::GenLumiInfoProduct::XSec(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::XSec(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::GenLumiInfoProduct::XSec(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static void constructor_22327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::XSec(*(const ::GenLumiInfoProduct::XSec*)arg[0]);
  else ::new(mem) ::GenLumiInfoProduct::XSec(*(const ::GenLumiInfoProduct::XSec*)arg[0]);
}

static  void method_22328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenLumiInfoProduct::XSec*)o)->value)());
  else   (((const ::GenLumiInfoProduct::XSec*)o)->value)();
}

static  void method_22329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenLumiInfoProduct::XSec*)o)->error)());
  else   (((const ::GenLumiInfoProduct::XSec*)o)->error)();
}

static  void method_22330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct::XSec*)o)->isSet)());
  else   (((const ::GenLumiInfoProduct::XSec*)o)->isSet)();
}

static  void method_22331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct::XSec*)o)->hasError)());
  else   (((const ::GenLumiInfoProduct::XSec*)o)->hasError)();
}

static  void converter_22332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenLumiInfoProduct::XSec*)o)->operator double)());
  else   (((const ::GenLumiInfoProduct::XSec*)o)->operator double)();
}

static  void converter_22333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct::XSec*)o)->operator bool)());
  else   (((const ::GenLumiInfoProduct::XSec*)o)->operator bool)();
}

static  void operator_22334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct::XSec*)o)->operator==)(*(const ::GenLumiInfoProduct::XSec*)arg[0]));
  else   (((const ::GenLumiInfoProduct::XSec*)o)->operator==)(*(const ::GenLumiInfoProduct::XSec*)arg[0]);
}

static  void operator_22335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct::XSec*)o)->operator!=)(*(const ::GenLumiInfoProduct::XSec*)arg[0]));
  else   (((const ::GenLumiInfoProduct::XSec*)o)->operator!=)(*(const ::GenLumiInfoProduct::XSec*)arg[0]);
}

static void method_newdel_5599( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::XSec >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::XSec >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::XSec >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::XSec >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::XSec >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class XSec -------------------------------
void __GenLumiInfoProduct__XSec_db_datamem(Reflex::Class*);
void __GenLumiInfoProduct__XSec_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct__XSec_datamem_bld(&__GenLumiInfoProduct__XSec_db_datamem);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct__XSec_funcmem_bld(&__GenLumiInfoProduct__XSec_db_funcmem);
void __GenLumiInfoProduct__XSec_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenLumiInfoProduct::XSec"), typeid(::GenLumiInfoProduct::XSec), sizeof(::GenLumiInfoProduct::XSec), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~XSec"), destructor_22323, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29533, type_29534), Reflex::Literal("operator="), operator_22324, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("XSec"), constructor_22325, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_102, type_102), Reflex::Literal("XSec"), constructor_22326, 0, "v;e=-1.0e+0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29534), Reflex::Literal("XSec"), constructor_22327, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5599, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenLumiInfoProduct__XSec_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenLumiInfoProduct__XSec_funcmem_bld);
}

//------Delayed data member builder for class XSec -------------------
void __GenLumiInfoProduct__XSec_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_102, Reflex::Literal("value_"), OffsetOf(__shadow__::__GenLumiInfoProduct__XSec, value_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("error_"), OffsetOf(__shadow__::__GenLumiInfoProduct__XSec, error_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class XSec -------------------
void __GenLumiInfoProduct__XSec_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("value"), method_22328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("error"), method_22329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("isSet"), method_22330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("hasError"), method_22331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("operator double"), converter_22332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441), Reflex::Literal("operator bool"), converter_22333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_29534), Reflex::Literal("operator=="), operator_22334, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_29534), Reflex::Literal("operator!="), operator_22335, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class FinalStat -------------------------------
static void destructor_22378(void*, void * o, const std::vector<void*>&, void *) {
(((::GenLumiInfoProduct::FinalStat*)o)->::GenLumiInfoProduct::FinalStat::~FinalStat)();
}
static  void operator_22379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenLumiInfoProduct::FinalStat*)o)->operator=)(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]);
  else   (((::GenLumiInfoProduct::FinalStat*)o)->operator=)(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]);
}

static void constructor_22380( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::FinalStat();
  else ::new(mem) ::GenLumiInfoProduct::FinalStat();
}

static void constructor_22381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::FinalStat(*(unsigned int*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::GenLumiInfoProduct::FinalStat(*(unsigned int*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_22382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenLumiInfoProduct::FinalStat(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]);
  else ::new(mem) ::GenLumiInfoProduct::FinalStat(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]);
}

static  void method_22383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::GenLumiInfoProduct::FinalStat*)o)->n)());
  else   (((const ::GenLumiInfoProduct::FinalStat*)o)->n)();
}

static  void method_22384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenLumiInfoProduct::FinalStat*)o)->sum)());
  else   (((const ::GenLumiInfoProduct::FinalStat*)o)->sum)();
}

static  void method_22385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GenLumiInfoProduct::FinalStat*)o)->sum2)());
  else   (((const ::GenLumiInfoProduct::FinalStat*)o)->sum2)();
}

static  void method_22386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenLumiInfoProduct::FinalStat*)o)->add)(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]);
}

static  void operator_22387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct::FinalStat*)o)->operator==)(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]));
  else   (((const ::GenLumiInfoProduct::FinalStat*)o)->operator==)(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]);
}

static  void operator_22388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenLumiInfoProduct::FinalStat*)o)->operator!=)(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]));
  else   (((const ::GenLumiInfoProduct::FinalStat*)o)->operator!=)(*(const ::GenLumiInfoProduct::FinalStat*)arg[0]);
}

static void method_newdel_5601( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::FinalStat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::FinalStat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::FinalStat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::FinalStat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenLumiInfoProduct::FinalStat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FinalStat -------------------------------
void __GenLumiInfoProduct__FinalStat_db_datamem(Reflex::Class*);
void __GenLumiInfoProduct__FinalStat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct__FinalStat_datamem_bld(&__GenLumiInfoProduct__FinalStat_db_datamem);
Reflex::GenreflexMemberBuilder __GenLumiInfoProduct__FinalStat_funcmem_bld(&__GenLumiInfoProduct__FinalStat_db_funcmem);
void __GenLumiInfoProduct__FinalStat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenLumiInfoProduct::FinalStat"), typeid(::GenLumiInfoProduct::FinalStat), sizeof(::GenLumiInfoProduct::FinalStat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FinalStat"), destructor_22378, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29535, type_29536), Reflex::Literal("operator="), operator_22379, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FinalStat"), constructor_22380, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_198, type_102, type_102), Reflex::Literal("FinalStat"), constructor_22381, 0, "n1;sum1;sum21", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29536), Reflex::Literal("FinalStat"), constructor_22382, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5601, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenLumiInfoProduct__FinalStat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenLumiInfoProduct__FinalStat_funcmem_bld);
}

//------Delayed data member builder for class FinalStat -------------------
void __GenLumiInfoProduct__FinalStat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_198, Reflex::Literal("n_"), OffsetOf(__shadow__::__GenLumiInfoProduct__FinalStat, n_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sum_"), OffsetOf(__shadow__::__GenLumiInfoProduct__FinalStat, sum_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sum2_"), OffsetOf(__shadow__::__GenLumiInfoProduct__FinalStat, sum2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class FinalStat -------------------
void __GenLumiInfoProduct__FinalStat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_198), Reflex::Literal("n"), method_22383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sum"), method_22384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sum2"), method_22385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2169, type_29536), Reflex::Literal("add"), method_22386, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_29536), Reflex::Literal("operator=="), operator_22387, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_29536), Reflex::Literal("operator!="), operator_22388, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vertex_const_iterator -------------------------------
static void constructor_24966( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::vertex_const_iterator(*(const ::std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::vertex_const_iterator(*(const ::std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0]);
}

static void constructor_24967( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::vertex_const_iterator();
  else ::new(mem) ::HepMC::GenEvent::vertex_const_iterator();
}

static void constructor_24968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::vertex_const_iterator(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::vertex_const_iterator(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]);
}

static void destructor_24969(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenEvent::vertex_const_iterator*)o)->::HepMC::GenEvent::vertex_const_iterator::~vertex_const_iterator)();
}
static  void operator_24970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::vertex_const_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]);
  else   (((::HepMC::GenEvent::vertex_const_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]);
}

static  void operator_24971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent::vertex_const_iterator*)o)->operator*)());
  else   (((const ::HepMC::GenEvent::vertex_const_iterator*)o)->operator*)();
}

static  void operator_24972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::vertex_const_iterator*)o)->operator++)();
  else   (((::HepMC::GenEvent::vertex_const_iterator*)o)->operator++)();
}

static  void operator_24973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::vertex_const_iterator)((((::HepMC::GenEvent::vertex_const_iterator*)o)->operator++)(*(int*)arg[0]));
  else   (((::HepMC::GenEvent::vertex_const_iterator*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_24974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::vertex_const_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::vertex_const_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]);
}

static  void operator_24975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::vertex_const_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::vertex_const_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::vertex_const_iterator*)arg[0]);
}

static void method_newdel_15545( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_const_iterator >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_const_iterator >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_const_iterator >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_const_iterator >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_const_iterator >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x75( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>")), ::Reflex::BaseOffset< ::HepMC::GenEvent::vertex_const_iterator,::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class vertex_const_iterator -------------------------------
void __HepMC__GenEvent__vertex_const_iterator_db_datamem(Reflex::Class*);
void __HepMC__GenEvent__vertex_const_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__vertex_const_iterator_datamem_bld(&__HepMC__GenEvent__vertex_const_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__vertex_const_iterator_funcmem_bld(&__HepMC__GenEvent__vertex_const_iterator_db_funcmem);
void __HepMC__GenEvent__vertex_const_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenEvent::vertex_const_iterator"), typeid(::HepMC::GenEvent::vertex_const_iterator), sizeof(::HepMC::GenEvent::vertex_const_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2677, ::Reflex::BaseOffset< ::HepMC::GenEvent::vertex_const_iterator, ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24153), Reflex::Literal("vertex_const_iterator"), constructor_24966, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vertex_const_iterator"), constructor_24967, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30196), Reflex::Literal("vertex_const_iterator"), constructor_24968, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vertex_const_iterator"), destructor_24969, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_15545, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x75, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenEvent__vertex_const_iterator_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenEvent__vertex_const_iterator_funcmem_bld);
}

//------Delayed data member builder for class vertex_const_iterator -------------------
void __HepMC__GenEvent__vertex_const_iterator_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2595, Reflex::Literal("m_map_iterator"), OffsetOf(__shadow__::__HepMC__GenEvent__vertex_const_iterator, m_map_iterator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class vertex_const_iterator -------------------
void __HepMC__GenEvent__vertex_const_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30197, type_30196), Reflex::Literal("operator="), operator_24970, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9248), Reflex::Literal("operator*"), operator_24971, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30197), Reflex::Literal("operator++"), operator_24972, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15545, type_67), Reflex::Literal("operator++"), operator_24973, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30196), Reflex::Literal("operator=="), operator_24974, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30196), Reflex::Literal("operator!="), operator_24975, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vertex_iterator -------------------------------
static void constructor_24979( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::vertex_iterator(*(const ::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::vertex_iterator(*(const ::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenVertex*> >*)arg[0]);
}

static void constructor_24980( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::vertex_iterator();
  else ::new(mem) ::HepMC::GenEvent::vertex_iterator();
}

static void constructor_24981( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::vertex_iterator(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::vertex_iterator(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]);
}

static void destructor_24982(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenEvent::vertex_iterator*)o)->::HepMC::GenEvent::vertex_iterator::~vertex_iterator)();
}
static  void operator_24983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::vertex_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]);
  else   (((::HepMC::GenEvent::vertex_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]);
}

static  void converter_24984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::vertex_const_iterator)((((const ::HepMC::GenEvent::vertex_iterator*)o)->operator HepMC::GenEvent::vertex_const_iterator)());
  else   (((const ::HepMC::GenEvent::vertex_iterator*)o)->operator HepMC::GenEvent::vertex_const_iterator)();
}

static  void operator_24985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent::vertex_iterator*)o)->operator*)());
  else   (((const ::HepMC::GenEvent::vertex_iterator*)o)->operator*)();
}

static  void operator_24986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::vertex_iterator*)o)->operator++)();
  else   (((::HepMC::GenEvent::vertex_iterator*)o)->operator++)();
}

static  void operator_24987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::vertex_iterator)((((::HepMC::GenEvent::vertex_iterator*)o)->operator++)(*(int*)arg[0]));
  else   (((::HepMC::GenEvent::vertex_iterator*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_24988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::vertex_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::vertex_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]);
}

static  void operator_24989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::vertex_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::vertex_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::vertex_iterator*)arg[0]);
}

static void method_newdel_15546( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_iterator >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_iterator >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_iterator >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_iterator >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::vertex_iterator >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x77( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&>")), ::Reflex::BaseOffset< ::HepMC::GenEvent::vertex_iterator,::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class vertex_iterator -------------------------------
void __HepMC__GenEvent__vertex_iterator_db_datamem(Reflex::Class*);
void __HepMC__GenEvent__vertex_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__vertex_iterator_datamem_bld(&__HepMC__GenEvent__vertex_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__vertex_iterator_funcmem_bld(&__HepMC__GenEvent__vertex_iterator_db_funcmem);
void __HepMC__GenEvent__vertex_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenEvent::vertex_iterator"), typeid(::HepMC::GenEvent::vertex_iterator), sizeof(::HepMC::GenEvent::vertex_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2677, ::Reflex::BaseOffset< ::HepMC::GenEvent::vertex_iterator, ::std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24154), Reflex::Literal("vertex_iterator"), constructor_24979, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vertex_iterator"), constructor_24980, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30198), Reflex::Literal("vertex_iterator"), constructor_24981, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vertex_iterator"), destructor_24982, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_15546, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x77, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenEvent__vertex_iterator_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenEvent__vertex_iterator_funcmem_bld);
}

//------Delayed data member builder for class vertex_iterator -------------------
void __HepMC__GenEvent__vertex_iterator_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2891, Reflex::Literal("m_map_iterator"), OffsetOf(__shadow__::__HepMC__GenEvent__vertex_iterator, m_map_iterator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class vertex_iterator -------------------
void __HepMC__GenEvent__vertex_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30199, type_30198), Reflex::Literal("operator="), operator_24983, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15545), Reflex::Literal("operator HepMC::GenEvent::vertex_const_iterator"), converter_24984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9248), Reflex::Literal("operator*"), operator_24985, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30199), Reflex::Literal("operator++"), operator_24986, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15546, type_67), Reflex::Literal("operator++"), operator_24987, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30198), Reflex::Literal("operator=="), operator_24988, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30198), Reflex::Literal("operator!="), operator_24989, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class particle_const_iterator -------------------------------
static void constructor_24993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::particle_const_iterator(*(const ::std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::particle_const_iterator(*(const ::std::_Rb_tree_const_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0]);
}

static void constructor_24994( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::particle_const_iterator();
  else ::new(mem) ::HepMC::GenEvent::particle_const_iterator();
}

static void constructor_24995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::particle_const_iterator(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::particle_const_iterator(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]);
}

static void destructor_24996(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenEvent::particle_const_iterator*)o)->::HepMC::GenEvent::particle_const_iterator::~particle_const_iterator)();
}
static  void operator_24997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::particle_const_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]);
  else   (((::HepMC::GenEvent::particle_const_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]);
}

static  void operator_24998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent::particle_const_iterator*)o)->operator*)());
  else   (((const ::HepMC::GenEvent::particle_const_iterator*)o)->operator*)();
}

static  void operator_24999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::particle_const_iterator*)o)->operator++)();
  else   (((::HepMC::GenEvent::particle_const_iterator*)o)->operator++)();
}

static  void operator_25000( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::particle_const_iterator)((((::HepMC::GenEvent::particle_const_iterator*)o)->operator++)(*(int*)arg[0]));
  else   (((::HepMC::GenEvent::particle_const_iterator*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_25001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::particle_const_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::particle_const_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]);
}

static  void operator_25002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::particle_const_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::particle_const_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::particle_const_iterator*)arg[0]);
}

static void method_newdel_15547( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_const_iterator >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_const_iterator >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_const_iterator >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_const_iterator >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_const_iterator >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x79( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>")), ::Reflex::BaseOffset< ::HepMC::GenEvent::particle_const_iterator,::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class particle_const_iterator -------------------------------
void __HepMC__GenEvent__particle_const_iterator_db_datamem(Reflex::Class*);
void __HepMC__GenEvent__particle_const_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__particle_const_iterator_datamem_bld(&__HepMC__GenEvent__particle_const_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__particle_const_iterator_funcmem_bld(&__HepMC__GenEvent__particle_const_iterator_db_funcmem);
void __HepMC__GenEvent__particle_const_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenEvent::particle_const_iterator"), typeid(::HepMC::GenEvent::particle_const_iterator), sizeof(::HepMC::GenEvent::particle_const_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2676, ::Reflex::BaseOffset< ::HepMC::GenEvent::particle_const_iterator, ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24156), Reflex::Literal("particle_const_iterator"), constructor_24993, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("particle_const_iterator"), constructor_24994, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30200), Reflex::Literal("particle_const_iterator"), constructor_24995, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~particle_const_iterator"), destructor_24996, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_15547, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x79, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenEvent__particle_const_iterator_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenEvent__particle_const_iterator_funcmem_bld);
}

//------Delayed data member builder for class particle_const_iterator -------------------
void __HepMC__GenEvent__particle_const_iterator_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2596, Reflex::Literal("m_map_iterator"), OffsetOf(__shadow__::__HepMC__GenEvent__particle_const_iterator, m_map_iterator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class particle_const_iterator -------------------
void __HepMC__GenEvent__particle_const_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30201, type_30200), Reflex::Literal("operator="), operator_24997, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6865), Reflex::Literal("operator*"), operator_24998, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30201), Reflex::Literal("operator++"), operator_24999, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15547, type_67), Reflex::Literal("operator++"), operator_25000, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30200), Reflex::Literal("operator=="), operator_25001, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30200), Reflex::Literal("operator!="), operator_25002, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class particle_iterator -------------------------------
static void constructor_25006( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::particle_iterator(*(const ::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::particle_iterator(*(const ::std::_Rb_tree_iterator<std::pair<const int,HepMC::GenParticle*> >*)arg[0]);
}

static void constructor_25007( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::particle_iterator();
  else ::new(mem) ::HepMC::GenEvent::particle_iterator();
}

static void constructor_25008( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HepMC::GenEvent::particle_iterator(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]);
  else ::new(mem) ::HepMC::GenEvent::particle_iterator(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]);
}

static void destructor_25009(void*, void * o, const std::vector<void*>&, void *) {
(((::HepMC::GenEvent::particle_iterator*)o)->::HepMC::GenEvent::particle_iterator::~particle_iterator)();
}
static  void operator_25010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::particle_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]);
  else   (((::HepMC::GenEvent::particle_iterator*)o)->operator=)(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]);
}

static  void converter_25011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::particle_const_iterator)((((const ::HepMC::GenEvent::particle_iterator*)o)->operator HepMC::GenEvent::particle_const_iterator)());
  else   (((const ::HepMC::GenEvent::particle_iterator*)o)->operator HepMC::GenEvent::particle_const_iterator)();
}

static  void operator_25012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HepMC::GenEvent::particle_iterator*)o)->operator*)());
  else   (((const ::HepMC::GenEvent::particle_iterator*)o)->operator*)();
}

static  void operator_25013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HepMC::GenEvent::particle_iterator*)o)->operator++)();
  else   (((::HepMC::GenEvent::particle_iterator*)o)->operator++)();
}

static  void operator_25014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (HepMC::GenEvent::particle_iterator)((((::HepMC::GenEvent::particle_iterator*)o)->operator++)(*(int*)arg[0]));
  else   (((::HepMC::GenEvent::particle_iterator*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_25015( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::particle_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::particle_iterator*)o)->operator==)(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]);
}

static  void operator_25016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HepMC::GenEvent::particle_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]));
  else   (((const ::HepMC::GenEvent::particle_iterator*)o)->operator!=)(*(const ::HepMC::GenEvent::particle_iterator*)arg[0]);
}

static void method_newdel_15548( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_iterator >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_iterator >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_iterator >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_iterator >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HepMC::GenEvent::particle_iterator >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x81( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&>")), ::Reflex::BaseOffset< ::HepMC::GenEvent::particle_iterator,::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class particle_iterator -------------------------------
void __HepMC__GenEvent__particle_iterator_db_datamem(Reflex::Class*);
void __HepMC__GenEvent__particle_iterator_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__particle_iterator_datamem_bld(&__HepMC__GenEvent__particle_iterator_db_datamem);
Reflex::GenreflexMemberBuilder __HepMC__GenEvent__particle_iterator_funcmem_bld(&__HepMC__GenEvent__particle_iterator_db_funcmem);
void __HepMC__GenEvent__particle_iterator_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HepMC::GenEvent::particle_iterator"), typeid(::HepMC::GenEvent::particle_iterator), sizeof(::HepMC::GenEvent::particle_iterator), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2676, ::Reflex::BaseOffset< ::HepMC::GenEvent::particle_iterator, ::std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24157), Reflex::Literal("particle_iterator"), constructor_25006, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("particle_iterator"), constructor_25007, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30202), Reflex::Literal("particle_iterator"), constructor_25008, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~particle_iterator"), destructor_25009, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_15548, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x81, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HepMC__GenEvent__particle_iterator_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HepMC__GenEvent__particle_iterator_funcmem_bld);
}

//------Delayed data member builder for class particle_iterator -------------------
void __HepMC__GenEvent__particle_iterator_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2892, Reflex::Literal("m_map_iterator"), OffsetOf(__shadow__::__HepMC__GenEvent__particle_iterator, m_map_iterator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class particle_iterator -------------------
void __HepMC__GenEvent__particle_iterator_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30203, type_30202), Reflex::Literal("operator="), operator_25010, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15547), Reflex::Literal("operator HepMC::GenEvent::particle_const_iterator"), converter_25011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6865), Reflex::Literal("operator*"), operator_25012, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30203), Reflex::Literal("operator++"), operator_25013, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15548, type_67), Reflex::Literal("operator++"), operator_25014, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30202), Reflex::Literal("operator=="), operator_25015, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1441, type_30202), Reflex::Literal("operator!="), operator_25016, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __GenEventInfoProduct_dict(); 
      __LHEEventProduct_dict(); 
      __LHEXMLStringProduct_dict(); 
      __LHERunInfoProduct_dict(); 
      __GenFilterInfo_dict(); 
      __GenRunInfoProduct_dict(); 
      __GenLumiInfoProduct_dict(); 
      __gen__PdfInfo_dict(); 
      __std__auto_ptr_gen__PdfInfo__dict(); 
      __std__iterator_std__forward_iterator_tag_HepMC__GenParticlep_long_HepMC__GenParticlepp_HepMC__GenParticlepr__dict(); 
      __std__iterator_std__forward_iterator_tag_HepMC__GenVertexp_long_HepMC__GenVertexpp_HepMC__GenVertexpr__dict(); 
      __std__pair_constsint_HepMC__GenVertexp__dict(); 
      __std__pair_constsint_HepMC__GenParticlep__dict(); 
      __gen__WeightsInfo_dict(); 
      __std__vector_gen__WeightsInfo__dict(); 
      __std__vector_constsedm__HepMCProductp__dict(); 
      __std__vector_HepMC__GenParticlep__dict(); 
      __GenLumiInfoProduct__ProcessInfo_dict(); 
      __std__vector_GenLumiInfoProduct__ProcessInfo__dict(); 
      __LHERunInfoProduct__Header_dict(); 
      __std__vector_LHERunInfoProduct__Header__dict(); 
      __lhef__HEPEUP_dict(); 
      __lhef__HEPEUP__FiveVector_dict(); 
      __std__vector_lhef__HEPEUP__FiveVector__dict(); 
      __std__map_int_HepMC__GenVertexp_std__greater_int_s__dict(); 
      __std__map_int_HepMC__GenParticlep__dict(); 
      __std__map_int_HepMC__GenVertexp__dict(); 
      __HepMC__PdfInfo_dict(); 
      __HepMC__GenCrossSection_dict(); 
      __HepMC__GenParticle_dict(); 
      __HepMC__Flow_dict(); 
      __HepMC__FourVector_dict(); 
      __HepMC__HeavyIon_dict(); 
      __HepMC__WeightContainer_dict(); 
      __HepMC__Polarization_dict(); 
      __HepMC__GenVertex_dict(); 
      __HepMC__GenEvent_dict(); 
      __edm__RefVector_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__dict(); 
      __edm__RefVector_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__dict(); 
      __edm__Wrapper_LHEXMLStringProduct__dict(); 
      __edm__Wrapper_LHEEventProduct__dict(); 
      __edm__Wrapper_LHERunInfoProduct__dict(); 
      __edm__Wrapper_GenLumiInfoProduct__dict(); 
      __edm__Wrapper_GenEventInfoProduct__dict(); 
      __edm__Wrapper_GenFilterInfo__dict(); 
      __edm__Wrapper_GenRunInfoProduct__dict(); 
      __edm__HepMCProduct_dict(); 
      __edm__Wrapper_edm__HepMCProduct__dict(); 
      __edm__Ref_edm__HepMCProduct_HepMC__GenVertex_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenVertex___Find__dict(); 
      __edm__Ref_edm__HepMCProduct_HepMC__GenParticle_edm__refhelper__FindTrait_edm__HepMCProduct_HepMC__GenParticle___Find__dict(); 
      __lhef__HEPRUP_dict(); 
      __GenRunInfoProduct__XSec_dict(); 
      __GenLumiInfoProduct__XSec_dict(); 
      __GenLumiInfoProduct__FinalStat_dict(); 
      __HepMC__GenEvent__vertex_const_iterator_dict(); 
      __HepMC__GenEvent__vertex_iterator_dict(); 
      __HepMC__GenEvent__particle_const_iterator_dict(); 
      __HepMC__GenEvent__particle_iterator_dict(); 
    }
    ~Dictionaries() {
      type_341.Unload(); // class GenEventInfoProduct 
      type_459.Unload(); // class LHEEventProduct 
      type_690.Unload(); // class LHEXMLStringProduct 
      type_818.Unload(); // class LHERunInfoProduct 
      type_866.Unload(); // class GenFilterInfo 
      type_1341.Unload(); // class GenRunInfoProduct 
      type_1920.Unload(); // class GenLumiInfoProduct 
      type_4043.Unload(); // class gen::PdfInfo 
      type_2551.Unload(); // class std::auto_ptr<gen::PdfInfo> 
      type_2676.Unload(); // class std::iterator<std::forward_iterator_tag,HepMC::GenParticle*,long,HepMC::GenParticle**,HepMC::GenParticle*&> 
      type_2677.Unload(); // class std::iterator<std::forward_iterator_tag,HepMC::GenVertex*,long,HepMC::GenVertex**,HepMC::GenVertex*&> 
      type_2751.Unload(); // class std::pair<const int,HepMC::GenVertex*> 
      type_2752.Unload(); // class std::pair<const int,HepMC::GenParticle*> 
      type_4248.Unload(); // class gen::WeightsInfo 
      type_2801.Unload(); // class std::vector<gen::WeightsInfo> 
      type_2803.Unload(); // class std::vector<const edm::HepMCProduct*> 
      type_2804.Unload(); // class std::vector<HepMC::GenParticle*> 
      type_5600.Unload(); // class GenLumiInfoProduct::ProcessInfo 
      type_2805.Unload(); // class std::vector<GenLumiInfoProduct::ProcessInfo> 
      type_4660.Unload(); // class LHERunInfoProduct::Header 
      type_2812.Unload(); // class std::vector<LHERunInfoProduct::Header> 
      type_4728.Unload(); // class lhef::HEPEUP 
      type_10846.Unload(); // class lhef::HEPEUP::FiveVector 
      type_2814.Unload(); // class std::vector<lhef::HEPEUP::FiveVector> 
      type_2955.Unload(); // class std::map<int,HepMC::GenVertex*,std::greater<int> > 
      type_2956.Unload(); // class std::map<int,HepMC::GenParticle*> 
      type_2957.Unload(); // class std::map<int,HepMC::GenVertex*> 
      type_3447.Unload(); // class HepMC::PdfInfo 
      type_3448.Unload(); // class HepMC::GenCrossSection 
      type_3450.Unload(); // class HepMC::GenParticle 
      type_3453.Unload(); // class HepMC::Flow 
      type_3455.Unload(); // class HepMC::FourVector 
      type_3459.Unload(); // class HepMC::HeavyIon 
      type_3474.Unload(); // class HepMC::WeightContainer 
      type_3475.Unload(); // class HepMC::Polarization 
      type_3482.Unload(); // class HepMC::GenVertex 
      type_3486.Unload(); // class HepMC::GenEvent 
      type_4093.Unload(); // class edm::RefVector<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> 
      type_4094.Unload(); // class edm::RefVector<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> 
      type_4103.Unload(); // class edm::Wrapper<LHEXMLStringProduct> 
      type_4104.Unload(); // class edm::Wrapper<LHEEventProduct> 
      type_4105.Unload(); // class edm::Wrapper<LHERunInfoProduct> 
      type_4106.Unload(); // class edm::Wrapper<GenLumiInfoProduct> 
      type_4107.Unload(); // class edm::Wrapper<GenEventInfoProduct> 
      type_4108.Unload(); // class edm::Wrapper<GenFilterInfo> 
      type_4109.Unload(); // class edm::Wrapper<GenRunInfoProduct> 
      type_4198.Unload(); // class edm::HepMCProduct 
      type_4110.Unload(); // class edm::Wrapper<edm::HepMCProduct> 
      type_4196.Unload(); // class edm::Ref<edm::HepMCProduct,HepMC::GenVertex,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenVertex>::Find> 
      type_4197.Unload(); // class edm::Ref<edm::HepMCProduct,HepMC::GenParticle,edm::refhelper::FindTrait<edm::HepMCProduct,HepMC::GenParticle>::Find> 
      type_4729.Unload(); // class lhef::HEPRUP 
      type_5075.Unload(); // class GenRunInfoProduct::XSec 
      type_5599.Unload(); // class GenLumiInfoProduct::XSec 
      type_5601.Unload(); // class GenLumiInfoProduct::FinalStat 
      type_15545.Unload(); // class HepMC::GenEvent::vertex_const_iterator 
      type_15546.Unload(); // class HepMC::GenEvent::vertex_iterator 
      type_15547.Unload(); // class HepMC::GenEvent::particle_const_iterator 
      type_15548.Unload(); // class HepMC::GenEvent::particle_iterator 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
